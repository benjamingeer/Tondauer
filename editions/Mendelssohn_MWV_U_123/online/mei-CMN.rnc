namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
default namespace ns1 = "http://www.music-encoding.org/ns/mei"
namespace ns2 = "http://www.w3.org/2000/svg"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace tei = "http://www.tei-c.org/ns/1.0"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xi = "http://www.w3.org/2001/XInclude"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2019-04-12T14:02:17Z. .
# TEI Edition: Version 4.0.0
# TEI Edition Location: http://www.tei-c.org/Vault/P5//
#

#

sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
div {
  svg_Boolean.datatype = "false" | "true"
  svg_ClipFillRule.datatype = "nonzero" | "evenodd" | "inherit"
  svg_ContentType.datatype = string
  svg_Coordinate.datatype = string
  svg_Coordinates.datatype = string
  svg_Color.datatype = string
  svg_Integer.datatype = string
  svg_LanguageCode.datatype = xsd:NMTOKEN
  svg_LanguageCodes.datatype = string
  svg_Length.datatype = string
  svg_Lengths.datatype = string
  svg_Number.datatype = string
  svg_Numbers.datatype = string
  svg_OpacityValue.datatype = string
  svg_PathData.datatype = string
  svg_PreserveAspectRatioSpec.datatype = string
  svg_Script.datatype = string
  svg_SVGColor.datatype = string
  svg_Text.datatype = string
  svg_TransformList.datatype = string
  svg_URI.datatype = string
  svg_ViewBoxSpec.datatype = string
  svg_XLINK.xmlns.attrib = empty
  svg_SVG.xmlns.attrib = svg_XLINK.xmlns.attrib
  svg_SVG.Description.extra.class = notAllowed
  svg_SVG.Description.class =
    svg_desc
    | svg_title
    | svg_metadata
    | svg_SVG.Description.extra.class
  svg_SVG.Use.extra.class = notAllowed
  svg_SVG.Use.class = svg_use | svg_SVG.Use.extra.class
  svg_SVG.Structure.extra.class = notAllowed
  svg_SVG.Structure.class =
    svg_svg
    | svg_g
    | svg_defs
    | svg_symbol
    | svg_SVG.Use.class
    | svg_SVG.Structure.extra.class
  svg_SVG.Conditional.extra.class = notAllowed
  svg_SVG.Conditional.class =
    svg_switch | svg_SVG.Conditional.extra.class
  svg_SVG.Image.extra.class = notAllowed
  svg_SVG.Image.class = svg_image | svg_SVG.Image.extra.class
  svg_SVG.Style.extra.class = notAllowed
  svg_SVG.Style.class = svg_style | svg_SVG.Style.extra.class
  svg_SVG.Shape.extra.class = notAllowed
  svg_SVG.Shape.class =
    svg_path
    | svg_rect
    | svg_circle
    | svg_line
    | svg_ellipse
    | svg_polyline
    | svg_polygon
    | svg_SVG.Shape.extra.class
  svg_SVG.Text.extra.class = notAllowed
  svg_SVG.Text.class =
    svg_text | svg_altGlyphDef | svg_SVG.Text.extra.class
  svg_SVG.TextContent.extra.class = notAllowed
  svg_SVG.TextContent.class =
    svg_tspan
    | svg_tref
    | svg_textPath
    | svg_altGlyph
    | svg_SVG.TextContent.extra.class
  svg_SVG.Marker.extra.class = notAllowed
  svg_SVG.Marker.class = svg_marker | svg_SVG.Marker.extra.class
  svg_SVG.ColorProfile.extra.class = notAllowed
  svg_SVG.ColorProfile.class =
    svg_color-profile | svg_SVG.ColorProfile.extra.class
  svg_SVG.Gradient.extra.class = notAllowed
  svg_SVG.Gradient.class =
    svg_linearGradient
    | svg_radialGradient
    | svg_SVG.Gradient.extra.class
  svg_SVG.Pattern.extra.class = notAllowed
  svg_SVG.Pattern.class = svg_svgpattern | svg_SVG.Pattern.extra.class
  svg_SVG.Clip.extra.class = notAllowed
  svg_SVG.Clip.class = svg_clipPath | svg_SVG.Clip.extra.class
  svg_SVG.Mask.extra.class = notAllowed
  svg_SVG.Mask.class = svg_mask | svg_SVG.Mask.extra.class
  svg_SVG.Filter.extra.class = notAllowed
  svg_SVG.Filter.class = svg_filter | svg_SVG.Filter.extra.class
  svg_SVG.FilterPrimitive.extra.class = notAllowed
  svg_SVG.FilterPrimitive.class =
    svg_feBlend
    | svg_feColorMatrix
    | svg_feComponentTransfer
    | svg_feComposite
    | svg_feConvolveMatrix
    | svg_feDiffuseLighting
    | svg_feDisplacementMap
    | svg_feFlood
    | svg_feGaussianBlur
    | svg_feImage
    | svg_feMerge
    | svg_feMorphology
    | svg_feOffset
    | svg_feSpecularLighting
    | svg_feTile
    | svg_feTurbulence
    | svg_SVG.FilterPrimitive.extra.class
  svg_SVG.Cursor.extra.class = notAllowed
  svg_SVG.Cursor.class = svg_cursor | svg_SVG.Cursor.extra.class
  svg_SVG.Hyperlink.extra.class = notAllowed
  svg_SVG.Hyperlink.class = svg_a | svg_SVG.Hyperlink.extra.class
  svg_SVG.View.extra.class = notAllowed
  svg_SVG.View.class = svg_view | svg_SVG.View.extra.class
  svg_SVG.Script.extra.class = notAllowed
  svg_SVG.Script.class = svg_script | svg_SVG.Script.extra.class
  svg_SVG.Animation.extra.class = notAllowed
  svg_SVG.Animation.class =
    svg_animate
    | svg_set
    | svg_animateMotion
    | svg_animateColor
    | svg_animateTransform
    | svg_SVG.Animation.extra.class
  svg_SVG.Font.extra.class = notAllowed
  svg_SVG.Font.class =
    svg_font | svg_font-face | svg_SVG.Font.extra.class
  svg_SVG.Extensibility.extra.class = notAllowed
  svg_SVG.Extensibility.class =
    svg_foreignObject | svg_SVG.Extensibility.extra.class
  svg_ExtensionList.datatype = string
  svg_FeatureList.datatype = string
  svg_SVG.Conditional.extra.attrib = empty
  svg_SVG.Conditional.attrib =
    attribute requiredFeatures { svg_FeatureList.datatype }?,
    attribute requiredExtensions { svg_ExtensionList.datatype }?,
    attribute systemLanguage { svg_LanguageCodes.datatype }?,
    svg_SVG.Conditional.extra.attrib
  svg_ClassList.datatype = string
  svg_StyleSheet.datatype = string
  svg_SVG.Style.extra.attrib = empty
  svg_SVG.Style.attrib =
    attribute style { svg_StyleSheet.datatype }?,
    attribute class { svg_ClassList.datatype }?,
    svg_SVG.Style.extra.attrib
  svg_BaselineShiftValue.datatype = string
  svg_FontFamilyValue.datatype = string
  svg_FontSizeValue.datatype = string
  svg_FontSizeAdjustValue.datatype = string
  svg_GlyphOrientationHorizontalValue.datatype = string
  svg_GlyphOrientationVerticalValue.datatype = string
  svg_KerningValue.datatype = string
  svg_SpacingValue.datatype = string
  svg_TextDecorationValue.datatype = string
  svg_SVG.Text.extra.attrib = empty
  svg_SVG.Text.attrib =
    attribute writing-mode {
      "lr-tb" | "rl-tb" | "tb-rl" | "lr" | "rl" | "tb" | "inherit"
    }?,
    svg_SVG.Text.extra.attrib
  svg_SVG.TextContent.extra.attrib = empty
  svg_SVG.TextContent.attrib =
    attribute alignment-baseline {
      "auto"
      | "baseline"
      | "before-edge"
      | "text-before-edge"
      | "middle"
      | "central"
      | "after-edge"
      | "text-after-edge"
      | "ideographic"
      | "alphabetic"
      | "hanging"
      | "mathematical"
      | "inherit"
    }?,
    attribute baseline-shift { svg_BaselineShiftValue.datatype }?,
    attribute direction { "ltr" | "rtl" | "inherit" }?,
    attribute dominant-baseline {
      "auto"
      | "use-script"
      | "no-change"
      | "reset-size"
      | "ideographic"
      | "alphabetic"
      | "hanging"
      | "mathematical"
      | "central"
      | "middle"
      | "text-after-edge"
      | "text-before-edge"
      | "inherit"
    }?,
    attribute glyph-orientation-horizontal {
      svg_GlyphOrientationHorizontalValue.datatype
    }?,
    attribute glyph-orientation-vertical {
      svg_GlyphOrientationVerticalValue.datatype
    }?,
    attribute kerning { svg_KerningValue.datatype }?,
    attribute letter-spacing { svg_SpacingValue.datatype }?,
    attribute text-anchor { "start" | "middle" | "end" | "inherit" }?,
    attribute text-decoration { svg_TextDecorationValue.datatype }?,
    attribute unicode-bidi {
      "normal" | "embed" | "bidi-override" | "inherit"
    }?,
    attribute word-spacing { svg_SpacingValue.datatype }?,
    svg_SVG.TextContent.extra.attrib
  svg_SVG.Font.extra.attrib = empty
  svg_SVG.Font.attrib =
    attribute font-family { svg_FontFamilyValue.datatype }?,
    attribute font-size { svg_FontSizeValue.datatype }?,
    attribute font-size-adjust { svg_FontSizeAdjustValue.datatype }?,
    attribute font-stretch {
      "normal"
      | "wider"
      | "narrower"
      | "ultra-condensed"
      | "extra-condensed"
      | "condensed"
      | "semi-condensed"
      | "semi-expanded"
      | "expanded"
      | "extra-expanded"
      | "ultra-expanded"
      | "inherit"
    }?,
    attribute font-style {
      "normal" | "italic" | "oblique" | "inherit"
    }?,
    attribute font-variant { "normal" | "small-caps" | "inherit" }?,
    attribute font-weight {
      "normal"
      | "bold"
      | "bolder"
      | "lighter"
      | "100"
      | "200"
      | "300"
      | "400"
      | "500"
      | "600"
      | "700"
      | "800"
      | "900"
      | "inherit"
    }?,
    svg_SVG.Font.extra.attrib
  svg_MarkerValue.datatype = string
  svg_SVG.Marker.extra.attrib = empty
  svg_SVG.Marker.attrib =
    attribute marker-start { svg_MarkerValue.datatype }?,
    attribute marker-mid { svg_MarkerValue.datatype }?,
    attribute marker-end { svg_MarkerValue.datatype }?,
    svg_SVG.Marker.extra.attrib
  svg_SVG.ColorProfile.extra.attrib = empty
  svg_SVG.ColorProfile.attrib =
    attribute color-profile { text }?,
    svg_SVG.ColorProfile.extra.attrib
  svg_NumberOrPercentage.datatype = string
  svg_SVG.Gradient.extra.attrib = empty
  svg_SVG.Gradient.attrib =
    attribute stop-color { svg_SVGColor.datatype }?,
    attribute stop-opacity { svg_OpacityValue.datatype }?,
    svg_SVG.Gradient.extra.attrib
  svg_ClipPathValue.datatype = string
  svg_SVG.Clip.extra.attrib = empty
  svg_SVG.Clip.attrib =
    attribute clip-path { svg_ClipPathValue.datatype }?,
    attribute clip-rule { svg_ClipFillRule.datatype }?,
    svg_SVG.Clip.extra.attrib
  svg_MaskValue.datatype = string
  svg_SVG.Mask.extra.attrib = empty
  svg_SVG.Mask.attrib =
    attribute mask { svg_MaskValue.datatype }?,
    svg_SVG.Mask.extra.attrib
  svg_FilterValue.datatype = string
  svg_NumberOptionalNumber.datatype = string
  svg_SVG.Filter.extra.attrib = empty
  svg_SVG.Filter.attrib =
    attribute filter { svg_FilterValue.datatype }?,
    svg_SVG.Filter.extra.attrib
  svg_SVG.FilterColor.extra.attrib = empty
  svg_SVG.FilterColor.attrib =
    attribute color-interpolation-filters {
      "auto" | "sRGB" | "linearRGB" | "inherit"
    }?,
    svg_SVG.FilterColor.extra.attrib
  svg_CursorValue.datatype = string
  svg_SVG.Cursor.extra.attrib = empty
  svg_SVG.Cursor.attrib =
    attribute cursor { svg_CursorValue.datatype }?,
    svg_SVG.Cursor.extra.attrib
  svg_SVG.id.attrib = attribute id { xsd:ID }?
  svg_SVG.base.attrib = attribute xml:base { svg_URI.datatype }?
  svg_SVG.lang.attrib =
    attribute xml:lang { svg_LanguageCode.datatype }?
  svg_SVG.space.attrib = attribute xml:space { "default" | "preserve" }?
  svg_SVG.Core.extra.attrib = empty
  svg_SVG.Core.attrib =
    svg_SVG.id.attrib,
    svg_SVG.base.attrib,
    svg_SVG.lang.attrib,
    svg_SVG.space.attrib,
    svg_SVG.Core.extra.attrib
  svg_EnableBackgroundValue.datatype = string
  svg_SVG.enable-background.attrib =
    attribute enable-background { svg_EnableBackgroundValue.datatype }?
  svg_SVG.Container.extra.attrib = empty
  svg_SVG.Container.attrib =
    svg_SVG.enable-background.attrib, svg_SVG.Container.extra.attrib
  svg_ClipValue.datatype = string
  svg_SVG.clip.attrib = attribute clip { svg_ClipValue.datatype }?
  svg_SVG.overflow.attrib =
    attribute overflow {
      "visible" | "hidden" | "scroll" | "auto" | "inherit"
    }?
  svg_SVG.Viewport.extra.attrib = empty
  svg_SVG.Viewport.attrib =
    svg_SVG.clip.attrib,
    svg_SVG.overflow.attrib,
    svg_SVG.Viewport.extra.attrib
  svg_Paint.datatype = string
  svg_StrokeDashArrayValue.datatype = string
  svg_StrokeDashOffsetValue.datatype = string
  svg_StrokeMiterLimitValue.datatype = string
  svg_StrokeWidthValue.datatype = string
  svg_SVG.fill.attrib = attribute fill { svg_Paint.datatype }?
  svg_SVG.fill-rule.attrib =
    attribute fill-rule { svg_ClipFillRule.datatype }?
  svg_SVG.stroke.attrib = attribute stroke { svg_Paint.datatype }?
  svg_SVG.stroke-dasharray.attrib =
    attribute stroke-dasharray { svg_StrokeDashArrayValue.datatype }?
  svg_SVG.stroke-dashoffset.attrib =
    attribute stroke-dashoffset { svg_StrokeDashOffsetValue.datatype }?
  svg_SVG.stroke-linecap.attrib =
    attribute stroke-linecap {
      "butt" | "round" | "square" | "inherit"
    }?
  svg_SVG.stroke-linejoin.attrib =
    attribute stroke-linejoin {
      "miter" | "round" | "bevel" | "inherit"
    }?
  svg_SVG.stroke-miterlimit.attrib =
    attribute stroke-miterlimit { svg_StrokeMiterLimitValue.datatype }?
  svg_SVG.stroke-width.attrib =
    attribute stroke-width { svg_StrokeWidthValue.datatype }?
  svg_SVG.Paint.extra.attrib = empty
  svg_SVG.Paint.attrib =
    svg_SVG.fill.attrib,
    svg_SVG.fill-rule.attrib,
    svg_SVG.stroke.attrib,
    svg_SVG.stroke-dasharray.attrib,
    svg_SVG.stroke-dashoffset.attrib,
    svg_SVG.stroke-linecap.attrib,
    svg_SVG.stroke-linejoin.attrib,
    svg_SVG.stroke-miterlimit.attrib,
    svg_SVG.stroke-width.attrib,
    svg_SVG.Paint.extra.attrib
  svg_SVG.color.attrib = attribute color { svg_Color.datatype }?
  svg_SVG.color-interpolation.attrib =
    attribute color-interpolation {
      "auto" | "sRGB" | "linearRGB" | "inherit"
    }?
  svg_SVG.color-rendering.attrib =
    attribute color-rendering {
      "auto" | "optimizeSpeed" | "optimizeQuality" | "inherit"
    }?
  svg_SVG.Color.extra.attrib = empty
  svg_SVG.Color.attrib =
    svg_SVG.color.attrib,
    svg_SVG.color-interpolation.attrib,
    svg_SVG.color-rendering.attrib,
    svg_SVG.Color.extra.attrib
  svg_SVG.opacity.attrib =
    attribute opacity { svg_OpacityValue.datatype }?
  svg_SVG.fill-opacity.attrib =
    attribute fill-opacity { svg_OpacityValue.datatype }?
  svg_SVG.stroke-opacity.attrib =
    attribute stroke-opacity { svg_OpacityValue.datatype }?
  svg_SVG.Opacity.extra.attrib = empty
  svg_SVG.Opacity.attrib =
    svg_SVG.opacity.attrib,
    svg_SVG.fill-opacity.attrib,
    svg_SVG.stroke-opacity.attrib,
    svg_SVG.Opacity.extra.attrib
  svg_SVG.display.attrib =
    attribute display {
      "inline"
      | "block"
      | "list-item"
      | "run-in"
      | "compact"
      | "marker"
      | "table"
      | "inline-table"
      | "table-row-group"
      | "table-header-group"
      | "table-footer-group"
      | "table-row"
      | "table-column-group"
      | "table-column"
      | "table-cell"
      | "table-caption"
      | "none"
      | "inherit"
    }?
  svg_SVG.image-rendering.attrib =
    attribute image-rendering {
      "auto" | "optimizeSpeed" | "optimizeQuality" | "inherit"
    }?
  svg_SVG.pointer-events.attrib =
    attribute pointer-events {
      "visiblePainted"
      | "visibleFill"
      | "visibleStroke"
      | "visible"
      | "painted"
      | "fill"
      | "stroke"
      | "all"
      | "none"
      | "inherit"
    }?
  svg_SVG.shape-rendering.attrib =
    attribute shape-rendering {
      "auto"
      | "optimizeSpeed"
      | "crispEdges"
      | "geometricPrecision"
      | "inherit"
    }?
  svg_SVG.text-rendering.attrib =
    attribute text-rendering {
      "auto"
      | "optimizeSpeed"
      | "optimizeLegibility"
      | "geometricPrecision"
      | "inherit"
    }?
  svg_SVG.visibility.attrib =
    attribute visibility { "visible" | "hidden" | "inherit" }?
  svg_SVG.Graphics.extra.attrib = empty
  svg_SVG.Graphics.attrib =
    svg_SVG.display.attrib,
    svg_SVG.image-rendering.attrib,
    svg_SVG.pointer-events.attrib,
    svg_SVG.shape-rendering.attrib,
    svg_SVG.text-rendering.attrib,
    svg_SVG.visibility.attrib,
    svg_SVG.Graphics.extra.attrib
  svg_SVG.onunload.attrib = attribute onunload { svg_Script.datatype }?
  svg_SVG.onabort.attrib = attribute onabort { svg_Script.datatype }?
  svg_SVG.onerror.attrib = attribute onerror { svg_Script.datatype }?
  svg_SVG.onresize.attrib = attribute onresize { svg_Script.datatype }?
  svg_SVG.onscroll.attrib = attribute onscroll { svg_Script.datatype }?
  svg_SVG.onzoom.attrib = attribute onzoom { svg_Script.datatype }?
  svg_SVG.DocumentEvents.extra.attrib = empty
  svg_SVG.DocumentEvents.attrib =
    svg_SVG.onunload.attrib,
    svg_SVG.onabort.attrib,
    svg_SVG.onerror.attrib,
    svg_SVG.onresize.attrib,
    svg_SVG.onscroll.attrib,
    svg_SVG.onzoom.attrib,
    svg_SVG.DocumentEvents.extra.attrib
  svg_SVG.onfocusin.attrib =
    attribute onfocusin { svg_Script.datatype }?
  svg_SVG.onfocusout.attrib =
    attribute onfocusout { svg_Script.datatype }?
  svg_SVG.onactivate.attrib =
    attribute onactivate { svg_Script.datatype }?
  svg_SVG.onclick.attrib = attribute onclick { svg_Script.datatype }?
  svg_SVG.onmousedown.attrib =
    attribute onmousedown { svg_Script.datatype }?
  svg_SVG.onmouseup.attrib =
    attribute onmouseup { svg_Script.datatype }?
  svg_SVG.onmouseover.attrib =
    attribute onmouseover { svg_Script.datatype }?
  svg_SVG.onmousemove.attrib =
    attribute onmousemove { svg_Script.datatype }?
  svg_SVG.onmouseout.attrib =
    attribute onmouseout { svg_Script.datatype }?
  svg_SVG.onload.attrib = attribute onload { svg_Script.datatype }?
  svg_SVG.GraphicalEvents.extra.attrib = empty
  svg_SVG.GraphicalEvents.attrib =
    svg_SVG.onfocusin.attrib,
    svg_SVG.onfocusout.attrib,
    svg_SVG.onactivate.attrib,
    svg_SVG.onclick.attrib,
    svg_SVG.onmousedown.attrib,
    svg_SVG.onmouseup.attrib,
    svg_SVG.onmouseover.attrib,
    svg_SVG.onmousemove.attrib,
    svg_SVG.onmouseout.attrib,
    svg_SVG.onload.attrib,
    svg_SVG.GraphicalEvents.extra.attrib
  svg_SVG.onbegin.attrib = attribute onbegin { svg_Script.datatype }?
  svg_SVG.onend.attrib = attribute onend { svg_Script.datatype }?
  svg_SVG.onrepeat.attrib = attribute onrepeat { svg_Script.datatype }?
  svg_SVG.AnimationEvents.extra.attrib = empty
  svg_SVG.AnimationEvents.attrib =
    svg_SVG.onbegin.attrib,
    svg_SVG.onend.attrib,
    svg_SVG.onrepeat.attrib,
    svg_SVG.onload.attrib,
    svg_SVG.AnimationEvents.extra.attrib
  svg_SVG.XLink.extra.attrib = empty
  svg_SVG.XLink.attrib =
    svg_XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { svg_URI.datatype }?,
    attribute xlink:role { svg_URI.datatype }?,
    attribute xlink:arcrole { svg_URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "other" ] attribute xlink:show { "other" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    svg_SVG.XLink.extra.attrib
  svg_SVG.XLinkRequired.extra.attrib = empty
  svg_SVG.XLinkRequired.attrib =
    svg_XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { svg_URI.datatype },
    attribute xlink:role { svg_URI.datatype }?,
    attribute xlink:arcrole { svg_URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "other" ] attribute xlink:show { "other" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    svg_SVG.XLinkRequired.extra.attrib
  svg_SVG.XLinkEmbed.extra.attrib = empty
  svg_SVG.XLinkEmbed.attrib =
    svg_XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { svg_URI.datatype },
    attribute xlink:role { svg_URI.datatype }?,
    attribute xlink:arcrole { svg_URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "embed" ] attribute xlink:show { "embed" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    svg_SVG.XLinkEmbed.extra.attrib
  svg_SVG.XLinkReplace.extra.attrib = empty
  svg_SVG.XLinkReplace.attrib =
    svg_XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { svg_URI.datatype },
    attribute xlink:role { svg_URI.datatype }?,
    attribute xlink:arcrole { svg_URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "replace" ]
    attribute xlink:show { "new" | "replace" }?,
    [ a:defaultValue = "onRequest" ]
    attribute xlink:actuate { "onRequest" }?,
    svg_SVG.XLinkReplace.extra.attrib
  svg_SVG.externalResourcesRequired.attrib =
    attribute externalResourcesRequired { svg_Boolean.datatype }?
  svg_SVG.External.extra.attrib = empty
  svg_SVG.External.attrib =
    svg_SVG.externalResourcesRequired.attrib,
    svg_SVG.External.extra.attrib
  svg_SVG.Presentation.extra.attrib = empty
  svg_SVG.Presentation.attrib =
    svg_SVG.Container.attrib,
    svg_SVG.Viewport.attrib,
    svg_SVG.Text.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Marker.attrib,
    svg_SVG.ColorProfile.attrib,
    svg_SVG.Gradient.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.Cursor.attrib,
    attribute flood-color { svg_SVGColor.datatype }?,
    attribute flood-opacity { svg_OpacityValue.datatype }?,
    attribute lighting-color { svg_SVGColor.datatype }?,
    svg_SVG.Presentation.extra.attrib
  svg_SVG.svg.extra.content = notAllowed
  svg_SVG.svg.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.svg.extra.content)*
  svg_svg = element ns2:svg { svg_attlist.svg, svg_SVG.svg.content }
  svg_attlist.svg &=
    svg_SVG.xmlns.attrib,
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.DocumentEvents.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype }?,
    attribute height { svg_Length.datatype }?,
    attribute viewBox { svg_ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?,
    [ a:defaultValue = "magnify" ]
    attribute zoomAndPan { "disable" | "magnify" }?,
    [ a:defaultValue = "1.1" ] attribute version { string "1.1" }?,
    attribute baseProfile { svg_Text.datatype }?,
    [ a:defaultValue = "text/ecmascript" ]
    attribute contentScriptType { svg_ContentType.datatype }?,
    [ a:defaultValue = "text/css" ]
    attribute contentStyleType { svg_ContentType.datatype }?
  svg_SVG.g.extra.content = notAllowed
  svg_SVG.g.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.g.extra.content)*
  svg_g = element ns2:g { svg_attlist.g, svg_SVG.g.content }
  svg_attlist.g &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.External.attrib,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.defs.extra.content = notAllowed
  svg_SVG.defs.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.defs.extra.content)*
  svg_defs = element ns2:defs { svg_attlist.defs, svg_SVG.defs.content }
  svg_attlist.defs &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.External.attrib,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.desc.extra.content = notAllowed
  svg_SVG.desc.content = (text | svg_SVG.desc.extra.content)*
  svg_desc = element ns2:desc { svg_attlist.desc, svg_SVG.desc.content }
  svg_attlist.desc &= svg_SVG.Core.attrib, svg_SVG.Style.attrib
  svg_SVG.title.extra.content = notAllowed
  svg_SVG.title.content = (text | svg_SVG.title.extra.content)*
  svg_title =
    element ns2:title { svg_attlist.title, svg_SVG.title.content }
  svg_attlist.title &= svg_SVG.Core.attrib, svg_SVG.Style.attrib
  svg_SVG.metadata.extra.content = notAllowed
  svg_SVG.metadata.content = (text | svg_SVG.metadata.extra.content)*
  svg_metadata =
    element ns2:metadata {
      svg_attlist.metadata, svg_SVG.metadata.content
    }
  svg_attlist.metadata &= svg_SVG.Core.attrib
  svg_SVG.symbol.extra.content = notAllowed
  svg_SVG.symbol.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.symbol.extra.content)*
  svg_symbol =
    element ns2:symbol { svg_attlist.symbol, svg_SVG.symbol.content }
  svg_attlist.symbol &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.External.attrib,
    attribute viewBox { svg_ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?
  svg_SVG.use.extra.content = notAllowed
  svg_SVG.use.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.use.extra.content)*
  svg_use = element ns2:use { svg_attlist.use, svg_SVG.use.content }
  svg_attlist.use &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.XLinkEmbed.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype }?,
    attribute height { svg_Length.datatype }?,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.switch.extra.content = notAllowed
  svg_SVG.switch.content =
    svg_SVG.Description.class*,
    (svg_svg
     | svg_g
     | svg_use
     | svg_text
     | svg_SVG.Animation.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Shape.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.Extensibility.class
     | svg_SVG.switch.extra.content)*
  svg_switch =
    element ns2:switch { svg_attlist.switch, svg_SVG.switch.content }
  svg_attlist.switch &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.External.attrib,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.image.extra.content = notAllowed
  svg_SVG.image.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.image.extra.content)*
  svg_image =
    element ns2:image { svg_attlist.image, svg_SVG.image.content }
  svg_attlist.image &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Viewport.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.ColorProfile.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.XLinkEmbed.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype },
    attribute height { svg_Length.datatype },
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?,
    attribute transform { svg_TransformList.datatype }?
  svg_MediaDesc.datatype = string
  svg_SVG.style.extra.content = notAllowed
  svg_SVG.style.content = (text | svg_SVG.style.extra.content)*
  svg_style =
    element ns2:style { svg_attlist.style, svg_SVG.style.content }
  svg_attlist.style &=
    [ a:defaultValue = "preserve" ] attribute xml:space { "preserve" }?,
    svg_SVG.id.attrib,
    svg_SVG.base.attrib,
    svg_SVG.lang.attrib,
    svg_SVG.Core.extra.attrib,
    attribute type { svg_ContentType.datatype },
    attribute media { svg_MediaDesc.datatype }?,
    attribute title { svg_Text.datatype }?
  svg_Points.datatype = string
  svg_SVG.path.extra.content = notAllowed
  svg_SVG.path.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.path.extra.content)*
  svg_path = element ns2:path { svg_attlist.path, svg_SVG.path.content }
  svg_attlist.path &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Marker.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute d { svg_PathData.datatype },
    attribute pathLength { svg_Number.datatype }?,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.rect.extra.content = notAllowed
  svg_SVG.rect.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.rect.extra.content)*
  svg_rect = element ns2:rect { svg_attlist.rect, svg_SVG.rect.content }
  svg_attlist.rect &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype },
    attribute height { svg_Length.datatype },
    attribute rx { svg_Length.datatype }?,
    attribute ry { svg_Length.datatype }?,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.circle.extra.content = notAllowed
  svg_SVG.circle.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.circle.extra.content)*
  svg_circle =
    element ns2:circle { svg_attlist.circle, svg_SVG.circle.content }
  svg_attlist.circle &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute cx { svg_Coordinate.datatype }?,
    attribute cy { svg_Coordinate.datatype }?,
    attribute r { svg_Length.datatype },
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.line.extra.content = notAllowed
  svg_SVG.line.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.line.extra.content)*
  svg_line = element ns2:line { svg_attlist.line, svg_SVG.line.content }
  svg_attlist.line &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Marker.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute x1 { svg_Coordinate.datatype }?,
    attribute y1 { svg_Coordinate.datatype }?,
    attribute x2 { svg_Coordinate.datatype }?,
    attribute y2 { svg_Coordinate.datatype }?,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.ellipse.extra.content = notAllowed
  svg_SVG.ellipse.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.ellipse.extra.content)*
  svg_ellipse =
    element ns2:ellipse { svg_attlist.ellipse, svg_SVG.ellipse.content }
  svg_attlist.ellipse &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute cx { svg_Coordinate.datatype }?,
    attribute cy { svg_Coordinate.datatype }?,
    attribute rx { svg_Length.datatype },
    attribute ry { svg_Length.datatype },
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.polyline.extra.content = notAllowed
  svg_SVG.polyline.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.polyline.extra.content)*
  svg_polyline =
    element ns2:polyline {
      svg_attlist.polyline, svg_SVG.polyline.content
    }
  svg_attlist.polyline &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Marker.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute points { svg_Points.datatype },
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.polygon.extra.content = notAllowed
  svg_SVG.polygon.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class | svg_SVG.polygon.extra.content)*
  svg_polygon =
    element ns2:polygon { svg_attlist.polygon, svg_SVG.polygon.content }
  svg_attlist.polygon &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Marker.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute points { svg_Points.datatype },
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.text.extra.content = notAllowed
  svg_SVG.text.content =
    (text
     | svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.TextContent.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.text.extra.content)*
  svg_text = element ns2:text { svg_attlist.text, svg_SVG.text.content }
  svg_attlist.text &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Text.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinates.datatype }?,
    attribute y { svg_Coordinates.datatype }?,
    attribute dx { svg_Lengths.datatype }?,
    attribute dy { svg_Lengths.datatype }?,
    attribute rotate { svg_Numbers.datatype }?,
    attribute textLength { svg_Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?,
    attribute transform { svg_TransformList.datatype }?
  svg_SVG.tspan.extra.content = notAllowed
  svg_SVG.tspan.content =
    (text
     | svg_tspan
     | svg_tref
     | svg_altGlyph
     | svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.Description.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.tspan.extra.content)*
  svg_tspan =
    element ns2:tspan { svg_attlist.tspan, svg_SVG.tspan.content }
  svg_attlist.tspan &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinates.datatype }?,
    attribute y { svg_Coordinates.datatype }?,
    attribute dx { svg_Lengths.datatype }?,
    attribute dy { svg_Lengths.datatype }?,
    attribute rotate { svg_Numbers.datatype }?,
    attribute textLength { svg_Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?
  svg_SVG.tref.extra.content = notAllowed
  svg_SVG.tref.content =
    (svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.Description.class
     | svg_SVG.tref.extra.content)*
  svg_tref = element ns2:tref { svg_attlist.tref, svg_SVG.tref.content }
  svg_attlist.tref &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.XLinkRequired.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinates.datatype }?,
    attribute y { svg_Coordinates.datatype }?,
    attribute dx { svg_Lengths.datatype }?,
    attribute dy { svg_Lengths.datatype }?,
    attribute rotate { svg_Numbers.datatype }?,
    attribute textLength { svg_Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?
  svg_SVG.textPath.extra.content = notAllowed
  svg_SVG.textPath.content =
    (text
     | svg_tspan
     | svg_tref
     | svg_altGlyph
     | svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.Description.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.textPath.extra.content)*
  svg_textPath =
    element ns2:textPath {
      svg_attlist.textPath, svg_SVG.textPath.content
    }
  svg_attlist.textPath &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.XLinkRequired.attrib,
    svg_SVG.External.attrib,
    attribute startOffset { svg_Length.datatype }?,
    attribute textLength { svg_Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?,
    attribute method { "align" | "stretch" }?,
    attribute spacing { "auto" | "exact" }?
  svg_SVG.altGlyph.extra.content = notAllowed
  svg_SVG.altGlyph.content = (text | svg_SVG.altGlyph.extra.content)*
  svg_altGlyph =
    element ns2:altGlyph {
      svg_attlist.altGlyph, svg_SVG.altGlyph.content
    }
  svg_attlist.altGlyph &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.XLink.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinates.datatype }?,
    attribute y { svg_Coordinates.datatype }?,
    attribute dx { svg_Lengths.datatype }?,
    attribute dy { svg_Lengths.datatype }?,
    attribute glyphRef { text }?,
    attribute format { text }?,
    attribute rotate { svg_Numbers.datatype }?
  svg_SVG.altGlyphDef.extra.content = notAllowed
  svg_SVG.altGlyphDef.content =
    (svg_glyphRef+ | svg_altGlyphItem+)
    | svg_SVG.altGlyphDef.extra.content
  svg_altGlyphDef =
    element ns2:altGlyphDef {
      svg_attlist.altGlyphDef, svg_SVG.altGlyphDef.content
    }
  svg_attlist.altGlyphDef &= svg_SVG.Core.attrib
  svg_SVG.altGlyphItem.extra.content = notAllowed
  svg_SVG.altGlyphItem.content =
    svg_glyphRef+ | svg_SVG.altGlyphItem.extra.content
  svg_altGlyphItem =
    element ns2:altGlyphItem {
      svg_attlist.altGlyphItem, svg_SVG.altGlyphItem.content
    }
  svg_attlist.altGlyphItem &= svg_SVG.Core.attrib
  svg_SVG.glyphRef.content = empty
  svg_glyphRef =
    element ns2:glyphRef {
      svg_attlist.glyphRef, svg_SVG.glyphRef.content
    }
  svg_attlist.glyphRef &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.XLink.attrib,
    attribute x { svg_Number.datatype }?,
    attribute y { svg_Number.datatype }?,
    attribute dx { svg_Number.datatype }?,
    attribute dy { svg_Number.datatype }?,
    attribute glyphRef { text }?,
    attribute format { text }?
  svg_SVG.marker.extra.content = notAllowed
  svg_SVG.marker.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.marker.extra.content)*
  svg_marker =
    element ns2:marker { svg_attlist.marker, svg_SVG.marker.content }
  svg_attlist.marker &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.External.attrib,
    attribute refX { svg_Coordinate.datatype }?,
    attribute refY { svg_Coordinate.datatype }?,
    attribute markerUnits { "strokeWidth" | "userSpaceOnUse" }?,
    attribute markerWidth { svg_Length.datatype }?,
    attribute markerHeight { svg_Length.datatype }?,
    attribute orient { text }?,
    attribute viewBox { svg_ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?
  svg_SVG.color-profile.extra.content = notAllowed
  svg_SVG.color-profile.content =
    (svg_SVG.Description.class | svg_SVG.color-profile.extra.content)*
  svg_color-profile =
    element ns2:color-profile {
      svg_attlist.color-profile, svg_SVG.color-profile.content
    }
  svg_attlist.color-profile &=
    svg_SVG.Core.attrib,
    svg_SVG.XLink.attrib,
    attribute local { text }?,
    attribute name { text },
    [ a:defaultValue = "auto" ]
    attribute rendering-intent {
      "auto"
      | "perceptual"
      | "relative-colorimetric"
      | "saturation"
      | "absolute-colorimetric"
    }?
  svg_SVG.linearGradient.extra.content = notAllowed
  svg_SVG.linearGradient.content =
    svg_SVG.Description.class*,
    (svg_stop
     | svg_animate
     | svg_set
     | svg_animateTransform
     | svg_SVG.linearGradient.extra.content)*
  svg_linearGradient =
    element ns2:linearGradient {
      svg_attlist.linearGradient, svg_SVG.linearGradient.content
    }
  svg_attlist.linearGradient &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Gradient.attrib,
    svg_SVG.XLink.attrib,
    svg_SVG.External.attrib,
    attribute x1 { svg_Coordinate.datatype }?,
    attribute y1 { svg_Coordinate.datatype }?,
    attribute x2 { svg_Coordinate.datatype }?,
    attribute y2 { svg_Coordinate.datatype }?,
    attribute gradientUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute gradientTransform { svg_TransformList.datatype }?,
    attribute spreadMethod { "pad" | "reflect" | "repeat" }?
  svg_SVG.radialGradient.extra.content = notAllowed
  svg_SVG.radialGradient.content =
    svg_SVG.Description.class*,
    (svg_stop
     | svg_animate
     | svg_set
     | svg_animateTransform
     | svg_SVG.radialGradient.extra.content)*
  svg_radialGradient =
    element ns2:radialGradient {
      svg_attlist.radialGradient, svg_SVG.radialGradient.content
    }
  svg_attlist.radialGradient &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Gradient.attrib,
    svg_SVG.XLink.attrib,
    svg_SVG.External.attrib,
    attribute cx { svg_Coordinate.datatype }?,
    attribute cy { svg_Coordinate.datatype }?,
    attribute r { svg_Length.datatype }?,
    attribute fx { svg_Coordinate.datatype }?,
    attribute fy { svg_Coordinate.datatype }?,
    attribute gradientUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute gradientTransform { svg_TransformList.datatype }?,
    attribute spreadMethod { "pad" | "reflect" | "repeat" }?
  svg_SVG.stop.extra.content = notAllowed
  svg_SVG.stop.content =
    (svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.stop.extra.content)*
  svg_stop = element ns2:stop { svg_attlist.stop, svg_SVG.stop.content }
  svg_attlist.stop &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Gradient.attrib,
    attribute offset { svg_NumberOrPercentage.datatype }
  svg_SVG.pattern.extra.content = notAllowed
  svg_SVG.pattern.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.pattern.extra.content)*
  svg_svgpattern =
    element ns2:pattern { svg_attlist.pattern, svg_SVG.pattern.content }
  svg_attlist.pattern &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.XLink.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype }?,
    attribute height { svg_Length.datatype }?,
    attribute patternUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute patternContentUnits {
      "userSpaceOnUse" | "objectBoundingBox"
    }?,
    attribute patternTransform { svg_TransformList.datatype }?,
    attribute viewBox { svg_ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?
  svg_SVG.clipPath.extra.content = notAllowed
  svg_SVG.clipPath.content =
    svg_SVG.Description.class*,
    (svg_SVG.Animation.class
     | svg_SVG.Use.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.clipPath.extra.content)*
  svg_clipPath =
    element ns2:clipPath {
      svg_attlist.clipPath, svg_SVG.clipPath.content
    }
  svg_attlist.clipPath &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Text.attrib,
    svg_SVG.TextContent.attrib,
    svg_SVG.Font.attrib,
    svg_SVG.Paint.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.Opacity.attrib,
    svg_SVG.Graphics.attrib,
    svg_SVG.Clip.attrib,
    svg_SVG.Mask.attrib,
    svg_SVG.Filter.attrib,
    svg_SVG.Cursor.attrib,
    svg_SVG.External.attrib,
    attribute transform { svg_TransformList.datatype }?,
    attribute clipPathUnits { "userSpaceOnUse" | "objectBoundingBox" }?
  svg_SVG.mask.extra.content = notAllowed
  svg_SVG.mask.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.mask.extra.content)*
  svg_mask = element ns2:mask { svg_attlist.mask, svg_SVG.mask.content }
  svg_attlist.mask &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype }?,
    attribute height { svg_Length.datatype }?,
    attribute maskUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute maskContentUnits {
      "userSpaceOnUse" | "objectBoundingBox"
    }?
  svg_SVG.FilterPrimitive.extra.attrib = empty
  svg_SVG.FilterPrimitive.attrib =
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype }?,
    attribute height { svg_Length.datatype }?,
    attribute result { text }?,
    svg_SVG.FilterPrimitive.extra.attrib
  svg_SVG.FilterPrimitiveWithIn.extra.attrib = empty
  svg_SVG.FilterPrimitiveWithIn.attrib =
    svg_SVG.FilterPrimitive.attrib,
    attribute in { text }?,
    svg_SVG.FilterPrimitiveWithIn.extra.attrib
  svg_SVG.filter.extra.content = notAllowed
  svg_SVG.filter.content =
    svg_SVG.Description.class*,
    (svg_animate
     | svg_set
     | svg_SVG.FilterPrimitive.class
     | svg_SVG.filter.extra.content)*
  svg_filter =
    element ns2:filter { svg_attlist.filter, svg_SVG.filter.content }
  svg_attlist.filter &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.XLink.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype }?,
    attribute height { svg_Length.datatype }?,
    attribute filterRes { svg_NumberOptionalNumber.datatype }?,
    attribute filterUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute primitiveUnits { "userSpaceOnUse" | "objectBoundingBox" }?
  svg_SVG.feBlend.extra.content = notAllowed
  svg_SVG.feBlend.content =
    (svg_animate | svg_set | svg_SVG.feBlend.extra.content)*
  svg_feBlend =
    element ns2:feBlend { svg_attlist.feBlend, svg_SVG.feBlend.content }
  svg_attlist.feBlend &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    [ a:defaultValue = "normal" ]
    attribute mode {
      "normal" | "multiply" | "screen" | "darken" | "lighten"
    }?
  svg_SVG.feColorMatrix.extra.content = notAllowed
  svg_SVG.feColorMatrix.content =
    (svg_animate | svg_set | svg_SVG.feColorMatrix.extra.content)*
  svg_feColorMatrix =
    element ns2:feColorMatrix {
      svg_attlist.feColorMatrix, svg_SVG.feColorMatrix.content
    }
  svg_attlist.feColorMatrix &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    [ a:defaultValue = "matrix" ]
    attribute type {
      "matrix" | "saturate" | "hueRotate" | "luminanceToAlpha"
    }?,
    attribute values { text }?
  svg_SVG.feComponentTransfer.extra.content = empty
  svg_SVG.feComponentTransfer.content =
    svg_feFuncR?,
    svg_feFuncG?,
    svg_feFuncB?,
    svg_feFuncA?,
    svg_SVG.feComponentTransfer.extra.content
  svg_feComponentTransfer =
    element ns2:feComponentTransfer {
      svg_attlist.feComponentTransfer,
      svg_SVG.feComponentTransfer.content
    }
  svg_attlist.feComponentTransfer &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib
  svg_SVG.feComposite.extra.content = notAllowed
  svg_SVG.feComposite.content =
    (svg_animate | svg_set | svg_SVG.feComposite.extra.content)*
  svg_feComposite =
    element ns2:feComposite {
      svg_attlist.feComposite, svg_SVG.feComposite.content
    }
  svg_attlist.feComposite &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    [ a:defaultValue = "over" ]
    attribute operator {
      "over" | "in" | "out" | "atop" | "xor" | "arithmetic"
    }?,
    attribute k1 { svg_Number.datatype }?,
    attribute k2 { svg_Number.datatype }?,
    attribute k3 { svg_Number.datatype }?,
    attribute k4 { svg_Number.datatype }?
  svg_SVG.feConvolveMatrix.extra.content = notAllowed
  svg_SVG.feConvolveMatrix.content =
    (svg_animate | svg_set | svg_SVG.feConvolveMatrix.extra.content)*
  svg_feConvolveMatrix =
    element ns2:feConvolveMatrix {
      svg_attlist.feConvolveMatrix, svg_SVG.feConvolveMatrix.content
    }
  svg_attlist.feConvolveMatrix &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute order { svg_NumberOptionalNumber.datatype },
    attribute kernelMatrix { text },
    attribute divisor { svg_Number.datatype }?,
    attribute bias { svg_Number.datatype }?,
    attribute targetX { svg_Integer.datatype }?,
    attribute targetY { svg_Integer.datatype }?,
    [ a:defaultValue = "duplicate" ]
    attribute edgeMode { "duplicate" | "wrap" | "none" }?,
    attribute kernelUnitLength { svg_NumberOptionalNumber.datatype }?,
    attribute preserveAlpha { svg_Boolean.datatype }?
  svg_SVG.feDiffuseLighting.extra.content = notAllowed
  svg_SVG.feDiffuseLighting.content =
    (svg_feDistantLight | svg_fePointLight | svg_feSpotLight),
    (svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.feDiffuseLighting.extra.content)*
  svg_feDiffuseLighting =
    element ns2:feDiffuseLighting {
      svg_attlist.feDiffuseLighting, svg_SVG.feDiffuseLighting.content
    }
  svg_attlist.feDiffuseLighting &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute lighting-color { svg_SVGColor.datatype }?,
    attribute surfaceScale { svg_Number.datatype }?,
    attribute diffuseConstant { svg_Number.datatype }?,
    attribute kernelUnitLength { svg_NumberOptionalNumber.datatype }?
  svg_SVG.feDisplacementMap.extra.content = notAllowed
  svg_SVG.feDisplacementMap.content =
    (svg_animate | svg_set | svg_SVG.feDisplacementMap.extra.content)*
  svg_feDisplacementMap =
    element ns2:feDisplacementMap {
      svg_attlist.feDisplacementMap, svg_SVG.feDisplacementMap.content
    }
  svg_attlist.feDisplacementMap &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    attribute scale { svg_Number.datatype }?,
    [ a:defaultValue = "A" ]
    attribute xChannelSelector { "R" | "G" | "B" | "A" }?,
    [ a:defaultValue = "A" ]
    attribute yChannelSelector { "R" | "G" | "B" | "A" }?
  svg_SVG.feFlood.extra.content = notAllowed
  svg_SVG.feFlood.content =
    (svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.feFlood.extra.content)*
  svg_feFlood =
    element ns2:feFlood { svg_attlist.feFlood, svg_SVG.feFlood.content }
  svg_attlist.feFlood &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute flood-color { svg_SVGColor.datatype }?,
    attribute flood-opacity { svg_OpacityValue.datatype }?
  svg_SVG.feGaussianBlur.extra.content = notAllowed
  svg_SVG.feGaussianBlur.content =
    (svg_animate | svg_set | svg_SVG.feGaussianBlur.extra.content)*
  svg_feGaussianBlur =
    element ns2:feGaussianBlur {
      svg_attlist.feGaussianBlur, svg_SVG.feGaussianBlur.content
    }
  svg_attlist.feGaussianBlur &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute stdDeviation { svg_NumberOptionalNumber.datatype }?
  svg_SVG.feImage.extra.content = notAllowed
  svg_SVG.feImage.content =
    (svg_animate
     | svg_set
     | svg_animateTransform
     | svg_SVG.feImage.extra.content)*
  svg_feImage =
    element ns2:feImage { svg_attlist.feImage, svg_SVG.feImage.content }
  svg_attlist.feImage &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.FilterPrimitive.attrib,
    svg_SVG.XLinkEmbed.attrib,
    svg_SVG.External.attrib,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?
  svg_SVG.feMerge.extra.content = notAllowed
  svg_SVG.feMerge.content =
    (svg_feMergeNode | svg_SVG.feMerge.extra.content)*
  svg_feMerge =
    element ns2:feMerge { svg_attlist.feMerge, svg_SVG.feMerge.content }
  svg_attlist.feMerge &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitive.attrib
  svg_SVG.feMergeNode.extra.content = notAllowed
  svg_SVG.feMergeNode.content =
    (svg_animate | svg_set | svg_SVG.feMergeNode.extra.content)*
  svg_feMergeNode =
    element ns2:feMergeNode {
      svg_attlist.feMergeNode, svg_SVG.feMergeNode.content
    }
  svg_attlist.feMergeNode &=
    svg_SVG.Core.attrib,
    attribute in { text }?
  svg_SVG.feMorphology.extra.content = notAllowed
  svg_SVG.feMorphology.content =
    (svg_animate | svg_set | svg_SVG.feMorphology.extra.content)*
  svg_feMorphology =
    element ns2:feMorphology {
      svg_attlist.feMorphology, svg_SVG.feMorphology.content
    }
  svg_attlist.feMorphology &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    [ a:defaultValue = "erode" ]
    attribute operator { "erode" | "dilate" }?,
    attribute radius { svg_NumberOptionalNumber.datatype }?
  svg_SVG.feOffset.extra.content = notAllowed
  svg_SVG.feOffset.content =
    (svg_animate | svg_set | svg_SVG.feOffset.extra.content)*
  svg_feOffset =
    element ns2:feOffset {
      svg_attlist.feOffset, svg_SVG.feOffset.content
    }
  svg_attlist.feOffset &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute dx { svg_Number.datatype }?,
    attribute dy { svg_Number.datatype }?
  svg_SVG.feSpecularLighting.extra.content = notAllowed
  svg_SVG.feSpecularLighting.content =
    (svg_feDistantLight | svg_fePointLight | svg_feSpotLight),
    (svg_animate
     | svg_set
     | svg_animateColor
     | svg_SVG.feSpecularLighting.extra.content)*
  svg_feSpecularLighting =
    element ns2:feSpecularLighting {
      svg_attlist.feSpecularLighting, svg_SVG.feSpecularLighting.content
    }
  svg_attlist.feSpecularLighting &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Color.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib,
    attribute lighting-color { svg_SVGColor.datatype }?,
    attribute surfaceScale { svg_Number.datatype }?,
    attribute specularConstant { svg_Number.datatype }?,
    attribute specularExponent { svg_Number.datatype }?,
    attribute kernelUnitLength { svg_NumberOptionalNumber.datatype }?
  svg_SVG.feTile.extra.content = notAllowed
  svg_SVG.feTile.content =
    (svg_animate | svg_set | svg_SVG.feTile.extra.content)*
  svg_feTile =
    element ns2:feTile { svg_attlist.feTile, svg_SVG.feTile.content }
  svg_attlist.feTile &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitiveWithIn.attrib
  svg_SVG.feTurbulence.extra.content = notAllowed
  svg_SVG.feTurbulence.content =
    (svg_animate | svg_set | svg_SVG.feTurbulence.extra.content)*
  svg_feTurbulence =
    element ns2:feTurbulence {
      svg_attlist.feTurbulence, svg_SVG.feTurbulence.content
    }
  svg_attlist.feTurbulence &=
    svg_SVG.Core.attrib,
    svg_SVG.FilterColor.attrib,
    svg_SVG.FilterPrimitive.attrib,
    attribute baseFrequency { svg_NumberOptionalNumber.datatype }?,
    attribute numOctaves { svg_Integer.datatype }?,
    attribute seed { svg_Number.datatype }?,
    [ a:defaultValue = "noStitch" ]
    attribute stitchTiles { "stitch" | "noStitch" }?,
    [ a:defaultValue = "turbulence" ]
    attribute type { "fractalNoise" | "turbulence" }?
  svg_SVG.feDistantLight.extra.content = notAllowed
  svg_SVG.feDistantLight.content =
    (svg_animate | svg_set | svg_SVG.feDistantLight.extra.content)*
  svg_feDistantLight =
    element ns2:feDistantLight {
      svg_attlist.feDistantLight, svg_SVG.feDistantLight.content
    }
  svg_attlist.feDistantLight &=
    svg_SVG.Core.attrib,
    attribute azimuth { svg_Number.datatype }?,
    attribute elevation { svg_Number.datatype }?
  svg_SVG.fePointLight.extra.content = notAllowed
  svg_SVG.fePointLight.content =
    (svg_animate | svg_set | svg_SVG.fePointLight.extra.content)*
  svg_fePointLight =
    element ns2:fePointLight {
      svg_attlist.fePointLight, svg_SVG.fePointLight.content
    }
  svg_attlist.fePointLight &=
    svg_SVG.Core.attrib,
    attribute x { svg_Number.datatype }?,
    attribute y { svg_Number.datatype }?,
    attribute z { svg_Number.datatype }?
  svg_SVG.feSpotLight.extra.content = notAllowed
  svg_SVG.feSpotLight.content =
    (svg_animate | svg_set | svg_SVG.feSpotLight.extra.content)*
  svg_feSpotLight =
    element ns2:feSpotLight {
      svg_attlist.feSpotLight, svg_SVG.feSpotLight.content
    }
  svg_attlist.feSpotLight &=
    svg_SVG.Core.attrib,
    attribute x { svg_Number.datatype }?,
    attribute y { svg_Number.datatype }?,
    attribute z { svg_Number.datatype }?,
    attribute pointsAtX { svg_Number.datatype }?,
    attribute pointsAtY { svg_Number.datatype }?,
    attribute pointsAtZ { svg_Number.datatype }?,
    attribute specularExponent { svg_Number.datatype }?,
    attribute limitingConeAngle { svg_Number.datatype }?
  svg_SVG.feFuncR.extra.content = notAllowed
  svg_SVG.feFuncR.content =
    (svg_animate | svg_set | svg_SVG.feFuncR.extra.content)*
  svg_feFuncR =
    element ns2:feFuncR { svg_attlist.feFuncR, svg_SVG.feFuncR.content }
  svg_attlist.feFuncR &=
    svg_SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { svg_Number.datatype }?,
    attribute intercept { svg_Number.datatype }?,
    attribute amplitude { svg_Number.datatype }?,
    attribute exponent { svg_Number.datatype }?,
    attribute offset { svg_Number.datatype }?
  svg_SVG.feFuncG.extra.content = notAllowed
  svg_SVG.feFuncG.content =
    (svg_animate | svg_set | svg_SVG.feFuncG.extra.content)*
  svg_feFuncG =
    element ns2:feFuncG { svg_attlist.feFuncG, svg_SVG.feFuncG.content }
  svg_attlist.feFuncG &=
    svg_SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { svg_Number.datatype }?,
    attribute intercept { svg_Number.datatype }?,
    attribute amplitude { svg_Number.datatype }?,
    attribute exponent { svg_Number.datatype }?,
    attribute offset { svg_Number.datatype }?
  svg_SVG.feFuncB.extra.content = notAllowed
  svg_SVG.feFuncB.content =
    (svg_animate | svg_set | svg_SVG.feFuncB.extra.content)*
  svg_feFuncB =
    element ns2:feFuncB { svg_attlist.feFuncB, svg_SVG.feFuncB.content }
  svg_attlist.feFuncB &=
    svg_SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { svg_Number.datatype }?,
    attribute intercept { svg_Number.datatype }?,
    attribute amplitude { svg_Number.datatype }?,
    attribute exponent { svg_Number.datatype }?,
    attribute offset { svg_Number.datatype }?
  svg_SVG.feFuncA.extra.content = notAllowed
  svg_SVG.feFuncA.content =
    (svg_animate | svg_set | svg_SVG.feFuncA.extra.content)*
  svg_feFuncA =
    element ns2:feFuncA { svg_attlist.feFuncA, svg_SVG.feFuncA.content }
  svg_attlist.feFuncA &=
    svg_SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { svg_Number.datatype }?,
    attribute intercept { svg_Number.datatype }?,
    attribute amplitude { svg_Number.datatype }?,
    attribute exponent { svg_Number.datatype }?,
    attribute offset { svg_Number.datatype }?
  svg_SVG.cursor.extra.content = notAllowed
  svg_SVG.cursor.content =
    (svg_SVG.Description.class | svg_SVG.cursor.extra.content)*
  svg_cursor =
    element ns2:cursor { svg_attlist.cursor, svg_SVG.cursor.content }
  svg_attlist.cursor &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.XLinkRequired.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?
  svg_LinkTarget.datatype = xsd:NMTOKEN
  svg_SVG.a.extra.content = notAllowed
  svg_SVG.a.content =
    (text
     | svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.a.extra.content)*
  svg_a = element ns2:a { svg_attlist.a, svg_SVG.a.content }
  svg_attlist.a &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.XLinkReplace.attrib,
    svg_SVG.External.attrib,
    attribute transform { svg_TransformList.datatype }?,
    attribute target { svg_LinkTarget.datatype }?
  svg_SVG.view.extra.content = notAllowed
  svg_SVG.view.content =
    (svg_SVG.Description.class | svg_SVG.view.extra.content)*
  svg_view = element ns2:view { svg_attlist.view, svg_SVG.view.content }
  svg_attlist.view &=
    svg_SVG.Core.attrib,
    svg_SVG.External.attrib,
    attribute viewBox { svg_ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio {
      svg_PreserveAspectRatioSpec.datatype
    }?,
    [ a:defaultValue = "magnify" ]
    attribute zoomAndPan { "disable" | "magnify" }?,
    attribute viewTarget { text }?
  svg_SVG.script.extra.content = notAllowed
  svg_SVG.script.content = (text | svg_SVG.script.extra.content)*
  svg_script =
    element ns2:script { svg_attlist.script, svg_SVG.script.content }
  svg_attlist.script &=
    svg_SVG.Core.attrib,
    svg_SVG.XLink.attrib,
    svg_SVG.External.attrib,
    attribute type { svg_ContentType.datatype }
  svg_SVG.Animation.extra.attrib = empty
  svg_SVG.Animation.attrib =
    svg_SVG.XLink.attrib, svg_SVG.Animation.extra.attrib
  svg_SVG.AnimationAttribute.extra.attrib = empty
  svg_SVG.AnimationAttribute.attrib =
    attribute attributeName { text },
    attribute attributeType { text }?,
    svg_SVG.AnimationAttribute.extra.attrib
  svg_SVG.AnimationTiming.extra.attrib = empty
  svg_SVG.AnimationTiming.attrib =
    attribute begin { text }?,
    attribute dur { text }?,
    attribute end { text }?,
    attribute min { text }?,
    attribute max { text }?,
    [ a:defaultValue = "always" ]
    attribute restart { "always" | "never" | "whenNotActive" }?,
    attribute repeatCount { text }?,
    attribute repeatDur { text }?,
    [ a:defaultValue = "remove" ]
    attribute fill { "remove" | "freeze" }?,
    svg_SVG.AnimationTiming.extra.attrib
  svg_SVG.AnimationValue.extra.attrib = empty
  svg_SVG.AnimationValue.attrib =
    [ a:defaultValue = "linear" ]
    attribute calcMode { "discrete" | "linear" | "paced" | "spline" }?,
    attribute values { text }?,
    attribute keyTimes { text }?,
    attribute keySplines { text }?,
    attribute from { text }?,
    attribute to { text }?,
    attribute by { text }?,
    svg_SVG.AnimationValue.extra.attrib
  svg_SVG.AnimationAddtion.extra.attrib = empty
  svg_SVG.AnimationAddtion.attrib =
    [ a:defaultValue = "replace" ]
    attribute additive { "replace" | "sum" }?,
    [ a:defaultValue = "none" ]
    attribute accumulate { "none" | "sum" }?,
    svg_SVG.AnimationAddtion.extra.attrib
  svg_SVG.animate.extra.content = notAllowed
  svg_SVG.animate.content =
    (svg_SVG.Description.class | svg_SVG.animate.extra.content)*
  svg_animate =
    element ns2:animate { svg_attlist.animate, svg_SVG.animate.content }
  svg_attlist.animate &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.AnimationEvents.attrib,
    svg_SVG.External.attrib,
    svg_SVG.Animation.attrib,
    svg_SVG.AnimationAttribute.attrib,
    svg_SVG.AnimationTiming.attrib,
    svg_SVG.AnimationValue.attrib,
    svg_SVG.AnimationAddtion.attrib
  svg_SVG.set.extra.content = notAllowed
  svg_SVG.set.content =
    (svg_SVG.Description.class | svg_SVG.set.extra.content)*
  svg_set = element ns2:set { svg_attlist.set, svg_SVG.set.content }
  svg_attlist.set &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.AnimationEvents.attrib,
    svg_SVG.External.attrib,
    svg_SVG.Animation.attrib,
    svg_SVG.AnimationAttribute.attrib,
    svg_SVG.AnimationTiming.attrib,
    attribute to { text }?
  svg_SVG.animateMotion.extra.content = empty
  svg_SVG.animateMotion.content =
    svg_SVG.Description.class*,
    svg_mpath?,
    svg_SVG.animateMotion.extra.content
  svg_animateMotion =
    element ns2:animateMotion {
      svg_attlist.animateMotion, svg_SVG.animateMotion.content
    }
  svg_attlist.animateMotion &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.AnimationEvents.attrib,
    svg_SVG.External.attrib,
    svg_SVG.Animation.attrib,
    svg_SVG.AnimationTiming.attrib,
    svg_SVG.AnimationAddtion.attrib,
    [ a:defaultValue = "paced" ]
    attribute calcMode { "discrete" | "linear" | "paced" | "spline" }?,
    attribute values { text }?,
    attribute keyTimes { text }?,
    attribute keySplines { text }?,
    attribute from { text }?,
    attribute to { text }?,
    attribute by { text }?,
    attribute path { text }?,
    attribute keyPoints { text }?,
    attribute rotate { text }?,
    attribute origin { text }?
  svg_SVG.animateColor.extra.content = notAllowed
  svg_SVG.animateColor.content =
    (svg_SVG.Description.class | svg_SVG.animateColor.extra.content)*
  svg_animateColor =
    element ns2:animateColor {
      svg_attlist.animateColor, svg_SVG.animateColor.content
    }
  svg_attlist.animateColor &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.AnimationEvents.attrib,
    svg_SVG.External.attrib,
    svg_SVG.Animation.attrib,
    svg_SVG.AnimationAttribute.attrib,
    svg_SVG.AnimationTiming.attrib,
    svg_SVG.AnimationValue.attrib,
    svg_SVG.AnimationAddtion.attrib
  svg_SVG.animateTransform.extra.content = notAllowed
  svg_SVG.animateTransform.content =
    (svg_SVG.Description.class
     | svg_SVG.animateTransform.extra.content)*
  svg_animateTransform =
    element ns2:animateTransform {
      svg_attlist.animateTransform, svg_SVG.animateTransform.content
    }
  svg_attlist.animateTransform &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.AnimationEvents.attrib,
    svg_SVG.External.attrib,
    svg_SVG.Animation.attrib,
    svg_SVG.AnimationAttribute.attrib,
    svg_SVG.AnimationTiming.attrib,
    svg_SVG.AnimationValue.attrib,
    svg_SVG.AnimationAddtion.attrib,
    [ a:defaultValue = "translate" ]
    attribute type {
      "translate" | "scale" | "rotate" | "skewX" | "skewY"
    }?
  svg_SVG.mpath.extra.content = notAllowed
  svg_SVG.mpath.content =
    (svg_SVG.Description.class | svg_SVG.mpath.extra.content)*
  svg_mpath =
    element ns2:mpath { svg_attlist.mpath, svg_SVG.mpath.content }
  svg_attlist.mpath &=
    svg_SVG.Core.attrib,
    svg_SVG.XLinkRequired.attrib,
    svg_SVG.External.attrib
  svg_SVG.font.extra.content = notAllowed
  svg_SVG.font.content =
    svg_SVG.Description.class*,
    svg_font-face,
    svg_missing-glyph,
    (svg_glyph | svg_hkern | svg_vkern | svg_SVG.font.extra.content)*
  svg_font = element ns2:font { svg_attlist.font, svg_SVG.font.content }
  svg_attlist.font &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.External.attrib,
    attribute horiz-origin-x { svg_Number.datatype }?,
    attribute horiz-origin-y { svg_Number.datatype }?,
    attribute horiz-adv-x { svg_Number.datatype },
    attribute vert-origin-x { svg_Number.datatype }?,
    attribute vert-origin-y { svg_Number.datatype }?,
    attribute vert-adv-y { svg_Number.datatype }?
  svg_SVG.font-face.extra.content = empty
  svg_SVG.font-face.content =
    svg_SVG.Description.class*,
    svg_font-face-src?,
    svg_definition-src?,
    svg_SVG.font-face.extra.content
  svg_font-face =
    element ns2:font-face {
      svg_attlist.font-face, svg_SVG.font-face.content
    }
  svg_attlist.font-face &=
    svg_SVG.Core.attrib,
    attribute font-family { text }?,
    attribute font-style { text }?,
    attribute font-variant { text }?,
    attribute font-weight { text }?,
    attribute font-stretch { text }?,
    attribute font-size { text }?,
    attribute unicode-range { text }?,
    attribute units-per-em { svg_Number.datatype }?,
    attribute panose-1 { text }?,
    attribute stemv { svg_Number.datatype }?,
    attribute stemh { svg_Number.datatype }?,
    attribute slope { svg_Number.datatype }?,
    attribute cap-height { svg_Number.datatype }?,
    attribute x-height { svg_Number.datatype }?,
    attribute accent-height { svg_Number.datatype }?,
    attribute ascent { svg_Number.datatype }?,
    attribute descent { svg_Number.datatype }?,
    attribute widths { text }?,
    attribute bbox { text }?,
    attribute ideographic { svg_Number.datatype }?,
    attribute alphabetic { svg_Number.datatype }?,
    attribute mathematical { svg_Number.datatype }?,
    attribute hanging { svg_Number.datatype }?,
    attribute v-ideographic { svg_Number.datatype }?,
    attribute v-alphabetic { svg_Number.datatype }?,
    attribute v-mathematical { svg_Number.datatype }?,
    attribute v-hanging { svg_Number.datatype }?,
    attribute underline-position { svg_Number.datatype }?,
    attribute underline-thickness { svg_Number.datatype }?,
    attribute strikethrough-position { svg_Number.datatype }?,
    attribute strikethrough-thickness { svg_Number.datatype }?,
    attribute overline-position { svg_Number.datatype }?,
    attribute overline-thickness { svg_Number.datatype }?
  svg_SVG.glyph.extra.content = notAllowed
  svg_SVG.glyph.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.glyph.extra.content)*
  svg_glyph =
    element ns2:glyph { svg_attlist.glyph, svg_SVG.glyph.content }
  svg_attlist.glyph &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    attribute unicode { text }?,
    attribute glyph-name { text }?,
    attribute d { svg_PathData.datatype }?,
    attribute orientation { text }?,
    attribute arabic-form { text }?,
    attribute lang { svg_LanguageCodes.datatype }?,
    attribute horiz-adv-x { svg_Number.datatype }?,
    attribute vert-origin-x { svg_Number.datatype }?,
    attribute vert-origin-y { svg_Number.datatype }?,
    attribute vert-adv-y { svg_Number.datatype }?
  svg_SVG.missing-glyph.extra.content = notAllowed
  svg_SVG.missing-glyph.content =
    (svg_SVG.Description.class
     | svg_SVG.Animation.class
     | svg_SVG.Structure.class
     | svg_SVG.Conditional.class
     | svg_SVG.Image.class
     | svg_SVG.Style.class
     | svg_SVG.Shape.class
     | svg_SVG.Text.class
     | svg_SVG.Marker.class
     | svg_SVG.ColorProfile.class
     | svg_SVG.Gradient.class
     | svg_SVG.Pattern.class
     | svg_SVG.Clip.class
     | svg_SVG.Mask.class
     | svg_SVG.Filter.class
     | svg_SVG.Cursor.class
     | svg_SVG.Hyperlink.class
     | svg_SVG.View.class
     | svg_SVG.Script.class
     | svg_SVG.Font.class
     | svg_SVG.missing-glyph.extra.content)*
  svg_missing-glyph =
    element ns2:missing-glyph {
      svg_attlist.missing-glyph, svg_SVG.missing-glyph.content
    }
  svg_attlist.missing-glyph &=
    svg_SVG.Core.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    attribute d { svg_PathData.datatype }?,
    attribute horiz-adv-x { svg_Number.datatype }?,
    attribute vert-origin-x { svg_Number.datatype }?,
    attribute vert-origin-y { svg_Number.datatype }?,
    attribute vert-adv-y { svg_Number.datatype }?
  svg_SVG.hkern.content = empty
  svg_hkern =
    element ns2:hkern { svg_attlist.hkern, svg_SVG.hkern.content }
  svg_attlist.hkern &=
    svg_SVG.Core.attrib,
    attribute u1 { text }?,
    attribute g1 { text }?,
    attribute u2 { text }?,
    attribute g2 { text }?,
    attribute k { svg_Number.datatype }
  svg_SVG.vkern.content = empty
  svg_vkern =
    element ns2:vkern { svg_attlist.vkern, svg_SVG.vkern.content }
  svg_attlist.vkern &=
    svg_SVG.Core.attrib,
    attribute u1 { text }?,
    attribute g1 { text }?,
    attribute u2 { text }?,
    attribute g2 { text }?,
    attribute k { svg_Number.datatype }
  svg_SVG.font-face-src.extra.content = notAllowed
  svg_SVG.font-face-src.content =
    (svg_font-face-uri
     | svg_font-face-name
     | svg_SVG.font-face-src.extra.content)+
  svg_font-face-src =
    element ns2:font-face-src {
      svg_attlist.font-face-src, svg_SVG.font-face-src.content
    }
  svg_attlist.font-face-src &= svg_SVG.Core.attrib
  svg_SVG.font-face-uri.extra.content = notAllowed
  svg_SVG.font-face-uri.content =
    (svg_font-face-format | svg_SVG.font-face-uri.extra.content)*
  svg_font-face-uri =
    element ns2:font-face-uri {
      svg_attlist.font-face-uri, svg_SVG.font-face-uri.content
    }
  svg_attlist.font-face-uri &=
    svg_SVG.Core.attrib, svg_SVG.XLinkRequired.attrib
  svg_SVG.font-face-format.content = empty
  svg_font-face-format =
    element ns2:font-face-format {
      svg_attlist.font-face-format, svg_SVG.font-face-format.content
    }
  svg_attlist.font-face-format &=
    svg_SVG.Core.attrib,
    attribute string { text }?
  svg_SVG.font-face-name.content = empty
  svg_font-face-name =
    element ns2:font-face-name {
      svg_attlist.font-face-name, svg_SVG.font-face-name.content
    }
  svg_attlist.font-face-name &=
    svg_SVG.Core.attrib,
    attribute name { text }?
  svg_SVG.definition-src.content = empty
  svg_definition-src =
    element ns2:definition-src {
      svg_attlist.definition-src, svg_SVG.definition-src.content
    }
  svg_attlist.definition-src &=
    svg_SVG.Core.attrib, svg_SVG.XLinkRequired.attrib
  svg_SVG.foreignObject.extra.content = notAllowed
  svg_SVG.foreignObject.content =
    (text | svg_SVG.foreignObject.extra.content)*
  svg_foreignObject =
    element ns2:foreignObject {
      svg_attlist.foreignObject, svg_SVG.foreignObject.content
    }
  svg_attlist.foreignObject &=
    svg_SVG.Core.attrib,
    svg_SVG.Conditional.attrib,
    svg_SVG.Style.attrib,
    svg_SVG.Presentation.attrib,
    svg_SVG.GraphicalEvents.attrib,
    svg_SVG.External.attrib,
    attribute x { svg_Coordinate.datatype }?,
    attribute y { svg_Coordinate.datatype }?,
    attribute width { svg_Length.datatype },
    attribute height { svg_Length.datatype },
    attribute transform { svg_TransformList.datatype }?
  mei_model.graphicLike |= svg_svg
}
mei_data.ACCIDENTAL.WRITTEN =
  
  ## Sharp.
  "s"
  | 
    ## Flat.
    "f"
  | 
    ## Double sharp (written as 2 sharps).
    "ss"
  | 
    ## Double sharp (written using croix).
    "x"
  | 
    ## Double flat.
    "ff"
  | 
    ## Triple sharp (written as a croix followed by a sharp).
    "xs"
  | 
    ## Triple sharp (written as a sharp followed by a croix).
    "sx"
  | 
    ## Triple sharp (written as 3 sharps).
    "ts"
  | 
    ## Triple flat.
    "tf"
  | 
    ## Natural.
    "n"
  | 
    ## Natural + flat; used to cancel preceding double flat.
    "nf"
  | 
    ## Natural + sharp; used to cancel preceding double sharp.
    "ns"
  | 
    ## Sharp note raised by quarter tone (sharp modified by arrow).
    "su"
  | 
    ## Sharp note lowered by quarter tone (sharp modified by arrow).
    "sd"
  | 
    ## Flat note raised by quarter tone (flat modified by arrow).
    "fu"
  | 
    ## Flat note lowered by quarter tone (flat modified by arrow).
    "fd"
  | 
    ## Natural note raised by quarter tone (natural modified by arrow).
    "nu"
  | 
    ## Natural note lowered by quarter tone (natural modified by arrow).
    "nd"
  | 
    ## 1/4-tone flat accidental.
    "1qf"
  | 
    ## 3/4-tone flat accidental.
    "3qf"
  | 
    ## 1/4-tone sharp accidental.
    "1qs"
  | 
    ## 3/4-tone sharp accidental.
    "3qs"
mei_data.ACCIDENTAL.GESTURAL =
  
  ## Sharp.
  "s"
  | 
    ## Flat.
    "f"
  | 
    ## Double sharp.
    "ss"
  | 
    ## Double flat.
    "ff"
  | 
    ## Natural.
    "n"
  | 
    ## Three quarter-tones sharp.
    "su"
  | 
    ## Quarter-tone sharp.
    "sd"
  | 
    ## Quarter-tone flat.
    "fu"
  | 
    ## Three quarter-tones flat.
    "fd"
mei_data.ARTICULATION =
  
  ## Accent (Unicode 1D17B).
  "acc"
  | 
    ## Staccato (Unicode 1D17C).
    "stacc"
  | 
    ## Tenuto (Unicode 1D17D).
    "ten"
  | 
    ## Staccatissimo (Unicode 1D17E).
    "stacciss"
  | 
    ## Marcato (Unicode 1D17F).
    "marc"
  | 
    ## Spiccato.
    "spicc"
  | 
    ## Main note followed by short slide to higher, indeterminate pitch (Unicode 1D185).
    "doit"
  | 
    ## Main note preceded by short slide from lower, indeterminate pitch (Unicode 1D186).
    "scoop"
  | 
    ## Main note preceded by long slide from lower, often indeterminate pitch; also known as "squeeze".
    "rip"
  | 
    ## Main note preceded by "slide" from higher, indeterminate pitch.
    "plop"
  | 
    ## Main note followed by short "slide" to lower, indeterminate pitch.
    "fall"
  | 
    ## Main note followed by long "slide" to lower, indeterminate pitch.
    "longfall"
  | 
    ## "lip slur" to lower pitch, then return to written pitch.
    "bend"
  | 
    ## Main note followed by quick upward rise, then descent in pitch (Unicode 1D187).
    "flip"
  | 
    ## (Unicode 1D188).
    "smear"
  | 
    ## Alternation between written pitch and next highest overtone (brass instruments) or note minor third higher (woodwinds).
    "shake"
  | 
    ## Down bow (Unicode 1D1AA).
    "dnbow"
  | 
    ## Up bow (Unicode 1D1AB).
    "upbow"
  | 
    ## Harmonic (Unicode 1D1AC).
    "harm"
  | 
    ## Snap pizzicato (Unicode 1D1AD).
    "snap"
  | 
    ## Fingernail (Unicode 1D1B3).
    "fingernail"
  | 
    ## Stop harp string from sounding (Unicode 1D1B4).
    "damp"
  | 
    ## Stop all harp strings from sounding (Unicode 1D1B5).
    "dampall"
  | 
    ## Full (as opposed to stopped) tone.
    "open"
  | 
    ## "muffled" tone.
    "stop"
  | 
    ## Double tongue (Unicode 1D18A).
    "dbltongue"
  | 
    ## Triple tongue (Unicode 1D18B).
    "trpltongue"
  | 
    ## Use heel (organ pedal).
    "heel"
  | 
    ## Use toe (organ pedal).
    "toe"
  | 
    ## Percussive effect on guitar string(s).
    "tap"
  | 
    ## Left-hand pizzicato.
    "lhpizz"
  | 
    ## Uninterpreted dot.
    "dot"
  | 
    ## Uninterpreted stroke.
    "stroke"
mei_data.AUGMENTDOT = xsd:nonNegativeInteger { maxInclusive = "4" }
mei_data.BARMETHOD =
  
  ## Between staves only.
  "mensur"
  | 
    ## Between and across staves as necessary.
    "staff"
  | 
    ## Short bar line through a subset of staff lines.
    "takt"
mei_data.BARRENDITION =
  
  ## Dashed line (Unicode 1D104).
  "dashed"
  | 
    ## Dotted line.
    "dotted"
  | 
    ## (Unicode 1D101).
    "dbl"
  | 
    ## Double dashed line.
    "dbldashed"
  | 
    ## Double dotted line.
    "dbldotted"
  | 
    ## (Unicode 1D102).
    "end"
  | 
    ## Bar line not rendered.
    "invis"
  | 
    ## Repeat start (Unicode 1D106).
    "rptstart"
  | 
    ## Repeat start and end.
    "rptboth"
  | 
    ## Repeat end (Unicode 1D107).
    "rptend"
  | 
    ## (Unicode 1D100).
    "single"
mei_data.BEAM = xsd:token { pattern = "[i|m|t][1-6]" }
mei_data.BEAMPLACE =
  
  ## The beam is above the material it affects.
  "above"
  | 
    ## The beam is below the material it affects.
    "below"
  | 
    ## The below is above and below the material it affects.
    "mixed"
mei_data.BEAT = xsd:decimal { minInclusive = "0" }
mei_data.BEATRPT.REND =
  xsd:positiveInteger { pattern = "1|2|3|4|5" }
  | xsd:token { pattern = "mixed" }
mei_data.BEND.AMOUNT =
  xsd:decimal { pattern = "\.25|\.5|\.75" }
  | xsd:decimal { pattern = "[0-9](\.25|\.5|\.75)?" }
  | xsd:token { pattern = "full" }
mei_data.BOOLEAN =
  
  ## True.
  "true"
  | 
    ## False.
    "false"
mei_data.CERTAINTY =
  
  ## High certainty.
  "high"
  | 
    ## Medium certainty.
    "medium"
  | 
    ## Low certainty.
    "low"
  | 
    ## An unknown level of certainty.
    "unknown"
mei_data.CLEFLINE = xsd:positiveInteger
mei_data.CLEFSHAPE =
  
  ## G clef (Unicode 1D11E).
  "G"
  | 
    ## Double G clef.
    "GG"
  | 
    ## F clef (Unicode 1D122).
    "F"
  | 
    ## C clef (Unicode 1D121).
    "C"
  | 
    ## Drum clef (Unicode 1D125 or Unicode 1D126).
    "perc"
  | 
    ## Tablature "clef"; i.e. usually "TAB" rendered vertically.
    "TAB"
mei_data.CLUSTER =
  
  ## White keys.
  "white"
  | 
    ## Black keys.
    "black"
  | 
    ## Mixed black and white keys.
    "chromatic"
mei_data.CONFIDENCE =
  xsd:decimal { minInclusive = "0" maxInclusive = "1" }
mei_data.COLORNAMES =
  
  ## Hex: #f0f8ff / RGB: 240,248,255
  "aliceblue"
  | 
    ## Hex: #faebd7 / RGB: 250,235,215
    "antiquewhite"
  | 
    ## Hex: #00ffff / RGB: 0,255,255
    "aqua"
  | 
    ## Hex: #7fffd4 / RGB: 127,255,212
    "aquamarine"
  | 
    ## Hex: #f0ffff / RGB: 240,255,255
    "azure"
  | 
    ## Hex: #f5f5dc / RGB: 245,245,220
    "beige"
  | 
    ## Hex: #ffe4c4 / RGB: 255,228,196
    "bisque"
  | 
    ## Hex: #000000 / RGB: 0,0,0
    "black"
  | 
    ## Hex: #ffebcd / RGB: 255,235,205
    "blanchedalmond"
  | 
    ## Hex: #0000ff / RGB: 0,0,255
    "blue"
  | 
    ## Hex: #8a2be2 / RGB: 138,43,226
    "blueviolet"
  | 
    ## Hex: #a52a2a / RGB: 165,42,42
    "brown"
  | 
    ## Hex: #deb887 / RGB: 222,184,135
    "burlywood"
  | 
    ## Hex: #5f9ea0 / RGB: 95,158,160
    "cadetblue"
  | 
    ## Hex: #7fff00 / RGB: 127,255,0
    "chartreuse"
  | 
    ## Hex: #d2691e / RGB: 210,105,30
    "chocolate"
  | 
    ## Hex: #ff7f50 / RGB: 255,127,80
    "coral"
  | 
    ## Hex: #6495ed / RGB: 100,149,237
    "cornflowerblue"
  | 
    ## Hex: #fff8dc / RGB: 255,248,220
    "cornsilk"
  | 
    ## Hex: #dc143c / RGB: 220,20,60
    "crimson"
  | 
    ## Hex: #00ffff / RGB: 0,255,255
    "cyan"
  | 
    ## Hex: #00008b / RGB: 0,0,139
    "darkblue"
  | 
    ## Hex: #008b8b / RGB: 0,139,139
    "darkcyan"
  | 
    ## Hex: #b8860b / RGB: 184,134,11
    "darkgoldenrod"
  | 
    ## Hex: #a9a9a9 / RGB: 169,169,169
    "darkgray"
  | 
    ## Hex: #006400 / RGB: 0,100,0
    "darkgreen"
  | 
    ## Hex: #a9a9a9 / RGB: 169,169,169
    "darkgrey"
  | 
    ## Hex: #bdb76b / RGB: 189,183,107
    "darkkhaki"
  | 
    ## Hex: #8b008b / RGB: 139,0,139
    "darkmagenta"
  | 
    ## Hex: #556b2f / RGB: 85,107,47
    "darkolivegreen"
  | 
    ## Hex: #ff8c00 / RGB: 255,140,0
    "darkorange"
  | 
    ## Hex: #9932cc / RGB: 153,50,204
    "darkorchid"
  | 
    ## Hex: #8b0000 / RGB: 139,0,0
    "darkred"
  | 
    ## Hex: #e9967a / RGB: 233,150,122
    "darksalmon"
  | 
    ## Hex: #8fbc8f / RGB: 143,188,143
    "darkseagreen"
  | 
    ## Hex: #483d8b / RGB: 72,61,139
    "darkslateblue"
  | 
    ## Hex: #2f4f4f / RGB: 47,79,79
    "darkslategray"
  | 
    ## Hex: #2f4f4f / RGB: 47,79,79
    "darkslategrey"
  | 
    ## Hex: #00ced1 / RGB: 0,206,209
    "darkturquoise"
  | 
    ## Hex: #9400d3 / RGB: 148,0,211
    "darkviolet"
  | 
    ## Hex: #ff1493 / RGB: 255,20,147
    "deeppink"
  | 
    ## Hex: #00bfff / RGB: 0,191,255
    "deepskyblue"
  | 
    ## Hex: #696969 / RGB: 105,105,105
    "dimgray"
  | 
    ## Hex: #696969 / RGB: 105,105,105
    "dimgrey"
  | 
    ## Hex: #1e90ff / RGB: 30,144,255
    "dodgerblue"
  | 
    ## Hex: #b22222 / RGB: 178,34,34
    "firebrick"
  | 
    ## Hex: #fffaf0 / RGB: 255,250,240
    "floralwhite"
  | 
    ## Hex: #228b22 / RGB: 34,139,34
    "forestgreen"
  | 
    ## Hex: #ff00ff / RGB: 255,0,255
    "fuchsia"
  | 
    ## Hex: #dcdcdc / RGB: 220,220,220
    "gainsboro"
  | 
    ## Hex: #f8f8ff / RGB: 248,248,255
    "ghostwhite"
  | 
    ## Hex: #ffd700 / RGB: 255,215,0
    "gold"
  | 
    ## Hex: #daa520 / RGB: 218,165,32
    "goldenrod"
  | 
    ## Hex: #808080 / RGB: 128,128,128
    "gray"
  | 
    ## Hex: #008000 / RGB: 0,128,0
    "green"
  | 
    ## Hex: #adff2f / RGB: 173,255,47
    "greenyellow"
  | 
    ## Hex: #808080 / RGB: 128,128,128
    "grey"
  | 
    ## Hex: #f0fff0 / RGB: 240,255,240
    "honeydew"
  | 
    ## Hex: #ff69b4 / RGB: 255,105,180
    "hotpink"
  | 
    ## Hex: #cd5c5c / RGB: 205,92,92
    "indianred"
  | 
    ## Hex: #4b0082 / RGB: 75,0,130
    "indigo"
  | 
    ## Hex: #fffff0 / RGB: 255,255,240
    "ivory"
  | 
    ## Hex: #f0e68c / RGB: 240,230,140
    "khaki"
  | 
    ## Hex: #e6e6fa / RGB: 230,230,250
    "lavender"
  | 
    ## Hex: #fff0f5 / RGB: 255,240,245
    "lavenderblush"
  | 
    ## Hex: #7cfc00 / RGB: 124,252,0
    "lawngreen"
  | 
    ## Hex: #fffacd / RGB: 255,250,205
    "lemonchiffon"
  | 
    ## Hex: #add8e6 / RGB: 173,216,230
    "lightblue"
  | 
    ## Hex: #f08080 / RGB: 240,128,128
    "lightcoral"
  | 
    ## Hex: #e0ffff / RGB: 224,255,255
    "lightcyan"
  | 
    ## Hex: #fafad2 / RGB: 250,250,210
    "lightgoldenrodyellow"
  | 
    ## Hex: #d3d3d3 / RGB: 211,211,211
    "lightgray"
  | 
    ## Hex: #90ee90 / RGB: 144,238,144
    "lightgreen"
  | 
    ## Hex: #d3d3d3 / RGB: 211,211,211
    "lightgrey"
  | 
    ## Hex: #ffb6c1 / RGB: 255,182,193
    "lightpink"
  | 
    ## Hex: #ffa07a / RGB: 255,160,122
    "lightsalmon"
  | 
    ## Hex: #20b2aa / RGB: 32,178,170
    "lightseagreen"
  | 
    ## Hex: #87cefa / RGB: 135,206,250
    "lightskyblue"
  | 
    ## Hex: #778899 / RGB: 119,136,153
    "lightslategray"
  | 
    ## Hex: #778899 / RGB: 119,136,153
    "lightslategrey"
  | 
    ## Hex: #b0c4de / RGB: 176,196,222
    "lightsteelblue"
  | 
    ## Hex: #ffffe0 / RGB: 255,255,224
    "lightyellow"
  | 
    ## Hex: #00ff00 / RGB: 0,255,0
    "lime"
  | 
    ## Hex: #32cd32 / RGB: 50,205,50
    "limegreen"
  | 
    ## Hex: #faf0e6 / RGB: 250,240,230
    "linen"
  | 
    ## Hex: #ff00ff / RGB: 255,0,255
    "magenta"
  | 
    ## Hex: #800000 / RGB: 128,0,0
    "maroon"
  | 
    ## Hex: #66cdaa / RGB: 102,205,170
    "mediumaquamarine"
  | 
    ## Hex: #0000cd / RGB: 0,0,205
    "mediumblue"
  | 
    ## Hex: #ba55d3 / RGB: 186,85,211
    "mediumorchid"
  | 
    ## Hex: #9370db / RGB: 147,112,219
    "mediumpurple"
  | 
    ## Hex: #3cb371 / RGB: 60,179,113
    "mediumseagreen"
  | 
    ## Hex: #7b68ee / RGB: 123,104,238
    "mediumslateblue"
  | 
    ## Hex: #00fa9a / RGB: 0,250,154
    "mediumspringgreen"
  | 
    ## Hex: #48d1cc / RGB: 72,209,204
    "mediumturquoise"
  | 
    ## Hex: #c71585 / RGB: 199,21,133
    "mediumvioletred"
  | 
    ## Hex: #191970 / RGB: 25,25,112
    "midnightblue"
  | 
    ## Hex: #f5fffa / RGB: 245,255,250
    "mintcream"
  | 
    ## Hex: #ffe4e1 / RGB: 255,228,225
    "mistyrose"
  | 
    ## Hex: #ffe4b5 / RGB: 255,228,181
    "moccasin"
  | 
    ## Hex: #ffdead / RGB: 255,222,173
    "navajowhite"
  | 
    ## Hex: #000080 / RGB: 0,0,128
    "navy"
  | 
    ## Hex: #fdf5e6 / RGB: 253,245,230
    "oldlace"
  | 
    ## Hex: #808000 / RGB: 128,128,0
    "olive"
  | 
    ## Hex: #6b8e23 / RGB: 107,142,35
    "olivedrab"
  | 
    ## Hex: #ffa500 / RGB: 255,165,0
    "orange"
  | 
    ## Hex: #ff4500 / RGB: 255,69,0
    "orangered"
  | 
    ## Hex: #da70d6 / RGB: 218,112,214
    "orchid"
  | 
    ## Hex: #eee8aa / RGB: 238,232,170
    "palegoldenrod"
  | 
    ## Hex: #98fb98 / RGB: 152,251,152
    "palegreen"
  | 
    ## Hex: #afeeee / RGB: 175,238,238
    "paleturquoise"
  | 
    ## Hex: #db7093 / RGB: 219,112,147
    "palevioletred"
  | 
    ## Hex: #ffefd5 / RGB: 255,239,213
    "papayawhip"
  | 
    ## Hex: #ffdab9 / RGB: 255,218,185
    "peachpuff"
  | 
    ## Hex: #cd853f / RGB: 205,133,63
    "peru"
  | 
    ## Hex: #ffc0cb / RGB: 255,192,203
    "pink"
  | 
    ## Hex: #dda0dd / RGB: 221,160,221
    "plum"
  | 
    ## Hex: #b0e0e6 / RGB: 176,224,230
    "powderblue"
  | 
    ## Hex: #800080 / RGB: 128,0,128
    "purple"
  | 
    ## Hex: #ff0000 / RGB: 255,0,0
    "red"
  | 
    ## Hex: #bc8f8f / RGB: 188,143,143
    "rosybrown"
  | 
    ## Hex: #4169e1 / RGB: 65,105,225
    "royalblue"
  | 
    ## Hex: #8b4513 / RGB: 139,69,19
    "saddlebrown"
  | 
    ## Hex: #fa8072 / RGB: 250,128,114
    "salmon"
  | 
    ## Hex: #f4a460 / RGB: 244,164,96
    "sandybrown"
  | 
    ## Hex: #2e8b57 / RGB: 46,139,87
    "seagreen"
  | 
    ## Hex: #fff5ee / RGB: 255,245,238
    "seashell"
  | 
    ## Hex: #a0522d / RGB: 160,82,45
    "sienna"
  | 
    ## Hex: #c0c0c0 / RGB: 192,192,192
    "silver"
  | 
    ## Hex: #87ceeb / RGB: 135,206,235
    "skyblue"
  | 
    ## Hex: #6a5acd / RGB: 106,90,205
    "slateblue"
  | 
    ## Hex: #708090 / RGB: 112,128,144
    "slategray"
  | 
    ## Hex: #708090 / RGB: 112,128,144
    "slategrey"
  | 
    ## Hex: #fffafa / RGB: 255,250,250
    "snow"
  | 
    ## Hex: #00ff7f / RGB: 0,255,127
    "springgreen"
  | 
    ## Hex: #4682b4 / RGB: 70,130,180
    "steelblue"
  | 
    ## Hex: #d2b48c / RGB: 210,180,140
    "tan"
  | 
    ## Hex: #008080 / RGB: 0,128,128
    "teal"
  | 
    ## Hex: #d8bfd8 / RGB: 216,191,216
    "thistle"
  | 
    ## Hex: #ff6347 / RGB: 255,99,71
    "tomato"
  | 
    ## Hex: #40e0d0 / RGB: 64,224,208
    "turquoise"
  | 
    ## Hex: #ee82ee / RGB: 238,130,238
    "violet"
  | 
    ## Hex: #f5deb3 / RGB: 245,222,179
    "wheat"
  | 
    ## Hex: #ffffff / RGB: 255,255,255
    "white"
  | 
    ## Hex: #f5f5f5 / RGB: 245,245,245
    "whitesmoke"
  | 
    ## Hex: #ffff00 / RGB: 255,255,0
    "yellow"
  | 
    ## Hex: #9acd32 / RGB: 154,205,50
    "yellowgreen"
mei_data.COLORVALUES =
  xsd:token { pattern = "#[0-9A-Fa-f]{6,6}" }
  | xsd:token { pattern = "#[0-9A-Fa-f]{8,8}" }
  | xsd:token {
      pattern =
        "rgb\((\s*(([01]?[0-9]?[0-9])|2[0-4][0-9]|25[0-5])\s*,\s*){2}([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*\)"
    }
  | xsd:token {
      pattern =
        "rgba\(\s*(([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\s*,\s*){3}(0(\.\d+)?|1(\.0+)?)\s*\)|rgba\(\s*(((\d{1,2})?%|100%)\s*,\s*){2}(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)"
    }
  | xsd:token {
      pattern =
        "hsl\(\s*((\d{1,2})|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*\)"
    }
  | xsd:token {
      pattern =
        "hsla\(\s*(\d{1,2}|[12]\d{2}|3[0-5]\d|360)\s*,\s*(\d{1,2}%|100%)\s*,\s*(\d{1,2}%|100%)\s*,\s*(0(\.\d+)?|1(\.0+)?)\s*\)"
    }
mei_data.COLOR = mei_data.COLORNAMES | mei_data.COLORVALUES
mei_data.DEGREES =
  xsd:decimal { maxInclusive = "360.0" minInclusive = "-360.0" }
mei_data.DURATION = mei_data.DURATION.cmn
mei_data.DURATION.gestural = mei_data.DURATION.cmn
mei_data.ENCLOSURE =
  
  ## Parentheses: ( and ).
  "paren"
  | 
    ## Square brackets: [ and ].
    "brack"
mei_data.FILL =
  
  ## Unfilled
  "void"
  | 
    ## Filled
    "solid"
  | 
    ## Top half filled
    "top"
  | 
    ## Bottom half filled
    "bottom"
  | 
    ## Left half filled
    "left"
  | 
    ## Right half filled
    "right"
mei_data.FINGER.FRET =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "4" }
  | xsd:token { pattern = "x|o|t" }
mei_data.FONTFAMILY = xsd:token
mei_data.FONTNAME = xsd:token
mei_data.FONTSIZE =
  mei_data.FONTSIZENUMERIC | mei_data.FONTSIZETERM | mei_data.PERCENT
mei_data.FONTSIZENUMERIC =
  xsd:token { pattern = "\d*(\.\d+)?(pt|vu)" }
  - ((xsd:token { pattern = "(pt|vu)" }
      | xsd:token { pattern = "0+(pt|vu)" }
      | xsd:token { pattern = "0+(\.0+)?(pt|vu)" }
      | xsd:token { pattern = "\.0+(pt|vu)" }))
mei_data.FONTSIZESCALE =
  xsd:integer { minInclusive = "1" maxInclusive = "9" }
mei_data.FONTSIZETERM =
  
  ## Smaller than x-small.
  "xx-small"
  | 
    ## Smaller than small, larger than xx-small.
    "x-small"
  | 
    ## Smaller than normal, larger than x-small.
    "small"
  | 
    ## Smaller than large, larger than small.
    "normal"
  | 
    ## Smaller than x-large, larger than normal.
    "large"
  | 
    ## Smaller than xx-large, larger than large.
    "x-large"
  | 
    ## Larger than x-large.
    "xx-large"
  | 
    ## One size smaller than the current size.
    "smaller"
  | 
    ## One size larger than the current size.
    "larger"
mei_data.FONTSTYLE =
  
  ## Text slants to right.
  "italic"
  | 
    ## Unadorned.
    "normal"
  | 
    ## Text slants to the left.
    "oblique"
mei_data.FONTWEIGHT =
  
  ## Bold or heavy.
  "bold"
  | 
    ## Not bold.
    "normal"
mei_data.FRETNUMBER = xsd:nonNegativeInteger
mei_data.GLISSANDO =
  
  ## First note/chord in glissando.
  "i"
  | 
    ## Note/chord that's neither first nor last in glissando.
    "m"
  | 
    ## Last note in glissando.
    "t"
mei_data.GRACE =
  
  ## Time "stolen" from following note.
  "acc"
  | 
    ## Time "stolen" from previous note.
    "unacc"
  | 
    ## No interpretation regarding performed value of grace note.
    "unknown"
mei_data.HEADSHAPE =
  mei_data.HEADSHAPE.list | mei_data.HEXNUM | mei_data.NMTOKEN
mei_data.HEADSHAPE.list =
  
  ## Filled, rotated oval (Unicode 1D158).
  "quarter"
  | 
    ## Unfilled, rotated oval (Unicode 1D157).
    "half"
  | 
    ## Unfilled, rotated oval (Unicode 1D15D).
    "whole"
  | 
    ## Unfilled backslash (~ reflection of Unicode 1D10D).
    "backslash"
  | 
    ## Unfilled circle (Unicode 25CB).
    "circle"
  | 
    ## Plus sign (Unicode 1D144).
    "+"
  | 
    ## Unfilled diamond (Unicode 1D1B9).
    "diamond"
  | 
    ## Unfilled isosceles triangle (Unicode 1D148).
    "isotriangle"
  | 
    ## Unfilled, unrotated oval (Unicode 2B2D).
    "oval"
  | 
    ## Unfilled downward-pointing wedge (Unicode 1D154).
    "piewedge"
  | 
    ## Unfilled rectangle (Unicode 25AD).
    "rectangle"
  | 
    ## Unfilled right triangle (Unicode 1D14A).
    "rtriangle"
  | 
    ## Unfilled semi-circle (Unicode 1D152).
    "semicircle"
  | 
    ## Unfilled slash (~ Unicode 1D10D).
    "slash"
  | 
    ## Unfilled square (Unicode 1D146).
    "square"
  | 
    ## X (Unicode 1D143).
    "x"
mei_data.HEXNUM = xsd:string { pattern = "(#x|U\+)[A-F0-9]+" }
mei_data.HORIZONTALALIGNMENT =
  
  ## Left aligned.
  "left"
  | 
    ## Right aligned.
    "right"
  | 
    ## Centered.
    "center"
  | 
    ## Left and right aligned.
    "justify"
mei_data.INTERVAL.HARMONIC = xsd:token { pattern = "[AdMmP][0-9]+" }
mei_data.INTERVAL.MELODIC =
  xsd:token { pattern = "u|d|s|n|sd|su" }
  | xsd:token { pattern = "(\+|\-)?([AdMmP])?[0-9]+" }
  | xsd:token { pattern = "(\+|\-)?\d+(\.\d+)?hs" }
mei_data.ISODATE =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
mei_data.ISOTIME = xsd:time
mei_data.KEYFIFTHS =
  xsd:token { pattern = "mixed|0|([1-9]|1[0-2])[f|s]" }
mei_data.LAYERSCHEME =
  
  ## Single layer.
  "1"
  | 
    ## Two layers with opposing stems.
    "2o"
  | 
    ## Two layers with 'floating' stems.
    "2f"
  | 
    ## Three layers with opposing stems.
    "3o"
  | 
    ## Three layers with 'floating' stems.
    "3f"
mei_data.LINEFORM =
  
  ## Dashed line.
  "dashed"
  | 
    ## Dotted line.
    "dotted"
  | 
    ## Straight, uninterrupted line.
    "solid"
  | 
    ## Undulating line.
    "wavy"
mei_data.LINESTARTENDSYMBOL =
  
  ## 90 degree turn down (similar to Unicode 231D at end of line, 231C at start).
  "angledown"
  | 
    ## 90 degree turn up (similar to Unicode 231F at end of line, 231E at start).
    "angleup"
  | 
    ## 90 degree turn right (syntactic sugar for "angledown" for vertical or angled lines).
    "angleright"
  | 
    ## 90 degree turn left (syntactic sugar for "angleup" for vertical or angled lines).
    "angleleft"
  | 
    ## Filled, triangular arrowhead (similar to Unicode U+25C0 or SMuFL U+EB78).
    "arrow"
  | 
    ## Open triangular arrowhead (similar to Unicode U+02C3 or SMuFL U+EB8A).
    "arrowopen"
  | 
    ## Unfilled, triangular arrowhead (similar to Unicode U+25C1 or SMuFL U+EB82).
    "arrowwhite"
  | 
    ## Harpoon-shaped arrowhead left of line (similar to arrowhead of Unicode U+21BD).
    "harpoonleft"
  | 
    ## Harpoon-shaped arrowhead right of line (similar to arrowhead of Unicode U+21BC).
    "harpoonright"
  | 
    ## Hauptstimme (Unicode U+1D1A6 or SMuFL U+E860).
    "H"
  | 
    ## Nebenstimme (Unicode U+1D1A7 or SMuFL U+E861).
    "N"
  | 
    ## Theme (SMuFL U+E864).
    "Th"
  | 
    ## Theme, retrograde (SMuFL U+E865).
    "ThRetro"
  | 
    ## Theme, retrograde inversion (SMuFL U+E866).
    "ThRetroInv"
  | 
    ## Theme, inverted (SMuFL U+E867).
    "ThInv"
  | 
    ## Theme (SMuFL U+E868).
    "T"
  | 
    ## Theme, inverted (SMuFL U+E869).
    "TInv"
  | 
    ## Choralemelodie (SMuFL U+E86A).
    "CH"
  | 
    ## Hauptrhythmus (SMuFL U+E86B).
    "RH"
  | 
    ## No start/end symbol.
    "none"
mei_data.LINEWIDTH = mei_data.LINEWIDTHTERM | mei_data.MEASUREMENTABS
mei_data.LINEWIDTHTERM =
  
  ## Default line width.
  "narrow"
  | 
    ## Twice as wide as narrow.
    "medium"
  | 
    ## Twice as wide as medium.
    "wide"
mei_data.MEASUREBEAT =
  xsd:token { pattern = "([0-9]+m\s*\+\s*)?[0-9]+(\.?[0-9]*)?" }
mei_data.MEASUREBEATOFFSET =
  xsd:token { pattern = "(\+|-)?[0-9]+m\+[0-9]+(\.[0-9]*)?" }
mei_data.MEASUREMENTABS =
  xsd:token { pattern = "(\+)?\d+(\.\d+)?(cm|mm|in|pt|pc|px|vu)?" }
mei_data.MEASUREMENTREL =
  xsd:token { pattern = "(\+|-)?\d+(\.\d+)?(cm|mm|in|pt|pc|px|vu)?" }
mei_data.MELODICFUNCTION =
  
  ## Accented lower neighbor.
  "aln"
  | 
    ## Anticipation.
    "ant"
  | 
    ## Appogiatura.
    "app"
  | 
    ## Accented passing tone.
    "apt"
  | 
    ## Arpeggio tone (chordal tone).
    "arp"
  | 
    ## Arpeggio tone (7th added to the chord).
    "arp7"
  | 
    ## Accented upper neighbor.
    "aun"
  | 
    ## Changing tone.
    "chg"
  | 
    ## Chromatic lower neighbor.
    "cln"
  | 
    ## Chord tone (i.e., not an embellishment).
    "ct"
  | 
    ## Chord tone (7th added to the chord).
    "ct7"
  | 
    ## Chromatic upper neighbor.
    "cun"
  | 
    ## Chromatic unaccented passing tone.
    "cup"
  | 
    ## Escape tone.
    "et"
  | 
    ## Lower neighbor.
    "ln"
  | 
    ## Pedal tone.
    "ped"
  | 
    ## Repeated tone.
    "rep"
  | 
    ## Retardation.
    "ret"
  | 
    ## 2-3 retardation.
    "23ret"
  | 
    ## 7-8 retardation.
    "78ret"
  | 
    ## Suspension.
    "sus"
  | 
    ## 4-3 suspension.
    "43sus"
  | 
    ## 9-8 suspension.
    "98sus"
  | 
    ## 7-6 suspension.
    "76sus"
  | 
    ## Upper neighbor.
    "un"
  | 
    ## Upper neighbor (7th added to the chord).
    "un7"
  | 
    ## Unaccented passing tone.
    "upt"
  | 
    ## Unaccented passing tone (7th added to the chord).
    "upt7"
mei_data.MENSURATIONSIGN =
  
  ## Tempus imperfectum.
  "C"
  | 
    ## Tempus perfectum.
    "O"
mei_data.METERSIGN =
  
  ## Common time; i.e. 4/4.
  "common"
  | 
    ## Cut time; i.e. 2/2.
    "cut"
mei_data.MIDICHANNEL = xsd:token { pattern = "0|([1-9]|1[0-5])o?|16o" }
mei_data.MIDIBPM = xsd:positiveInteger
mei_data.MIDIMSPB = xsd:positiveInteger
mei_data.MIDINAMES =
  
  ## Program #0.
  "Acoustic Grand Piano"
  | 
    ## Program #1.
    "Bright Acoustic Piano"
  | 
    ## Program #2.
    "Electric Grand Piano"
  | 
    ## Program #3.
    "Honky-tonk Piano"
  | 
    ## Program #4.
    "Electric Piano 1"
  | 
    ## Program #5.
    "Electric Piano 2"
  | 
    ## Program #6.
    "Harpsichord"
  | 
    ## Program #7.
    "Clavi"
  | 
    ## Program #8.
    "Celesta"
  | 
    ## Program #9.
    "Glockenspiel"
  | 
    ## Program #10.
    "Music_Box"
  | 
    ## Program #11.
    "Vibraphone"
  | 
    ## Program #12.
    "Marimba"
  | 
    ## Program #13.
    "Xylophone"
  | 
    ## Program #14.
    "Tubular Bells"
  | 
    ## Program #15.
    "Dulcimer"
  | 
    ## Program #16.
    "Drawbar Organ"
  | 
    ## Program #17.
    "Percussive Organ"
  | 
    ## Program #18.
    "Rock Organ"
  | 
    ## Program #19.
    "Church Organ"
  | 
    ## Program #20.
    "Reed Organ"
  | 
    ## Program #21.
    "Accordion"
  | 
    ## Program #22.
    "Harmonica"
  | 
    ## Program #23.
    "Tango Accordion"
  | 
    ## Program #24.
    "Acoustic Guitar (nylon)"
  | 
    ## Program #25.
    "Acoustic Guitar (steel)"
  | 
    ## Program #26.
    "Electric Guitar (jazz)"
  | 
    ## Program #27.
    "Electric Guitar (clean)"
  | 
    ## Program #28.
    "Electric Guitar (muted)"
  | 
    ## Program #29.
    "Overdriven Guitar"
  | 
    ## Program #30.
    "Distortion Guitar"
  | 
    ## Program #31.
    "Guitar harmonics"
  | 
    ## Program #32.
    "Acoustic Bass"
  | 
    ## Program #33.
    "Electric Bass (finger)"
  | 
    ## Program #34.
    "Electric Bass (pick)"
  | 
    ## Program #35.
    "Fretless Bass"
  | 
    ## Program #36.
    "Slap Bass 1"
  | 
    ## Program #37.
    "Slap Bass 2"
  | 
    ## Program #38.
    "Synth Bass 1"
  | 
    ## Program #39.
    "Synth Bass 2"
  | 
    ## Program #40.
    "Violin"
  | 
    ## Program #41.
    "Viola"
  | 
    ## Program #42.
    "Cello"
  | 
    ## Program #43.
    "Contrabass"
  | 
    ## Program #44.
    "Tremolo Strings"
  | 
    ## Program #45.
    "Pizzicato Strings"
  | 
    ## Program #46.
    "Orchestral Harp"
  | 
    ## Program #47.
    "Timpani"
  | 
    ## Program #48.
    "String Ensemble 1"
  | 
    ## Program #49.
    "String Ensemble 2"
  | 
    ## Program #50.
    "SynthStrings 1"
  | 
    ## Program #51.
    "SynthStrings 2"
  | 
    ## Program #52.
    "Choir Aahs"
  | 
    ## Program #53.
    "Voice Oohs"
  | 
    ## Program #54.
    "Synth Voice"
  | 
    ## Program #55.
    "Orchestra Hit"
  | 
    ## Program #56.
    "Trumpet"
  | 
    ## Program #57.
    "Trombone"
  | 
    ## Program #58.
    "Tuba"
  | 
    ## Program #59.
    "Muted Trumpet"
  | 
    ## Program #60.
    "French Horn"
  | 
    ## Program #61.
    "Brass Section"
  | 
    ## Program #62.
    "SynthBrass 1"
  | 
    ## Program #63.
    "SynthBrass 2"
  | 
    ## Program #64.
    "Soprano Sax"
  | 
    ## Program #65.
    "Alto Sax"
  | 
    ## Program #66.
    "Tenor Sax"
  | 
    ## Program #67.
    "Baritone Sax"
  | 
    ## Program #68.
    "Oboe"
  | 
    ## Program #69.
    "English Horn"
  | 
    ## Program #70.
    "Bassoon"
  | 
    ## Program #71.
    "Clarinet"
  | 
    ## Program #72.
    "Piccolo"
  | 
    ## Program #73.
    "Flute"
  | 
    ## Program #74.
    "Recorder"
  | 
    ## Program #75.
    "Pan Flute"
  | 
    ## Program #76.
    "Blown Bottle"
  | 
    ## Program #77.
    "Shakuhachi"
  | 
    ## Program #78.
    "Whistle"
  | 
    ## Program #79.
    "Ocarina"
  | 
    ## Program #80.
    "Lead 1 (square)"
  | 
    ## Program #81.
    "Lead 2 (sawtooth)"
  | 
    ## Program #82.
    "Lead 3 (calliope)"
  | 
    ## Program #83.
    "Lead 4 (chiff)"
  | 
    ## Program #84.
    "Lead 5 (charang)"
  | 
    ## Program #85.
    "Lead 6 (voice)"
  | 
    ## Program #86.
    "Lead 7 (fifths)"
  | 
    ## Program #87.
    "Lead 8 (bass + lead)"
  | 
    ## Program #88.
    "Pad 1 (new age)"
  | 
    ## Program #89.
    "Pad 2 (warm)"
  | 
    ## Program #90.
    "Pad 3 (polysynth)"
  | 
    ## Program #91.
    "Pad 4 (choir)"
  | 
    ## Program #92.
    "Pad 5 (bowed)"
  | 
    ## Program #93.
    "Pad 6 (metallic)"
  | 
    ## Program #94.
    "Pad 7 (halo)"
  | 
    ## Program #95.
    "Pad 8 (sweep)"
  | 
    ## Program #96.
    "FX 1 (rain)"
  | 
    ## Program #97.
    "FX 2 (soundtrack)"
  | 
    ## Program #98.
    "FX 3 (crystal)"
  | 
    ## Program #99.
    "FX 4 (atmosphere)"
  | 
    ## Program #100.
    "FX 5 (brightness)"
  | 
    ## Program #101.
    "FX 6 (goblins)"
  | 
    ## Program #102.
    "FX 7 (echoes)"
  | 
    ## Program #103.
    "FX 8 (sci-fi)"
  | 
    ## Program #104.
    "Sitar"
  | 
    ## Program #105.
    "Banjo"
  | 
    ## Program #106.
    "Shamisen"
  | 
    ## Program #107.
    "Koto"
  | 
    ## Program #108.
    "Kalimba"
  | 
    ## Program #109.
    "Bagpipe"
  | 
    ## Program #110.
    "Fiddle"
  | 
    ## Program #111.
    "Shanai"
  | 
    ## Program #112.
    "Tinkle Bell"
  | 
    ## Program #113.
    "Agogo"
  | 
    ## Program #114.
    "Steel Drums"
  | 
    ## Program #115.
    "Woodblock"
  | 
    ## Program #116.
    "Taiko Drum"
  | 
    ## Program #117.
    "Melodic Tom"
  | 
    ## Program #118.
    "Synth Drum"
  | 
    ## Program #119.
    "Reverse Cymbal"
  | 
    ## Program #120.
    "Guitar Fret Noise"
  | 
    ## Program #121.
    "Breath Noise"
  | 
    ## Program #122.
    "Seashore"
  | 
    ## Program #123.
    "Bird Tweet"
  | 
    ## Program #124.
    "Telephone Ring"
  | 
    ## Program #125.
    "Helicopter"
  | 
    ## Program #126.
    "Applause"
  | 
    ## Program #127.
    "Gunshot"
  | 
    ## Key #35.
    "Acoustic Bass Drum"
  | 
    ## Key #36.
    "Bass Drum 1"
  | 
    ## Key #37.
    "Side Stick"
  | 
    ## Key #38.
    "Acoustic Snare"
  | 
    ## Key #39.
    "Hand Clap"
  | 
    ## Key #40.
    "Electric Snare"
  | 
    ## Key #41.
    "Low Floor Tom"
  | 
    ## Key #42.
    "Closed Hi Hat"
  | 
    ## Key #43.
    "High Floor Tom"
  | 
    ## Key #44.
    "Pedal Hi-Hat"
  | 
    ## Key #45.
    "Low Tom"
  | 
    ## Key #46.
    "Open Hi-Hat"
  | 
    ## Key #47.
    "Low-Mid Tom"
  | 
    ## Key #48.
    "Hi-Mid Tom"
  | 
    ## Key #49.
    "Crash Cymbal 1"
  | 
    ## Key #50.
    "High Tom"
  | 
    ## Key #51.
    "Ride Cymbal 1"
  | 
    ## Key #52.
    "Chinese Cymbal"
  | 
    ## Key #53.
    "Ride Bell"
  | 
    ## Key #54.
    "Tambourine"
  | 
    ## Key #55.
    "Splash Cymbal"
  | 
    ## Key #56.
    "Cowbell"
  | 
    ## Key #57.
    "Crash Cymbal 2"
  | 
    ## Key #58.
    "Vibraslap"
  | 
    ## Key #59.
    "Ride Cymbal 2"
  | 
    ## Key #60.
    "Hi Bongo"
  | 
    ## Key #61.
    "Low Bongo"
  | 
    ## Key #62.
    "Mute Hi Conga"
  | 
    ## Key #63.
    "Open Hi Conga"
  | 
    ## Key #64.
    "Low Conga"
  | 
    ## Key #65.
    "High Timbale"
  | 
    ## Key #66.
    "Low Timbale"
  | 
    ## Key #67.
    "High Agogo"
  | 
    ## Key #68.
    "Low Agogo"
  | 
    ## Key #69.
    "Cabasa"
  | 
    ## Key #70.
    "Maracas"
  | 
    ## Key #71.
    "Short Whistle"
  | 
    ## Key #72.
    "Long Whistle"
  | 
    ## Key #73.
    "Short Guiro"
  | 
    ## Key #74.
    "Long Guiro"
  | 
    ## Key #75.
    "Claves"
  | 
    ## Key #76.
    "Hi Wood Block"
  | 
    ## Key #77.
    "Low Wood Block"
  | 
    ## Key #78.
    "Mute Cuica"
  | 
    ## Key #79.
    "Open Cuica"
  | 
    ## Key #80.
    "Mute Triangle"
  | 
    ## Key #81.
    "Open Triangle"
mei_data.MIDIVALUE =
  xsd:token {
    pattern = "0|([1-9]|[1-9][0-9]|1([0-1][0-9]|2[0-7]))o?|128o"
  }
mei_data.MIDIVALUE_NAME = mei_data.MIDIVALUE | mei_data.NCNAME
mei_data.MIDIVALUE_PAN =
  mei_data.MIDIVALUE | mei_data.PERCENT.LIMITED.SIGNED
mei_data.MODE =
  
  ## Major mode.
  "major"
  | 
    ## Minor mode.
    "minor"
  | 
    ## Dorian mode.
    "dorian"
  | 
    ## Phrygian mode.
    "phrygian"
  | 
    ## Lydian mode.
    "lydian"
  | 
    ## Mixolydian mode.
    "mixolydian"
  | 
    ## Aeolian mode.
    "aeolian"
  | 
    ## Locrian mode.
    "locrian"
mei_data.MODSRELATIONSHIP =
  
  ## Temporal predecessor of the resource.
  "preceding"
  | 
    ## Temporal successor to the resource.
    "succeeding"
  | 
    ## Original form of the resource.
    "original"
  | 
    ## Parent containing the resource.
    "host"
  | 
    ## Intellectual or physical component of the resource.
    "constituent"
  | 
    ## Version of the resource's intellectual content not changed enough to be a different work.
    "otherVersion"
  | 
    ## Version of the resource in a different physical format.
    "otherFormat"
  | 
    ## Published bibliographic description, review, abstract, or index of the resource's content.
    "isReferencedBy"
  | 
    ## Cited or referred to in the resource.
    "references"
mei_data.MUSICFONT = xsd:token
mei_data.NCNAME = xsd:NCName
mei_data.NMTOKEN = xsd:NMTOKEN
mei_data.NONSTAFFPLACE =
  
  ## At the foot of the page.
  "botmar"
  | 
    ## At the top of the page.
    "topmar"
  | 
    ## At the left of the page.
    "leftmar"
  | 
    ## At the right of the page.
    "rightmar"
  | 
    ## On the opposite, i.e. facing, page.
    "facing"
  | 
    ## On the other side of the leaf.
    "overleaf"
  | 
    ## At the end of this division; e.g., chapter, volume, etc.
    "end"
  | 
    ## Within a line text; i.e., an insertion.
    "inter"
  | 
    ## Between the lines of text, less exact than "sub" or "super".
    "intra"
  | 
    ## Above a line of text, more exact than "intra(linear)". Do not confuse with superscript rendition.
    "super"
  | 
    ## Below a line of text, more exact than "intra(linear)". Do not confuse with subscript rendition.
    "sub"
  | 
    ## In a predefined space; i.e., that left by an earlier scribe.
    "inspace"
  | 
    ## Obscures original text; e.g., via overstrike, addition of new writing surface material, etc.
    "superimposed"
mei_data.NOTATIONTYPE =
  
  ## Common Music Notation.
  "cmn"
  | 
    ## Mensural notation.
    "mensural"
  | 
    ## Black mensural notation.
    "mensural.black"
  | 
    ## White mensural notation.
    "mensural.white"
  | 
    ## Neumatic notation.
    "neume"
  | 
    ## Tablature notation.
    "tab"
mei_data.NOTEHEADMODIFIER =
  mei_data.NOTEHEADMODIFIER.list | mei_data.NOTEHEADMODIFIER.pat
mei_data.NOTEHEADMODIFIER.list =
  
  ## Slash (upper right to lower left).
  "slash"
  | 
    ## Backslash (upper left to lower right).
    "backslash"
  | 
    ## Vertical line.
    "vline"
  | 
    ## Horizontal line.
    "hline"
  | 
    ## Center dot.
    "centerdot"
  | 
    ## Enclosing parentheses.
    "paren"
  | 
    ## Enclosing square brackets.
    "brack"
  | 
    ## Enclosing box.
    "box"
  | 
    ## Enclosing circle.
    "circle"
  | 
    ## Enclosing "fences".
    "dblwhole"
mei_data.NOTEHEADMODIFIER.pat =
  xsd:string { pattern = "centertext\((A|B|C|D|E|F|G)(f||n||s|)?\)" }
  | xsd:string { pattern = "centertext\(H(s|)?\)" }
mei_data.OCTAVE = xsd:nonNegativeInteger { maxInclusive = "9" }
mei_data.OCTAVE.DIS = xsd:positiveInteger { pattern = "8|15|22" }
mei_data.OTHERSTAFF =
  
  ## The staff immediately above.
  "above"
  | 
    ## The staff immediately below.
    "below"
mei_data.PAGE.PANELS =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "2" }
mei_data.PERCENT = xsd:token { pattern = "[0-9]+(\.?[0-9]*)?%" }
mei_data.PERCENT.LIMITED =
  xsd:token { pattern = "(([0-9]|[1-9][0-9])(\.[0-9]+)?|100)%" }
mei_data.PERCENT.LIMITED.SIGNED =
  xsd:token { pattern = "(\+|-)?(([0-9]|[1-9][0-9])(\.[0-9]+)?|100)%" }
mei_data.PGSCALE = mei_data.PERCENT
mei_data.PITCHCLASS = xsd:nonNegativeInteger { maxInclusive = "11" }
mei_data.PITCHNAME = xsd:token { pattern = "[a-g]" }
mei_data.PITCHNAME.GES = xsd:token { pattern = "[a-g]|none" }
mei_data.PITCHNUMBER = xsd:nonNegativeInteger
mei_data.PLACEMENT =
  mei_data.STAFFREL | mei_data.NONSTAFFPLACE | mei_data.NMTOKEN
mei_data.RELATIONSHIP =
  mei_data.FRBRRELATIONSHIP
  | mei_data.MODSRELATIONSHIP
  | mei_data.NMTOKEN
mei_data.ROTATION = mei_data.DEGREES | mei_data.ROTATIONDIRECTION
mei_data.ROTATIONDIRECTION =
  
  ## No rotation.
  "none"
  | 
    ## Rotated 180 degrees.
    "down"
  | 
    ## Rotated 270 degrees clockwise.
    "left"
  | 
    ## Rotated 45 degrees clockwise.
    "ne"
  | 
    ## Rotated 315 degrees clockwise.
    "nw"
  | 
    ## Rotated 135 degrees clockwise.
    "se"
  | 
    ## Rotated 225 degrees clockwise.
    "sw"
mei_data.SCALEDEGREE = xsd:token { pattern = "(\^|v)?[1-7](\+|\-)?" }
mei_data.SLASH =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "6" }
mei_data.SLUR = xsd:token { pattern = "[i|m|t][1-6]" }
mei_data.STAFFITEM = mei_data.STAFFITEM.basic | mei_data.STAFFITEM.cmn
mei_data.STAFFITEM.basic =
  
  ## Accidentals.
  "accid"
  | 
    ## Annotations.
    "annot"
  | 
    ## Articulations.
    "artic"
  | 
    ## Directives.
    "dir"
  | 
    ## Dynamics.
    "dynam"
  | 
    ## Harmony indications.
    "harm"
  | 
    ## Ornaments.
    "ornam"
  | 
    ## Spoken text.
    "sp"
  | 
    ## Stage directions.
    "stageDir"
  | 
    ## Tempo markings.
    "tempo"
mei_data.STAFFLOC = xsd:integer
mei_data.STAFFREL = mei_data.STAFFREL.basic | mei_data.STAFFREL.extended
mei_data.STAFFREL.basic =
  
  ## Above the staff.
  "above"
  | 
    ## Below the staff.
    "below"
mei_data.STAFFREL.extended =
  
  ## Between staves.
  "between"
  | 
    ## Within/on the staff.
    "within"
mei_data.STEMDIRECTION =
  mei_data.STEMDIRECTION.basic | mei_data.STEMDIRECTION.extended
mei_data.STEMDIRECTION.basic =
  
  ## Stem points upwards.
  "up"
  | 
    ## Stem points downwards.
    "down"
mei_data.STEMDIRECTION.extended =
  
  ## Stem points left.
  "left"
  | 
    ## Stem points right.
    "right"
  | 
    ## Stem points up and right.
    "ne"
  | 
    ## Stem points down and right.
    "se"
  | 
    ## Stem points up and left.
    "nw"
  | 
    ## Stem points down and left.
    "sw"
mei_data.STEMMODIFIER =
  
  ## No modifications to stem.
  "none"
  | 
    ## 1 slash through stem.
    "1slash"
  | 
    ## 2 slashes through stem.
    "2slash"
  | 
    ## 3 slashes through stem.
    "3slash"
  | 
    ## 4 slashes through stem.
    "4slash"
  | 
    ## 5 slashes through stem.
    "5slash"
  | 
    ## 6 slashes through stem.
    "6slash"
  | 
    ## X placed on stem.
    "sprech"
  | 
    ## Z placed on stem.
    "z"
mei_data.STEMPOSITION =
  
  ## Stem attached to left side of note head.
  "left"
  | 
    ## Stem attached to right side of note head.
    "right"
  | 
    ## Stem is originates from center of note head.
    "center"
mei_data.STRINGNUMBER = xsd:positiveInteger
mei_data.TEMPERAMENT =
  
  ## Equal or 12-tone temperament.
  "equal"
  | 
    ## Just intonation.
    "just"
  | 
    ## Meantone intonation.
    "mean"
  | 
    ## Pythagorean tuning.
    "pythagorean"
mei_data.TEMPOVALUE = xsd:decimal
mei_data.TEXTRENDITIONLIST =
  
  ## Surrounded by single quotes.
  "quote"
  | 
    ## Surrounded by double quotes.
    "quotedbl"
  | 
    ## Italicized (slanted to right).
    "italic"
  | 
    ## Oblique (slanted to left).
    "oblique"
  | 
    ## Small capitals.
    "smcaps"
  | 
    ## Relative font weight.
    "bold"
  | 
    ## Relative font weight.
    "bolder"
  | 
    ## Relative font weight.
    "lighter"
  | 
    ## Enclosed in box.
    "box"
  | 
    ## Enclosed in ellipse/circle.
    "circle"
  | 
    ## Enclosed in diamond.
    "dbox"
  | 
    ## Enclosed in triangle.
    "tbox"
  | 
    ## Struck through by '\' (back slash).
    "bslash"
  | 
    ## Struck through by '/' (forward slash).
    "fslash"
  | 
    ## Struck through by '-'; may be qualified to indicate multiple parallel lines, e.g. line-through(2).
    "line-through"
  | 
    ## Not rendered, invisible.
    "none"
  | 
    ## Line above the text; may be qualified to indicate multiple parallel lines, e.g. overline(3).
    "overline"
  | 
    ## Use for deleted text fully or partially obscured by other text (such as 'XXXXX') or musical symbols (such as notes, rests, etc.).
    "overstrike"
  | 
    ## Struck through by '-'; equivalent to line-through; may be qualified to indicate multiple parallel lines, e.g. strike(3).
    "strike"
  | 
    ## Subscript.
    "sub"
  | 
    ## Superscript.
    "sup"
  | 
    ## Use for added text or musical symbols that fully or partially obscure text from an earlier writing stage.
    "superimpose"
  | 
    ## Underlined; may be qualified to indicate multiple parallel lines, e.g. underline(2).
    "underline"
  | 
    ## Crossed-out; equivalent to 'bslash' (\) plus 'fslash' (/); that is, a hand-written 'X'; may be qualified to indicate multiple parallel lines, e.g. x-through(2).
    "x-through"
  | 
    ## Left-to-right (BIDI embed).
    "ltr"
  | 
    ## Right-to-left (BIDI embed).
    "rtl"
  | 
    ## Left-to-right (BIDI override).
    "lro"
  | 
    ## Right-to-left (BIDI override).
    "rlo"
mei_data.TEXTRENDITIONPAR =
  xsd:string {
    pattern =
      "(underline|overline|line-through|strike|x-through)\(\d+\)"
  }
  | xsd:string {
      pattern = "(letter-spacing|line-height)\((\+|-)?\d+(\.\d+)?%?\)"
    }
mei_data.TEXTRENDITION =
  mei_data.TEXTRENDITIONLIST | mei_data.TEXTRENDITIONPAR
mei_data.TIE = xsd:token { pattern = "[i|m|t]" }
mei_data.TSTAMPOFFSET = xsd:decimal
mei_data.TUPLET = xsd:token { pattern = "[i|m|t][1-6]" }
mei_data.URI = xsd:anyURI
mei_data.VERTICALALIGNMENT =
  
  ## Top aligned.
  "top"
  | 
    ## Middle aligned.
    "middle"
  | 
    ## Bottom aligned.
    "bottom"
  | 
    ## Baseline aligned.
    "baseline"
mei_data.WORD = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})*" }
mei_data.DURATION.cmn =
  
  ## Quadruple whole note.
  "long"
  | 
    ## Double whole note.
    "breve"
  | 
    ## Whole note.
    "1"
  | 
    ## Half note.
    "2"
  | 
    ## Quarter note.
    "4"
  | 
    ## 8th note.
    "8"
  | 
    ## 16th note.
    "16"
  | 
    ## 32nd note.
    "32"
  | 
    ## 64th note.
    "64"
  | 
    ## 128th note.
    "128"
  | 
    ## 256th note.
    "256"
  | 
    ## 512th note.
    "512"
  | 
    ## 1024th note.
    "1024"
  | 
    ## 2048th note.
    "2048"
mei_data.STAFFITEM.cmn =
  
  ## Beams.
  "beam"
  | 
    ## Bend indications.
    "bend"
  | 
    ## Brackets, e.g., for transcribed ligatures.
    "bracketSpan"
  | 
    ## Breath marks.
    "breath"
  | 
    ## Copy marks.
    "cpMark"
  | 
    ## Fermatas.
    "fermata"
  | 
    ## Fingerings.
    "fing"
  | 
    ## Hairpin dynamics.
    "hairpin"
  | 
    ## Harp pedals.
    "harpPedal"
  | 
    ## Laissez vibrer indications, sometimes called "open ties".
    "lv"
  | 
    ## Mordents.
    "mordent"
  | 
    ## Octaviation marks.
    "octave"
  | 
    ## Piano pedal marks.
    "pedal"
  | 
    ## Rehearsal marks.
    "reh"
  | 
    ## Ties.
    "tie"
  | 
    ## Trills.
    "trill"
  | 
    ## Tuplets.
    "tuplet"
  | 
    ## Turns.
    "turn"
mei_data.ORNAM.cmn =
  xsd:token {
    pattern =
      "[A|a|b|I|i|K|k|M|m|N|n|S|s|T|t|O]|(A|a|S|s|K|k)?(T|t|M|m)(I|i|S|s)?"
  }
mei_data.FRBRRELATIONSHIP =
  
  ## Target is an abridgement, condensation, or expurgation of the current entity.
  "hasAbridgement"
  | 
    ## Reciprocal relationship of hasAbridgement.
    "isAbridgementOf"
  | 
    ## Target is an adaptation, paraphrase, free translation, variation (music), harmonization (music), or fantasy (music) of the current entity.
    "hasAdaptation"
  | 
    ## Reciprocal relationship of hasAdaptation.
    "isAdaptationOf"
  | 
    ## Target is an alternate format or simultaneously released edition of the current entity.
    "hasAlternate"
  | 
    ## Reciprocal relationship of hasAlternate.
    "isAlternateOf"
  | 
    ## Target is an arrangement (music) of the current entity.
    "hasArrangement"
  | 
    ## Reciprocal relationship of hasArrangement.
    "isArrangementOf"
  | 
    ## Target is a cadenza, libretto, choreography, ending for unfinished work, incidental music, or musical setting of a text of the current entity.
    "hasComplement"
  | 
    ## Reciprocal relationship of hasComplement.
    "isComplementOf"
  | 
    ## Target is a physical embodiment of the current abstract entity; describes the expression-to-manifestation relationship.
    "hasEmbodiment"
  | 
    ## Reciprocal relationship of hasEmbodiment.
    "isEmbodimentOf"
  | 
    ## Target is an exemplar of the class of things represented by the current entity; describes the manifestation-to-item relationship.
    "hasExemplar"
  | 
    ## Reciprocal relationship of hasExamplar.
    "isExemplarOf"
  | 
    ## Target is a parody, imitation, or travesty of the current entity.
    "hasImitation"
  | 
    ## Reciprocal relationship of hasImitation.
    "isImitationOf"
  | 
    ## Target is a chapter, section, part, etc.; volume of a multivolume manifestation; volume/issue of serial; intellectual part of a multi-part work; illustration for a text; sound aspect of a film; soundtrack for a film on separate medium; soundtrack for a film embedded in film; monograph in a series; physical component of a particular copy; the binding of a book of the current entity.
    "hasPart"
  | 
    ## Reciprocal relationship of hasPart.
    "isPartOf"
  | 
    ## Target is a realization of the current entity; describes the work-to-expression relationship.
    "hasRealization"
  | 
    ## Reciprocal relationship of hasRealization.
    "isRealizationOf"
  | 
    ## Target has been reconfigured: bound with, split into, extracted from the current entity.
    "hasReconfiguration"
  | 
    ## Reciprocal relationship of hasReconfiguration.
    "isReconfigurationOf"
  | 
    ## Target is a reproduction, microreproduction, macroreproduction, reprint, photo-offset reprint, or facsimile of the current entity.
    "hasReproduction"
  | 
    ## Reciprocal relationship of hasReproduction.
    "isReproductionOf"
  | 
    ## Target is a revised edition, enlarged edition, or new state (graphic) of the current entity.
    "hasRevision"
  | 
    ## Reciprocal relationship of hasRevision.
    "isRevisionOf"
  | 
    ## Target is a sequel or succeeding work of the current entity.
    "hasSuccessor"
  | 
    ## Reciprocal relationship of hasSuccessor.
    "isSuccessorOf"
  | 
    ## Target is a digest or abstract of the current entity.
    "hasSummarization"
  | 
    ## Reciprocal relationship of hasSummarization.
    "isSummarizationOf"
  | 
    ## Target is an index, concordance, teacher's guide, gloss, supplement, or appendix of the current entity.
    "hasSupplement"
  | 
    ## Reciprocal relationship of hasSupplement.
    "isSupplementOf"
  | 
    ## Target is a dramatization, novelization, versification, or screenplay of the current entity.
    "hasTransformation"
  | 
    ## Reciprocal relationship of hasTransformation.
    "isTransformationOf"
  | 
    ## Target is a literal translation or transcription (music) of the current entity.
    "hasTranslation"
  | 
    ## Reciprocal relationship of hasTranslation.
    "isTranslationOf"
mei_macro.availabilityPart =
  (mei_model.headLike*,
   (mei_accessRestrict
    | mei_distributor
    | mei_price
    | mei_sysReq
    | mei_useRestrict
    | mei_model.addressLike
    | mei_model.dateLike
    | mei_model.identifierLike)*)
  | text
mei_macro.bibldescPart =
  mei_editionStmt?,
  mei_pubStmt?,
  mei_physDesc*,
  mei_physLoc*,
  mei_seriesStmt*
mei_macro.anyXML =
  element * - (ns1:* | ns2:*) {
    attribute * { text }*,
    (text | mei_macro.anyXML)*
  }
mei_macro.metaLike.page = mei_pgHead?, mei_pgFoot?, mei_pgDesc?
mei_macro.musicPart =
  mei_model.frontLike?, (mei_body | mei_group)?, mei_model.backLike?
mei_macro.struc-unstrucContent =
  (mei_model.headLike*, mei_model.pLike*)
  | (text | mei_model.textPhraseLike.limited)*
mei_macro.titlePart =
  (mei_model.addressLike
   | mei_model.addressPart
   | mei_model.annotLike
   | mei_model.biblLike
   | mei_model.dateLike
   | mei_model.editorialLike
   | mei_model.figureLike
   | mei_model.identifierLike
   | mei_model.lbLike
   | mei_model.locrefLike
   | mei_model.measurementLike
   | mei_model.nameLike
   | mei_model.nameLike.label
   | mei_model.pbLike
   | mei_model.rendLike
   | mei_symbol)*
mei_data.BETYPE =
  
  ## Bytes.
  "byte"
  | 
    ## Synchronized Multimedia Integration Language.
    "smil"
  | 
    ## MIDI clicks.
    "midi"
  | 
    ## MIDI machine code.
    "mmc"
  | 
    ## MIDI time code.
    "mtc"
  | 
    ## SMPTE 25 EBU.
    "smpte-25"
  | 
    ## SMPTE 24 Film Sync.
    "smpte-24"
  | 
    ## SMPTE 30 Drop.
    "smpte-df30"
  | 
    ## SMPTE 30 Non-Drop.
    "smpte-ndf30"
  | 
    ## SMPTE 29.97 Drop.
    "smpte-df29.97"
  | 
    ## SMPTE 29.97 Non-Drop.
    "smpte-ndf29.97"
  | 
    ## AES Time-code character format.
    "tcf"
  | 
    ## ISO 24-hour time format: HH:MM:SS.ss.
    "time"
mei_att.notationType.attributes =
  mei_att.notationType.attribute.notationtype,
  mei_att.notationType.attribute.notationsubtype
mei_att.notationType.attribute.notationtype =
  
  ## Contains classification of the notation contained or described by the element bearing this attribute.
  attribute notationtype { mei_data.NOTATIONTYPE }?
mei_att.notationType.attribute.notationsubtype =
  
  ## Provides any sub-classification of the notation contained or described by the element, additional to that given by its notationtype attribute.
  attribute notationsubtype { xsd:NMTOKEN }?
sch:pattern [
  id =
    "mei-att.notationType-notationsubtype-When_notationsubtype-constraint-rule-5"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@notationsubtype]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@notationtype"
      "An element with a notationsubtype attribute must have\x{a}" ~
      "                a notationtype attribute."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.accid.anl.attributes = empty
mei_att.ambNote.anl.attributes = empty
mei_att.annot.anl.attributes = empty
mei_att.arpeg.anl.attributes = empty
mei_att.artic.anl.attributes = empty
mei_att.attacca.anl.attributes = empty
mei_att.barLine.anl.attributes = empty
mei_att.beam.anl.attributes = empty
mei_att.beamSpan.anl.attributes = empty
mei_att.beatRpt.anl.attributes = empty
mei_att.bend.anl.attributes = empty
mei_att.bracketSpan.anl.attributes = empty
mei_att.breath.anl.attributes = empty
mei_att.bTrem.anl.attributes = empty
mei_att.caesura.anl.attributes = empty
mei_att.chord.anl.attributes = mei_att.chord.anl.cmn.attributes
mei_att.chordDef.anl.attributes = empty
mei_att.chordMember.anl.attributes = mei_att.intervalHarmonic.attributes
mei_att.clef.anl.attributes = empty
mei_att.clefGrp.anl.attributes = empty
mei_att.cpMark.anl.attributes = empty
mei_att.curve.anl.attributes = empty
mei_att.custos.anl.attributes = empty
mei_att.mdiv.anl.attributes = empty
mei_att.dir.anl.attributes = empty
mei_att.dot.anl.attributes = empty
mei_att.dynam.anl.attributes = empty
mei_att.ending.anl.attributes = empty
mei_att.f.anl.attributes = empty
mei_att.fermata.anl.attributes = empty
mei_att.fing.anl.attributes = empty
mei_att.fingGrp.anl.attributes = empty
mei_att.fTrem.anl.attributes = empty
mei_att.gliss.anl.attributes = empty
mei_att.grpSym.anl.attributes = empty
mei_att.hairpin.anl.attributes = empty
mei_att.halfmRpt.anl.attributes = empty
mei_att.harm.anl.attributes =
  mei_att.intervalHarmonic.attributes, mei_att.harm.anl.attribute.form
mei_att.harm.anl.attribute.form =
  
  ## Indicates to what degree the harmonic label is supported by the notation.
  attribute form {
    
    ## The notation contains all the notes necessary for the harmonic label, e.g., the notes "D F A" for the harmonic label "D".
    "explicit"
    | 
      ## The harmonic label relies on notes implied, but not actually present, in the notation, e.g., the notes "D F C" for the harmonic label "D7". The note "A" is missing from the notation, but can be implied.
      "implied"
  }?
mei_att.harmonicFunction.attributes =
  mei_att.harmonicFunction.attribute.deg
mei_att.harmonicFunction.attribute.deg =
  
  ## Captures scale degree information using Humdrum **deg syntax -- an optional indicator of melodic approach (^ = ascending approach, v = descending approach), a scale degree value (1 = tonic ... 7 = leading tone), and an optional indication of chromatic alteration, "1", "v7", "^1", or "v5+", for example. The amount of chromatic alternation is not indicated.
  attribute deg { mei_data.SCALEDEGREE }?
mei_att.harpPedal.anl.attributes = empty
mei_att.instrDef.anl.attributes = empty
mei_att.intervalHarmonic.attributes =
  mei_att.intervalHarmonic.attribute.inth
mei_att.intervalHarmonic.attribute.inth =
  
  ## Encodes the harmonic interval between pitches occurring at the same time.
  attribute inth {
    list { mei_data.INTERVAL.HARMONIC+ }
  }?
mei_att.intervalMelodic.attributes =
  mei_att.intervalMelodic.attribute.intm
mei_att.intervalMelodic.attribute.intm =
  
  ## Encodes the melodic interval from the previous pitch. The value may be a general directional indication (u, d, s, etc.), an indication of diatonic interval direction, quality, and size, or a precise numeric value in half steps.
  attribute intm { mei_data.INTERVAL.MELODIC }?
mei_att.keyAccid.anl.attributes = empty
mei_att.keySig.anl.attributes =
  mei_att.accidental.attributes,
  mei_att.pitch.attributes,
  mei_att.keySig.anl.attribute.mode
mei_att.keySig.anl.attribute.mode =
  
  ## Indicates major, minor, or other tonality.
  attribute mode { mei_data.MODE }?
mei_att.keySigDefault.anl.attributes =
  mei_att.keySigDefault.anl.attribute.key.accid,
  mei_att.keySigDefault.anl.attribute.key.mode,
  mei_att.keySigDefault.anl.attribute.key.pname
mei_att.keySigDefault.anl.attribute.key.accid =
  
  ## Contains an accidental for the tonic key, if one is required, e.g., if key.pname equals 'c' and key.accid equals 's', then a tonic of C# is indicated.
  attribute key.accid { mei_data.ACCIDENTAL.GESTURAL }?
mei_att.keySigDefault.anl.attribute.key.mode =
  
  ## Indicates major, minor, or other tonality.
  attribute key.mode { mei_data.MODE }?
mei_att.keySigDefault.anl.attribute.key.pname =
  
  ## Holds the pitch name of the tonic key, e.g. 'c' for the key of C.
  attribute key.pname { mei_data.PITCHNAME }?
mei_att.layer.anl.attributes = empty
mei_att.layerDef.anl.attributes = empty
mei_att.line.anl.attributes = empty
mei_att.lv.anl.attributes = empty
mei_att.measure.anl.attributes = mei_att.joined.attributes
mei_att.melodicFunction.attributes =
  mei_att.melodicFunction.attribute.mfunc
mei_att.melodicFunction.attribute.mfunc =
  
  ## Describes melodic function using Humdrum **embel syntax.
  attribute mfunc { mei_data.MELODICFUNCTION }?
mei_att.meterSig.anl.attributes = empty
mei_att.meterSigGrp.anl.attributes = empty
mei_att.midi.anl.attributes = empty
mei_att.mordent.anl.attributes = empty
mei_att.mRest.anl.attributes = mei_att.fermataPresent.attributes
mei_att.mRpt.anl.attributes = empty
mei_att.mRpt2.anl.attributes = empty
mei_att.mSpace.anl.attributes = mei_att.fermataPresent.attributes
mei_att.multiRest.anl.attributes = empty
mei_att.multiRpt.anl.attributes = empty
mei_att.note.anl.attributes =
  mei_att.accidental.attributes,
  mei_att.articulation.attributes,
  mei_att.harmonicFunction.attributes,
  mei_att.intervalMelodic.attributes,
  mei_att.melodicFunction.attributes,
  mei_att.note.anl.cmn.attributes,
  mei_att.pitchClass.attributes,
  mei_att.solfa.attributes
mei_att.octave.anl.attributes = empty
mei_att.ornam.anl.attributes = empty
mei_att.ossia.anl.attributes = empty
mei_att.pad.anl.attributes = empty
mei_att.part.anl.attributes = empty
mei_att.parts.anl.attributes = empty
mei_att.pb.anl.attributes = empty
mei_att.pedal.anl.attributes = empty
mei_att.phrase.anl.attributes = mei_att.joined.attributes
mei_att.pitchClass.attributes = mei_att.pitchClass.attribute.pclass
mei_att.pitchClass.attribute.pclass =
  
  ## Holds pitch class information.
  attribute pclass { mei_data.PITCHCLASS }?
mei_att.rdg.anl.attributes = empty
mei_att.refrain.anl.attributes = empty
mei_att.reh.anl.attributes = empty
mei_att.rest.anl.attributes = mei_att.rest.anl.cmn.attributes
mei_att.sb.anl.attributes = empty
mei_att.score.anl.attributes = empty
mei_att.scoreDef.anl.attributes = mei_att.keySigDefault.anl.attributes
mei_att.section.anl.attributes = empty
mei_att.slur.anl.attributes = mei_att.joined.attributes
mei_att.solfa.attributes = mei_att.solfa.attribute.psolfa
mei_att.solfa.attribute.psolfa =
  
  ## Contains sol-fa designation, e.g., do, re, mi, etc., in either a fixed or movable Do system.
  attribute psolfa { xsd:NMTOKEN }?
mei_att.sp.anl.attributes = empty
mei_att.space.anl.attributes = mei_att.space.anl.cmn.attributes
mei_att.staff.anl.attributes = empty
mei_att.staffDef.anl.attributes = mei_att.keySigDefault.anl.attributes
mei_att.staffGrp.anl.attributes = empty
mei_att.stageDir.anl.attributes = empty
mei_att.syl.anl.attributes = empty
mei_att.symbol.anl.attributes = empty
mei_att.tempo.anl.attributes = empty
mei_att.tie.anl.attributes = empty
mei_att.trill.anl.attributes = empty
mei_att.tuplet.anl.attributes = empty
mei_att.tupletSpan.anl.attributes = mei_att.tuplet.anl.attributes
mei_att.turn.anl.attributes = empty
mei_att.verse.anl.attributes = empty
mei_att.volta.anl.attributes = empty
mei_att.arpeg.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startId.attributes,
  mei_att.arpeg.log.attribute.order
mei_att.arpeg.log.attribute.order =
  
  ## Describes the direction in which an arpeggio is to be performed.
  attribute order {
    
    ## Lowest to highest pitch.
    "up"
    | 
      ## Highest to lowest pitch.
      "down"
    | 
      ## Non-arpeggiated style (usually rendered with a preceding bracket instead of a wavy line).
      "nonarp"
  }?
mei_att.beam.log.attributes =
  mei_att.event.attributes, mei_att.beamedWith.attributes
mei_att.beamedWith.attributes = mei_att.beamedWith.attribute.beam.with
mei_att.beamedWith.attribute.beam.with =
  
  ## In the case of cross-staff beams, the beam.with attribute is used to indicate which staff the beam is connected to; that is, the staff above or the staff below.
  attribute beam.with { mei_data.OTHERSTAFF }?
mei_att.beaming.log.attributes =
  mei_att.beaming.log.attribute.beam.group,
  mei_att.beaming.log.attribute.beam.rests
mei_att.beaming.log.attribute.beam.group =
  
  ## Provides an example of how automated beaming (including secondary beams) is to be performed.
  attribute beam.group { xsd:string }?
mei_att.beaming.log.attribute.beam.rests =
  
  ## Indicates whether automatically-drawn beams should include rests shorter than a quarter note duration.
  attribute beam.rests { mei_data.BOOLEAN }?
mei_att.beamPresent.attributes = mei_att.beamPresent.attribute.beam
mei_att.beamPresent.attribute.beam =
  
  ## Indicates that this event is "under a beam".
  attribute beam {
    list { mei_data.BEAM+ }
  }?
mei_att.beamRend.attributes =
  mei_att.beamRend.attribute.form,
  mei_att.beamRend.attribute.place,
  mei_att.beamRend.attribute.slash,
  mei_att.beamRend.attribute.slope
mei_att.beamRend.attribute.form =
  
  ## Captures whether a beam is "feathered" and in which direction.
  attribute form {
    
    ## (accelerando) indicates that the secondary beams get progressively closer together toward the end of the beam.
    "acc"
    | 
      ## (mixed acc and rit) for beams that are "feathered" in both directions.
      "mixed"
    | 
      ## (ritardando) means that the secondary beams become progressively more distant toward the end of the beam.
      "rit"
    | 
      ## (normal) indicates that the secondary beams are equidistant along the course of the beam.
      "norm"
  }?
mei_att.beamRend.attribute.place =
  
  ## Records the placement of the beam relative to the events it affects.
  attribute place { mei_data.BEAMPLACE }?
sch:pattern [
  id = "mei-att.beamRend-place-check_beam_place-constraint-rule-6"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "mei:beam[@place eq 'mixed' and not(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ./@staff] or descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ancestor::mei:staff/@n])]"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@stem.dir]) = count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'])"
      "Stem direction must be specified for all notes and chords under the\x{a}" ~
      "                beam."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "count(distinct-values(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord']/@stem.dir)) > 1"
      'Opposing stem directions are required for a beam with @place="mixed".'
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id = "mei-att.beamRend-place-check_beam_place-constraint-rule-7"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "mei:beam[@place eq 'mixed' and (descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ./@staff] or descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@staff != ancestor::mei:staff/@n])                 and count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'][@stem.dir]) = count(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord'])]"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "count(distinct-values(descendant::mei:*[local-name() eq 'note' or local-name() eq 'chord']/@stem.dir)) > 1"
      'Opposing stem directions are required for a beam with @place="mixed".'
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.beamRend.attribute.slash =
  
  ## Indicates presence of slash through the beam.
  attribute slash { mei_data.BOOLEAN }?
mei_att.beamRend.attribute.slope =
  
  ## Records the slope of the beam.
  attribute slope { xsd:decimal }?
mei_att.beamSecondary.attributes =
  mei_att.beamSecondary.attribute.breaksec
mei_att.beamSecondary.attribute.breaksec =
  
  ## Presence of this attribute indicates that the secondary beam should be broken following this note/chord. The value of the attribute records the number of beams which should remain unbroken.
  attribute breaksec { xsd:positiveInteger }?
mei_att.beamSpan.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.beamedWith.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.beatRpt.log.attributes =
  mei_att.event.attributes, mei_att.beatRpt.log.attribute.beatdef
mei_att.beatRpt.log.attribute.beatdef =
  
  ## Indicates the performed duration represented by the beatRpt symbol; expressed in time signature denominator units.
  attribute beatdef {
    xsd:decimal { pattern = "\d+(\.\d+)?" }
  }?
mei_att.bend.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.bracketSpan.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.breath.log.attributes =
  mei_att.alignment.attributes,
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes,
  mei_att.startId.attributes,
  mei_att.timestamp.logical.attributes
mei_att.bTrem.log.attributes =
  mei_att.event.attributes,
  mei_att.augmentDots.attributes,
  mei_att.duration.logical.attributes,
  mei_att.numbered.attributes,
  mei_att.bTrem.log.attribute.form
mei_att.bTrem.log.attribute.form =
  
  ## Indicates whether the tremolo is measured or unmeasured.
  attribute form {
    
    ## Measured tremolo.
    "meas"
    | 
      ## Unmeasured tremolo.
      "unmeas"
  }?
mei_att.chord.anl.cmn.attributes =
  mei_att.beamPresent.attributes,
  mei_att.fermataPresent.attributes,
  mei_att.lvPresent.attributes,
  mei_att.ornamPresent.attributes,
  mei_att.slurPresent.attributes,
  mei_att.tiePresent.attributes,
  mei_att.tupletPresent.attributes
mei_att.chord.ges.cmn.attributes = empty
mei_att.chord.log.cmn.attributes = mei_att.graced.attributes
mei_att.chord.vis.cmn.attributes = mei_att.beamSecondary.attributes
mei_att.cutout.attributes = mei_att.cutout.attribute.cutout
mei_att.cutout.attribute.cutout =
  
  ## "Cut-out" style.
  attribute cutout {
    
    ## The staff lines should not be drawn.
    "cutout"
  }?
mei_att.mNum.anl.attributes = empty
mei_att.mNum.ges.attributes = empty
mei_att.mNum.log.attributes = empty
mei_att.mNum.vis.attributes =
  mei_att.color.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.expandable.attributes = mei_att.expandable.attribute.expand
mei_att.expandable.attribute.expand =
  
  ## Indicates whether to render a repeat symbol or the source material to which it refers. A value of 'true' renders the source material, while 'false' displays the repeat symbol.
  attribute expand { mei_data.BOOLEAN }?
mei_att.fermata.log.attributes =
  mei_att.controlEvent.attributes, mei_att.startEndId.attributes
mei_att.fTrem.log.attributes =
  mei_att.event.attributes,
  mei_att.augmentDots.attributes,
  mei_att.duration.logical.attributes,
  mei_att.fTrem.log.attribute.form
mei_att.fTrem.log.attribute.form =
  
  ## Describes the style of the tremolo.
  attribute form {
    
    ## Measured tremolo.
    "meas"
    | 
      ## Unmeasured tremolo.
      "unmeas"
  }?
mei_att.glissPresent.attributes = mei_att.glissPresent.attribute.gliss
mei_att.glissPresent.attribute.gliss =
  
  ## Indicates that this element participates in a glissando. If visual information about the glissando needs to be recorded, then a gliss element should be employed instead.
  attribute gliss { mei_data.GLISSANDO }?
mei_att.gliss.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.graced.attributes =
  mei_att.graced.attribute.grace, mei_att.graced.attribute.grace.time
mei_att.graced.attribute.grace =
  
  ## Marks a note or chord as a "grace" (without a definite performed duration) and records from which other note/chord it should "steal" time.
  attribute grace { mei_data.GRACE }?
mei_att.graced.attribute.grace.time =
  
  ## Records the amount of time to be "stolen" from a non-grace note/chord.
  attribute grace.time { mei_data.PERCENT }?
mei_att.graceGrp.anl.attributes = empty
mei_att.graceGrp.ges.attributes = empty
mei_att.graceGrp.log.attributes =
  mei_att.event.attributes,
  mei_att.graced.attributes,
  mei_att.graceGrp.log.attribute.attach
mei_att.graceGrp.log.attribute.attach =
  
  ## Records whether the grace note group is attached to the following event or to the preceding one. The usual name for the latter is "Nachschlag".
  attribute attach {
    
    ## Attached to the preceding event.
    "pre"
    | 
      ## Attached to the following event.
      "post"
    | 
      ## Attachment is ambiguous.
      "unknown"
  }?
mei_att.graceGrp.vis.attributes = mei_att.color.attributes
mei_att.hairpin.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.hairpin.log.attribute.form,
  mei_att.hairpin.log.attribute.niente
mei_att.hairpin.log.attribute.form =
  
  ## Captures the visual rendition and function of the hairpin; that is, whether it indicates an increase or a decrease in volume.
  attribute form {
    
    ## Crescendo; i.e., louder.
    "cres"
    | 
      ## Diminuendo; i.e., softer.
      "dim"
  }
mei_att.hairpin.log.attribute.niente =
  
  ## Indicates that the hairpin starts from or ends in silence. Often rendered as a small circle attached to the closed end of the hairpin. See Gould, p. 108.
  attribute niente { mei_data.BOOLEAN }?
mei_att.halfmRpt.log.attributes =
  mei_att.event.attributes, mei_att.duration.logical.attributes
mei_att.harpPedal.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.harpPedal.log.attribute.c,
  mei_att.harpPedal.log.attribute.d,
  mei_att.harpPedal.log.attribute.e,
  mei_att.harpPedal.log.attribute.f,
  mei_att.harpPedal.log.attribute.g,
  mei_att.harpPedal.log.attribute.a,
  mei_att.harpPedal.log.attribute.b
mei_att.harpPedal.log.attribute.c =
  
  ## Indicates the pedal setting for the harp's C strings.
  [ a:defaultValue = "n" ]
  attribute c {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.harpPedal.log.attribute.d =
  
  ## Indicates the pedal setting for the harp's D strings.
  [ a:defaultValue = "n" ]
  attribute d {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.harpPedal.log.attribute.e =
  
  ## Indicates the pedal setting for the harp's E strings.
  [ a:defaultValue = "n" ]
  attribute e {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.harpPedal.log.attribute.f =
  
  ## Indicates the pedal setting for the harp's F strings.
  [ a:defaultValue = "n" ]
  attribute f {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.harpPedal.log.attribute.g =
  
  ## Indicates the pedal setting for the harp's G strings.
  [ a:defaultValue = "n" ]
  attribute g {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.harpPedal.log.attribute.a =
  
  ## Indicates the pedal setting for the harp's A strings.
  [ a:defaultValue = "n" ]
  attribute a {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.harpPedal.log.attribute.b =
  
  ## Indicates the pedal setting for the harp's B strings.
  [ a:defaultValue = "n" ]
  attribute b {
    
    ## Flat.
    "f"
    | 
      ## Natural.
      "n"
    | 
      ## Sharp.
      "s"
  }?
mei_att.layerDef.log.cmn.attributes = mei_att.beaming.log.attributes
mei_att.lv.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.lvPresent.attributes = mei_att.lvPresent.attribute.lv
mei_att.lvPresent.attribute.lv =
  
  ## Indicates the attachment of an l.v. (laissez vibrer) sign to this element.
  attribute lv { mei_data.BOOLEAN }?
mei_att.measure.log.attributes =
  mei_att.alignment.attributes,
  mei_att.meterConformance.bar.attributes,
  mei_att.measure.log.attribute.left,
  mei_att.measure.log.attribute.right
mei_att.measure.log.attribute.left =
  
  ## Indicates the visual rendition of the left bar line. It is present here only for facilitation of translation from legacy encodings which use it. Usually, it can be safely ignored.
  attribute left { mei_data.BARRENDITION }?
mei_att.measure.log.attribute.right =
  
  ## Indicates the function of the right bar line and is structurally important.
  attribute right { mei_data.BARRENDITION }?
mei_att.meterSigGrp.log.attributes =
  mei_att.meterSigGrp.log.attribute.func
mei_att.meterSigGrp.log.attribute.func =
  
  ## Function of the meter signature group.
  attribute func {
    
    ## Meter signatures apply to alternating measures.
    "alternating"
    | 
      ## Meter signatures are interchangeable, e.g. 3/4 and 6/8.
      "interchanging"
    | 
      ## Meter signatures with different unit values are used to express a complex metrical pattern that is not expressible using traditional means, such as 2/4+1/8.
      "mixed"
  }
mei_att.mRest.log.attributes =
  mei_att.cue.attributes,
  mei_att.duration.additive.attributes,
  mei_att.event.attributes
mei_att.mRpt.log.attributes = mei_att.event.attributes
mei_att.mRpt2.log.attributes = mei_att.event.attributes
mei_att.mSpace.log.attributes =
  mei_att.duration.additive.attributes, mei_att.event.attributes
mei_att.multiRest.log.attributes =
  mei_att.event.attributes, mei_att.numbered.attributes
mei_att.multiRpt.log.attributes =
  mei_att.event.attributes, mei_att.numbered.attributes
mei_att.note.anl.cmn.attributes =
  mei_att.beamPresent.attributes,
  mei_att.fermataPresent.attributes,
  mei_att.glissPresent.attributes,
  mei_att.lvPresent.attributes,
  mei_att.ornamPresent.attributes,
  mei_att.slurPresent.attributes,
  mei_att.sylText.attributes,
  mei_att.tiePresent.attributes,
  mei_att.tupletPresent.attributes
mei_att.note.log.cmn.attributes = mei_att.graced.attributes
mei_att.note.vis.cmn.attributes = mei_att.beamSecondary.attributes
mei_att.numbered.attributes = mei_att.numbered.attribute.num
mei_att.numbered.attribute.num =
  
  ## Records a number or count accompanying a notational feature.
  attribute num { xsd:positiveInteger }?
mei_att.numberPlacement.attributes =
  mei_att.numberPlacement.attribute.num.place,
  mei_att.numberPlacement.attribute.num.visible
mei_att.numberPlacement.attribute.num.place =
  
  ## States where the tuplet number will be placed in relation to the note heads.
  attribute num.place { mei_data.STAFFREL.basic }?
mei_att.numberPlacement.attribute.num.visible =
  
  ## Determines if the tuplet number is visible.
  attribute num.visible { mei_data.BOOLEAN }?
mei_att.octave.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.octaveDisplacement.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.octave.log.attribute.coll
mei_att.octave.log.attribute.coll =
  
  ## Indicates whether the octave displacement should be performed simultaneously with the written notes, i.e., "coll' ottava". Unlike other octave signs which are indicated by broken lines, coll' ottava typically uses an unbroken line or a series of longer broken lines, ending with a short vertical stroke. See Read, p. 47-48.
  attribute coll {
    
    ## Coll' ottava (with the octave).
    "coll"
  }?
mei_att.ossia.log.attributes = empty
mei_att.pedal.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.pedal.log.attribute.dir,
  mei_att.pedal.log.attribute.func
mei_att.pedal.log.attribute.dir =
  
  ## Records the position of the piano damper pedal.
  attribute dir {
    
    ## Depress the pedal.
    "down"
    | 
      ## Release the pedal.
      "up"
    | 
      ## Half pedal.
      "half"
    | 
      ## Release then immediately depress the pedal.
      "bounce"
  }
mei_att.pedal.log.attribute.func =
  
  ## Indicates the function of the depressed pedal, but not necessarily the text associated with its use. Use the dir element for such text.
  ## Suggested values include: 1] sustain; 2] soft; 3] sostenuto; 4] silent
  attribute func {
    
    ## The sustain pedal, also referred to as the "damper" pedal, allows the piano strings to vibrate sympathetically with the struck strings. It is the right-most and the most frequently used pedal on modern pianos.
    "sustain"
    | 
      ## The soft pedal, sometimes called the "una corda", "piano", or "half-blow" pedal, reduces the volume and modifies the timbre of the piano. On the modern piano, it is the left-most pedal.
      "soft"
    | 
      ## The sostenuto or tone-sustaining pedal allows notes already undamped to continue to ring while other notes are damped normally; that is, on their release by the fingers. This is usually the center pedal of the modern piano.
      "sostenuto"
    | 
      ## The silent or practice pedal mutes the volume of the piano so that one may practice quietly. It is sometimes a replacement for the sostenuto pedal, especially on an upright or vertical instrument.
      "silent"
    | xsd:NMTOKEN
  }?
mei_att.phrase.vis.cmn.attributes =
  mei_att.curvature.attributes, mei_att.curveRend.attributes
mei_att.pianoPedals.attributes =
  mei_att.pianoPedals.attribute.pedal.style
mei_att.pianoPedals.attribute.pedal.style =
  
  ## Determines whether piano pedal marks should be rendered as lines or as terms.
  attribute pedal.style {
    
    ## Continuous line with start and end positions rendered by vertical bars and bounces shown by upward-pointing "blips".
    "line"
    | 
      ## Pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered with "* Ped.".
      "pedstar"
    | 
      ## Pedal up and down indications same as with "pedstar", but bounce is rendered with "Ped." only.
      "altpedstar"
  }?
mei_att.reh.log.attributes =
  mei_att.alignment.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes,
  mei_att.startId.attributes,
  mei_att.timestamp.logical.attributes,
  mei_att.timestamp.gestural.attributes
mei_att.rehearsal.attributes = mei_att.rehearsal.attribute.reh.enclose
mei_att.rehearsal.attribute.reh.enclose =
  
  ## Describes the enclosing shape for rehearsal marks.
  attribute reh.enclose {
    
    ## Enclosed by box.
    "box"
    | 
      ## Enclosed by circle.
      "circle"
    | 
      ## No enclosing shape.
      "none"
  }?
mei_att.rest.anl.cmn.attributes =
  mei_att.beamPresent.attributes,
  mei_att.fermataPresent.attributes,
  mei_att.tupletPresent.attributes
mei_att.rest.log.cmn.attributes = empty
mei_att.rest.vis.cmn.attributes = mei_att.beamSecondary.attributes
mei_att.scoreDef.log.cmn.attributes = mei_att.beaming.log.attributes
mei_att.scoreDef.vis.cmn.attributes =
  mei_att.beaming.vis.attributes,
  mei_att.pianoPedals.attributes,
  mei_att.rehearsal.attributes,
  mei_att.slurRend.attributes,
  mei_att.tieRend.attributes,
  mei_att.scoreDef.vis.cmn.attribute.grid.show
mei_att.scoreDef.vis.cmn.attribute.grid.show =
  
  ## Determines whether to display guitar chord grids.
  attribute grid.show { mei_data.BOOLEAN }?
mei_att.slur.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.slurRend.attributes =
  mei_att.slurRend.attribute.slur.lform,
  mei_att.slurRend.attribute.slur.lwidth
mei_att.slurRend.attribute.slur.lform =
  
  ##
  attribute slur.lform { mei_data.LINEFORM }?
mei_att.slurRend.attribute.slur.lwidth =
  
  ##
  attribute slur.lwidth { mei_data.LINEWIDTH }?
mei_att.space.anl.cmn.attributes =
  mei_att.beamPresent.attributes,
  mei_att.fermataPresent.attributes,
  mei_att.tupletPresent.attributes
mei_att.staffDef.log.cmn.attributes = mei_att.beaming.log.attributes
mei_att.staffDef.vis.cmn.attributes =
  mei_att.beaming.vis.attributes,
  mei_att.pianoPedals.attributes,
  mei_att.rehearsal.attributes,
  mei_att.slurRend.attributes,
  mei_att.tieRend.attributes
mei_att.stems.cmn.attributes = mei_att.stems.cmn.attribute.stem.with
mei_att.stems.cmn.attribute.stem.with =
  
  ## Contains an indication of which staff a note or chord that logically belongs to the current staff should be visually placed on; that is, the one above or the one below.
  attribute stem.with { mei_data.OTHERSTAFF }?
mei_att.tie.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.tieRend.attributes =
  mei_att.tieRend.attribute.tie.lform,
  mei_att.tieRend.attribute.tie.lwidth
mei_att.tieRend.attribute.tie.lform =
  
  ##
  attribute tie.lform { mei_data.LINEFORM }?
mei_att.tieRend.attribute.tie.lwidth =
  
  ##
  attribute tie.lwidth { mei_data.LINEWIDTH }?
mei_att.tremMeasured.attributes = mei_att.tremMeasured.attribute.unitdur
mei_att.tremMeasured.attribute.unitdur =
  
  ## The performed duration of an individual note in a measured tremolo.
  attribute unitdur { mei_data.DURATION.cmn }?
mei_att.tuplet.log.attributes =
  mei_att.beamedWith.attributes,
  mei_att.duration.additive.attributes,
  mei_att.duration.ratio.attributes,
  mei_att.event.attributes,
  mei_att.startEndId.attributes
mei_att.tupletSpan.log.attributes =
  mei_att.beamedWith.attributes,
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.duration.ratio.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_model.controlEventLike.cmn =
  mei_arpeg
  | mei_attacca
  | mei_beamSpan
  | mei_bracketSpan
  | mei_breath
  | mei_fermata
  | mei_hairpin
  | mei_harpPedal
  | mei_lv
  | mei_octave
  | mei_pedal
  | mei_reh
  | mei_slur
  | mei_tie
  | mei_tupletSpan
  | mei_model.ornamentLike.cmn
mei_model.controlEventLike.cmn_alternation =
  mei_arpeg
  | mei_attacca
  | mei_beamSpan
  | mei_bracketSpan
  | mei_breath
  | mei_fermata
  | mei_hairpin
  | mei_harpPedal
  | mei_lv
  | mei_octave
  | mei_pedal
  | mei_reh
  | mei_slur
  | mei_tie
  | mei_tupletSpan
  | mei_model.ornamentLike.cmn_alternation
mei_model.controlEventLike.cmn_sequence =
  mei_arpeg,
  mei_attacca,
  mei_beamSpan,
  mei_bracketSpan,
  mei_breath,
  mei_fermata,
  mei_hairpin,
  mei_harpPedal,
  mei_lv,
  mei_octave,
  mei_pedal,
  mei_reh,
  mei_slur,
  mei_tie,
  mei_tupletSpan,
  mei_model.ornamentLike.cmn_sequence
mei_model.controlEventLike.cmn_sequenceOptional =
  mei_arpeg?,
  mei_attacca?,
  mei_beamSpan?,
  mei_bracketSpan?,
  mei_breath?,
  mei_fermata?,
  mei_hairpin?,
  mei_harpPedal?,
  mei_lv?,
  mei_octave?,
  mei_pedal?,
  mei_reh?,
  mei_slur?,
  mei_tie?,
  mei_tupletSpan?,
  mei_model.ornamentLike.cmn_sequenceOptional?
mei_model.controlEventLike.cmn_sequenceOptionalRepeatable =
  mei_arpeg*,
  mei_attacca*,
  mei_beamSpan*,
  mei_bracketSpan*,
  mei_breath*,
  mei_fermata*,
  mei_hairpin*,
  mei_harpPedal*,
  mei_lv*,
  mei_octave*,
  mei_pedal*,
  mei_reh*,
  mei_slur*,
  mei_tie*,
  mei_tupletSpan*,
  mei_model.ornamentLike.cmn_sequenceOptionalRepeatable*
mei_model.controlEventLike.cmn_sequenceRepeatable =
  mei_arpeg+,
  mei_attacca+,
  mei_beamSpan+,
  mei_bracketSpan+,
  mei_breath+,
  mei_fermata+,
  mei_hairpin+,
  mei_harpPedal+,
  mei_lv+,
  mei_octave+,
  mei_pedal+,
  mei_reh+,
  mei_slur+,
  mei_tie+,
  mei_tupletSpan+,
  mei_model.ornamentLike.cmn_sequenceRepeatable+
mei_model.eventLike.cmn =
  mei_beam
  | mei_beatRpt
  | mei_bTrem
  | mei_fTrem
  | mei_graceGrp
  | mei_halfmRpt
  | mei_tuplet
mei_model.eventLike.cmn_alternation =
  mei_beam
  | mei_beatRpt
  | mei_bTrem
  | mei_fTrem
  | mei_graceGrp
  | mei_halfmRpt
  | mei_tuplet
mei_model.eventLike.cmn_sequence =
  mei_beam,
  mei_beatRpt,
  mei_bTrem,
  mei_fTrem,
  mei_graceGrp,
  mei_halfmRpt,
  mei_tuplet
mei_model.eventLike.cmn_sequenceOptional =
  mei_beam?,
  mei_beatRpt?,
  mei_bTrem?,
  mei_fTrem?,
  mei_graceGrp?,
  mei_halfmRpt?,
  mei_tuplet?
mei_model.eventLike.cmn_sequenceOptionalRepeatable =
  mei_beam*,
  mei_beatRpt*,
  mei_bTrem*,
  mei_fTrem*,
  mei_graceGrp*,
  mei_halfmRpt*,
  mei_tuplet*
mei_model.eventLike.cmn_sequenceRepeatable =
  mei_beam+,
  mei_beatRpt+,
  mei_bTrem+,
  mei_fTrem+,
  mei_graceGrp+,
  mei_halfmRpt+,
  mei_tuplet+
mei_model.eventLike.measureFilling =
  mei_mRest
  | mei_mRpt
  | mei_mRpt2
  | mei_mSpace
  | mei_multiRest
  | mei_multiRpt
mei_model.eventLike.measureFilling_alternation =
  mei_mRest
  | mei_mRpt
  | mei_mRpt2
  | mei_mSpace
  | mei_multiRest
  | mei_multiRpt
mei_model.eventLike.measureFilling_sequence =
  mei_mRest,
  mei_mRpt,
  mei_mRpt2,
  mei_mSpace,
  mei_multiRest,
  mei_multiRpt
mei_model.eventLike.measureFilling_sequenceOptional =
  mei_mRest?,
  mei_mRpt?,
  mei_mRpt2?,
  mei_mSpace?,
  mei_multiRest?,
  mei_multiRpt?
mei_model.eventLike.measureFilling_sequenceOptionalRepeatable =
  mei_mRest*,
  mei_mRpt*,
  mei_mRpt2*,
  mei_mSpace*,
  mei_multiRest*,
  mei_multiRpt*
mei_model.eventLike.measureFilling_sequenceRepeatable =
  mei_mRest+,
  mei_mRpt+,
  mei_mRpt2+,
  mei_mSpace+,
  mei_multiRest+,
  mei_multiRpt+
mei_model.layerPart.cmn =
  mei_model.eventLike.cmn | mei_model.eventLike.measureFilling
mei_model.measureLike = mei_measure
mei_model.measureLike_alternation = mei_measure
mei_model.measureLike_sequence = mei_measure
mei_model.measureLike_sequenceOptional = mei_measure?
mei_model.measureLike_sequenceOptionalRepeatable = mei_measure*
mei_model.measureLike_sequenceRepeatable = mei_measure+
mei_model.measurePart =
  mei_model.controlEventLike.cmn
  | mei_model.ossiaLike
  | mei_model.midiLike
  | mei_model.controlEventLike
  | mei_model.staffLike
mei_model.ossiaLike = mei_ossia
mei_model.sectionPart.cmn = mei_model.measureLike
mei_arpeg =
  
  ## (arpeggiation)  Indicates that the notes of a chord are to be performed successively rather than simultaneously, usually from lowest to highest. Sometimes called a "roll".
  element arpeg {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.arpeg.log.attributes,
    mei_att.arpeg.vis.attributes,
    mei_att.arpeg.ges.attributes,
    mei_att.arpeg.anl.attributes,
    empty
  }
mei_attacca =
  
  ## An instruction to begin the next section or movement of a composition without pause.
  element attacca {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.graphicPrimitiveLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-attacca-attacca_start-type_attributes_required-constraint-rule-8"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:attacca[not(ancestor::mei:syllable)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.attacca.log.attributes,
    mei_att.attacca.vis.attributes,
    mei_att.attacca.ges.attributes,
    mei_att.attacca.anl.attributes,
    empty
  }
mei_beam =
  
  ## A container for a series of explicitly beamed events that begins and ends entirely within a measure.
  element beam {
    ((mei_model.eventLike
      | mei_model.eventLike.cmn
      | mei_model.appLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-beam-When_not_copyof_beam_content-constraint-rule-9"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:beam[not(@copyof)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) > 1"
             "A beam without a copyof attribute must have at least 2 note, rest, chord, or space\x{a}" ~
             "            descendants."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.beam.log.attributes,
    mei_att.beam.vis.attributes,
    mei_att.beam.ges.attributes,
    mei_att.beam.anl.attributes,
    empty
  }
mei_beamSpan =
  
  ## (beam span)  Alternative element for explicitly encoding beams, particularly those which extend across bar lines.
  element beamSpan {
    empty
    >> sch:pattern [
         id =
           "mei-beamSpan-beamspan_start-_and_end-type_attributes_required-constraint-rule-10"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:beamSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.beamSpan.log.attributes,
    mei_att.beamSpan.vis.attributes,
    mei_att.beamSpan.ges.attributes,
    mei_att.beamSpan.anl.attributes,
    empty
  }
mei_beatRpt =
  
  ## (beat repeat)  An indication that material on a preceding beat should be repeated.
  element beatRpt {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.beatRpt.log.attributes,
    mei_att.beatRpt.vis.attributes,
    mei_att.beatRpt.ges.attributes,
    mei_att.beatRpt.anl.attributes,
    mei_att.plist.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_bend =
  
  ## A variation in pitch (often micro-tonal) upwards or downwards during the course of a note.
  element bend {
    empty
    >> sch:pattern [
         id =
           "mei-bend-bend_start-_and_end-type_attributes_required-constraint-rule-11"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:bend"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.bend.log.attributes,
    mei_att.bend.vis.attributes,
    mei_att.bend.ges.attributes,
    mei_att.bend.anl.attributes,
    empty
  }
mei_bracketSpan =
  
  ## Marks a sequence of notational events grouped by a bracket.
  element bracketSpan {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "mei-bracketSpan-bracketSpan_start-_and_end-type_attributes_required-constraint-rule-12"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:bracketSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bracketSpan.log.attributes,
    mei_att.bracketSpan.vis.attributes,
    mei_att.bracketSpan.ges.attributes,
    mei_att.bracketSpan.anl.attributes,
    mei_att.facsimile.attributes,
    
    ## Describes the function of the bracketed event sequence.
    ## Suggested values include: 1] coloration; 2] cross-rhythm; 3] ligature
    attribute func {
      
      ## Represents coloration in the mensural notation source material.
      "coloration"
      | 
        ## Marks a sequence which does not match the current meter.
        "cross-rhythm"
      | 
        ## Represents a ligature in the mensural notation source material.
        "ligature"
      | xsd:NMTOKENS
    },
    empty
  }
mei_breath =
  
  ## (breath mark)  An indication of a point at which the performer on an instrument requiring breath (including the voice) may breathe.
  element breath {
    empty
    >> sch:pattern [
         id =
           "mei-breath-breath_start-type_attributes_required-constraint-rule-13"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:breath"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.breath.log.attributes,
    mei_att.breath.vis.attributes,
    mei_att.breath.ges.attributes,
    mei_att.breath.anl.attributes,
    empty
  }
mei_bTrem =
  
  ## (bowed tremolo)  A rapid alternation on a single pitch or chord.
  element bTrem {
    (mei_chord | mei_note),
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.bTrem.log.attributes,
    mei_att.bTrem.vis.attributes,
    mei_att.bTrem.ges.attributes,
    mei_att.bTrem.anl.attributes,
    empty
  }
mei_fermata =
  
  ## An indication placed over a note or rest to indicate that it should be held longer than its written value. May also occur over a bar line to indicate the end of a phrase or section. Sometimes called a 'hold' or 'pause'.
  element fermata {
    empty
    >> sch:pattern [
         id =
           "mei-fermata-fermata_start-type_attributes_required-constraint-rule-14"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:fermata"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.fermata.log.attributes,
    mei_att.fermata.vis.attributes,
    mei_att.fermata.ges.attributes,
    mei_att.fermata.anl.attributes,
    empty
  }
mei_fTrem =
  
  ## (fingered tremolo)  A rapid alternation between a pair of notes (or chords or perhaps between a note and a chord) that are (usually) farther apart than a major second.
  element fTrem {
    ((mei_chord, (mei_chord | mei_note))
     | (mei_note, (mei_chord | mei_note))),
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.fTrem.log.attributes,
    mei_att.fTrem.vis.attributes,
    mei_att.fTrem.ges.attributes,
    mei_att.fTrem.anl.attributes,
    empty
  }
mei_gliss =
  
  ## (glissando)  A continuous or sliding movement from one pitch to another, usually indicated by a straight or wavy line.
  element gliss {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "mei-gliss-gliss_start-_and_end-type_attributes_required-constraint-rule-15"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:gliss"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.gliss.log.attributes,
    mei_att.gliss.vis.attributes,
    mei_att.gliss.ges.attributes,
    mei_att.gliss.anl.attributes,
    empty
  }
mei_graceGrp =
  
  ## A container for a sequence of grace notes.
  element graceGrp {
    ((mei_model.eventLike
      | mei_model.eventLike.cmn
      | mei_model.appLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-graceGrp-When_not_copyof_graceGrp_content-constraint-rule-16"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:graceGrp[not(@copyof)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord' or local-name()='space']) > 1"
             "A graceGrp without a copyof attribute must have at least 2 note, rest, chord, or space\x{a}" ~
             "            descendants."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-graceGrp-When_graced-constraint-rule-17"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:graceGrp[@grace]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(descendant::mei:*[@grace])"
             "The grace attribute is not allowed on\x{a}" ~
             "            descendants of a graceGrp with a grace attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.graceGrp.log.attributes,
    mei_att.graceGrp.vis.attributes,
    mei_att.graceGrp.ges.attributes,
    mei_att.graceGrp.anl.attributes,
    empty
  }
mei_hairpin =
  
  ## Indicates continuous dynamics expressed on the score as wedge-shaped graphics, e.g. < and >.
  element hairpin {
    empty
    >> sch:pattern [
         id =
           "mei-hairpin-hairpin_start-_and_end-type_attributes_required-constraint-rule-18"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:hairpin"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.hairpin.log.attributes,
    mei_att.hairpin.vis.attributes,
    mei_att.hairpin.ges.attributes,
    mei_att.hairpin.anl.attributes,
    empty
  }
mei_halfmRpt =
  
  ## (half-measure repeat)  A half-measure repeat in any meter.
  element halfmRpt {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.halfmRpt.log.attributes,
    mei_att.halfmRpt.vis.attributes,
    mei_att.halfmRpt.ges.attributes,
    mei_att.halfmRpt.anl.attributes,
    empty
  }
mei_harpPedal =
  
  ## (harp pedal)  Harp pedal diagram.
  element harpPedal {
    empty
    >> sch:pattern [
         id =
           "mei-harpPedal-harpPedal_start-type_attributes_required-constraint-rule-19"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:harpPedal"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.harpPedal.log.attributes,
    mei_att.harpPedal.vis.attributes,
    mei_att.harpPedal.ges.attributes,
    mei_att.harpPedal.anl.attributes,
    empty
  }
mei_lv =
  
  ## A "tie-like" indication that a note should ring beyond its written duration.
  element lv {
    (mei_curve*)
    >> sch:pattern [
         id =
           "mei-lv-lv_start-_and_end-type_attributes_required-constraint-rule-20"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:lv"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-lv-lv_containing_curve-constraint-rule-21"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:lv[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or              @endvo or @x or @y or @x2 or @y2]]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
             role = "warning"
             "The visual attributes of the lv element (@bezier, @bulge, @curvedir,\x{a}" ~
             "            @lform, @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo,\x{a}" ~
             "            @x, @y, @x2, and @y2) will be overridden by visual attributes of the contained curve\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lv.log.attributes,
    mei_att.lv.vis.attributes,
    mei_att.lv.ges.attributes,
    mei_att.lv.anl.attributes,
    empty
  }
mei_measure =
  
  ## Unit of musical time consisting of a fixed number of note values of a given type, as determined by the prevailing meter, and delimited in musical notation by bar lines.
  element measure {
    mei_mNum?,
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.measurePart
     | mei_model.milestoneLike.music
     | mei_model.relationLike
     | mei_model.staffDefLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.measure.anl.attributes,
    mei_att.measure.ges.attributes,
    mei_att.measure.log.attributes,
    mei_att.measure.vis.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_meterSig =
  
  ## (meter signature)  Written meter signature.
  element meterSig {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.meterSig.anl.attributes,
    mei_att.meterSig.ges.attributes,
    mei_att.meterSig.log.attributes,
    mei_att.meterSig.vis.attributes,
    empty
  }
mei_meterSigGrp =
  
  ## (meter signature group)  Used to capture alternating, interchanging, and mixed meter signatures.
  element meterSigGrp {
    (mei_meterSig*)
    >> sch:pattern [
         id =
           "mei-meterSigGrp-check_meterSigGrpContent-constraint-rule-22"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meterSigGrp[not(@copyof)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:meterSig) > 1"
             "meterSigGrp must have at least 2 child\x{a}" ~
             "            meterSig elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.meterSigGrp.anl.attributes,
    mei_att.meterSigGrp.ges.attributes,
    mei_att.meterSigGrp.log.attributes,
    mei_att.meterSigGrp.vis.attributes,
    empty
  }
mei_mNum =
  
  ## (measure number)  Designation, name, or label for a measure, often but not always consisting of digits. Use this element when the n attribute on measure does not adequately capture the appearance or placement of the measure number/label.
  element mNum {
    (text | mei_model.lbLike | mei_model.rendLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.mNum.log.attributes,
    mei_att.mNum.vis.attributes,
    mei_att.mNum.ges.attributes,
    mei_att.mNum.anl.attributes,
    empty
  }
mei_mRest =
  
  ## (measure rest)  Complete measure rest in any meter. 
  element mRest {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.mRest.log.attributes,
    mei_att.mRest.vis.attributes,
    mei_att.mRest.ges.attributes,
    mei_att.mRest.anl.attributes,
    empty
  }
mei_mRpt =
  
  ## (measure repeat)  An indication that the previous measure should be repeated.
  element mRpt {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.mRpt.log.attributes,
    mei_att.mRpt.vis.attributes,
    mei_att.mRpt.ges.attributes,
    mei_att.mRpt.anl.attributes,
    empty
  }
mei_mRpt2 =
  
  ## (2-measure repeat)  An indication that the previous two measures should be repeated.
  element mRpt2 {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.mRpt2.log.attributes,
    mei_att.mRpt2.vis.attributes,
    mei_att.mRpt2.ges.attributes,
    mei_att.mRpt2.anl.attributes,
    empty
  }
mei_mSpace =
  
  ## (measure space)  A measure containing only empty space in any meter.
  element mSpace {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.mSpace.log.attributes,
    mei_att.mSpace.vis.attributes,
    mei_att.mSpace.ges.attributes,
    mei_att.mSpace.anl.attributes,
    empty
  }
mei_multiRest =
  
  ## (multiple rest)  Multiple measures of rest compressed into a single symbol, frequently found in performer parts.
  element multiRest {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.multiRest.log.attributes,
    mei_att.multiRest.vis.attributes,
    mei_att.multiRest.ges.attributes,
    mei_att.multiRest.anl.attributes,
    empty
  }
mei_multiRpt =
  
  ## (multiple repeat)  Multiple repeated measures.
  element multiRpt {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.multiRpt.log.attributes,
    mei_att.multiRpt.vis.attributes,
    mei_att.multiRpt.ges.attributes,
    mei_att.multiRpt.anl.attributes,
    empty
  }
mei_octave =
  
  ## An indication that a passage should be performed one or more octaves above or below its written pitch.
  element octave {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "mei-octave-octave_start-_and_end-type_attributes_required-constraint-rule-23"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:octave"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.octave.log.attributes,
    mei_att.octave.vis.attributes,
    mei_att.octave.ges.attributes,
    mei_att.octave.anl.attributes,
    empty
  }
mei_oLayer =
  
  ## (ossia layer)  A layer that contains an alternative to material in another layer.
  element oLayer {
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.transcriptionLike)*,
    mei_att.basic.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    mei_att.typed.attributes,
    mei_att.layer.log.attributes,
    mei_att.layer.vis.attributes,
    mei_att.layer.ges.attributes,
    mei_att.layer.anl.attributes,
    empty
  }
mei_ossia =
  
  ## Captures original notation and a differently notated version *present in the source being transcribed*.
  element ossia {
    ((mei_oStaff+, mei_model.staffLike+)
     | (mei_oLayer+, mei_model.layerLike+))
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:measure/mei:ossia"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:*) = count(mei:staff)+count(mei:oStaff)"
             "In a measure, ossia\x{a}" ~
             "              may only contain staff and oStaff elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staff/mei:ossia"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:*) = count(mei:layer)+count(mei:oLayer)"
             "In a staff, ossia\x{a}" ~
             "              may only contain layer and oLayer elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.ossia.log.attributes,
    mei_att.ossia.vis.attributes,
    mei_att.ossia.ges.attributes,
    mei_att.ossia.anl.attributes,
    empty
  }
mei_oStaff =
  
  ## (ossia staff)  A staff that holds an alternative passage which may be played instead of the original material.
  element oStaff {
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.milestoneLike.music
     | mei_model.relationLike
     | mei_model.staffDefLike
     | mei_model.staffPart
     | mei_model.transcriptionLike)*,
    mei_att.basic.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    mei_att.typed.attributes,
    mei_att.staff.log.attributes,
    mei_att.staff.vis.attributes,
    mei_att.staff.ges.attributes,
    mei_att.staff.anl.attributes,
    empty
  }
mei_pedal =
  
  ## Piano pedal mark.
  element pedal {
    empty
    >> sch:pattern [
         id =
           "mei-pedal-pedal_start-type_attributes_required-constraint-rule-26"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:pedal"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.pedal.log.attributes,
    mei_att.pedal.vis.attributes,
    mei_att.pedal.ges.attributes,
    mei_att.pedal.anl.attributes,
    empty
  }
mei_reh =
  
  ## (rehearsal mark)  In an orchestral score and its corresponding parts, a mark indicating a convenient point from which to resume rehearsal after a break.
  element reh {
    (text | mei_model.lbLike | mei_model.rendLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.reh.log.attributes,
    mei_att.reh.vis.attributes,
    mei_att.reh.ges.attributes,
    mei_att.reh.anl.attributes,
    empty
  }
mei_slur =
  
  ## Indication of 1) a "unified melodic idea" or 2) performance technique.
  element slur {
    (mei_curve*)
    >> sch:pattern [
         id =
           "mei-slur-slur_start-_and_end-type_attributes_required-constraint-rule-27"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:slur"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-slur-slur_containing_curve-constraint-rule-28"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:slur[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or              @x or @y or @x2 or @y2]]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
             role = "warning"
             "The visual attributes of the slur (@bezier, @bulge, @curvedir, @lform,\x{a}" ~
             "            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,\x{a}" ~
             "            @x2, and @y2) will be overridden by visual attributes of the contained curve\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.slur.log.attributes,
    mei_att.slur.vis.attributes,
    mei_att.slur.ges.attributes,
    mei_att.slur.anl.attributes,
    empty
  }
mei_tie =
  
  ## An indication that two notes of the same pitch form a single note with their combined rhythmic values.
  element tie {
    (mei_curve*)
    >> sch:pattern [
         id =
           "mei-tie-tie_start-_and_end-type_attributes_required-constraint-rule-29"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:tie"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-tie-tie_containing_curve-constraint-rule-30"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:tie[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or              @ho or @startho or @endho or @to or @startto or @endto or @vo or @startvo or              @endvo or @x or @y or @x2 or @y2]]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or                @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
             role = "warning"
             "The visual attributes of the tie (@bezier, @bulge, @curvedir, @lform,\x{a}" ~
             "            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,\x{a}" ~
             "            @x2, and @y2) will be overridden by visual attributes of the contained curve\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.tie.log.attributes,
    mei_att.tie.vis.attributes,
    mei_att.tie.ges.attributes,
    mei_att.tie.anl.attributes,
    empty
  }
mei_tuplet =
  
  ## A group of notes with "irregular" (sometimes called "irrational") rhythmic values, for example, three notes in the time normally occupied by two or nine in the time of five.
  element tuplet {
    ((mei_model.appLike
      | mei_model.editLike
      | mei_model.eventLike
      | mei_model.eventLike.cmn
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-tuplet-When_not_copyof_tuplet_content-constraint-rule-31"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:tuplet[not(@copyof)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::*[local-name()='note' or local-name()='rest' or               local-name()='chord']) > 1"
             "A tuplet without a copyof attribute must have at least 2 note, rest, or chord\x{a}" ~
             "            descendants."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.tuplet.log.attributes,
    mei_att.tuplet.vis.attributes,
    mei_att.tuplet.ges.attributes,
    mei_att.tuplet.anl.attributes,
    empty
  }
mei_tupletSpan =
  
  ## (tuplet span)  Alternative element for encoding tuplets, especially useful for tuplets that extend across bar lines.
  element tupletSpan {
    empty
    >> sch:pattern [
         id =
           "mei-tupletSpan-tupletSpan_start-_and_end-type_attributes_required-constraint-rule-32"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:tupletSpan"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.tupletSpan.log.attributes,
    mei_att.tupletSpan.vis.attributes,
    mei_att.tupletSpan.ges.attributes,
    mei_att.tupletSpan.anl.attributes,
    empty
  }
mei_att.mordent.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.ornamentAccid.attributes,
  mei_att.mordent.log.attribute.form,
  mei_att.mordent.log.attribute.long
mei_att.mordent.log.attribute.form =
  
  ## Records semantic meaning, i.e., intended performance, of the mordent. The altsym, glyph.name, or glyph.num attributes may be used to specify the appropriate symbol.
  attribute form {
    
    ## Starts with the written note, followed by its lower neighbor, with a return to the written note. In modern practice, this is called an "inverted mordent" and indicated by a short wavy line with a vertical line through it.
    "lower"
    | 
      ## Starts with the written note, followed by its upper neighbor, with a return to the principal note. In modern practice, the symbol lacks the vertical line used for the inverted form.
      "upper"
  }?
mei_att.mordent.log.attribute.long =
  
  ## When set to 'true', a double or long mordent, sometimes called a "pinc double", consisting of 5 notes, is indicated.
  attribute long { mei_data.BOOLEAN }?
mei_att.ornamentAccid.attributes =
  mei_att.ornamentAccid.attribute.accidupper,
  mei_att.ornamentAccid.attribute.accidlower
mei_att.ornamentAccid.attribute.accidupper =
  
  ## Records the written accidental associated with an upper neighboring note.
  attribute accidupper { mei_data.ACCIDENTAL.WRITTEN }?
mei_att.ornamentAccid.attribute.accidlower =
  
  ## Records the written accidental associated with a lower neighboring note.
  attribute accidlower { mei_data.ACCIDENTAL.WRITTEN }?
mei_att.ornamPresent.attributes = mei_att.ornamPresent.attribute.ornam
mei_att.ornamPresent.attribute.ornam =
  
  ## Indicates that this element has an attached ornament. If visual information about the ornament is needed, then one of the elements that represents an ornament (mordent, trill, or turn) should be employed.
  attribute ornam {
    list { mei_data.ORNAM.cmn+ }
  }?
mei_att.trill.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.ornamentAccid.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.turn.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.ornamentAccid.attributes,
  mei_att.startId.attributes,
  mei_att.turn.log.attribute.delayed,
  mei_att.turn.log.attribute.form
mei_att.turn.log.attribute.delayed =
  
  ## When set to 'true', the turn begins on the second half of the beat.
  attribute delayed { mei_data.BOOLEAN }?
mei_att.turn.log.attribute.form =
  
  ## Records meaning; i.e., intended performance, of the turn. The altsym, glyph.name, or glyph.num attributes may be used to specify the appropriate symbol.
  attribute form {
    
    ## Begins on the note below the written note.
    "lower"
    | 
      ## Begins on the note above the written note.
      "upper"
  }?
mei_model.ornamentLike.cmn = mei_mordent | mei_trill | mei_turn
mei_model.ornamentLike.cmn_alternation =
  mei_mordent | mei_trill | mei_turn
mei_model.ornamentLike.cmn_sequence = mei_mordent, mei_trill, mei_turn
mei_model.ornamentLike.cmn_sequenceOptional =
  mei_mordent?, mei_trill?, mei_turn?
mei_model.ornamentLike.cmn_sequenceOptionalRepeatable =
  mei_mordent*, mei_trill*, mei_turn*
mei_model.ornamentLike.cmn_sequenceRepeatable =
  mei_mordent+, mei_trill+, mei_turn+
mei_mordent =
  
  ## An ornament indicating rapid alternation of the main note with a secondary note, usually a step below, but sometimes a step above. 
  element mordent {
    empty
    >> sch:pattern [
         id =
           "mei-mordent-mordent_start-type_attributes_required-constraint-rule-33"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:mordent"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.mordent.log.attributes,
    mei_att.mordent.vis.attributes,
    mei_att.mordent.ges.attributes,
    mei_att.mordent.anl.attributes,
    empty
  }
mei_trill =
  
  ## Rapid alternation of a note with another (usually at the interval of a second above).
  element trill {
    empty
    >> sch:pattern [
         id =
           "mei-trill-trill_start-type_attributes_required-constraint-rule-34"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:trill"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.trill.log.attributes,
    mei_att.trill.vis.attributes,
    mei_att.trill.ges.attributes,
    mei_att.trill.anl.attributes,
    empty
  }
mei_turn =
  
  ## An ornament consisting of four notes  the upper neighbor of the written note, the written note, the lower neighbor, and the written note.
  element turn {
    empty
    >> sch:pattern [
         id =
           "mei-turn-turn_start-type_attributes_required-constraint-rule-35"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:turn"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.turn.log.attributes,
    mei_att.turn.vis.attributes,
    mei_att.turn.ges.attributes,
    mei_att.turn.anl.attributes,
    empty
  }
mei_meiCorpus =
  
  ## (MEI corpus)  A group of related MEI documents, consisting of a header for the group, and one or more mei elements, each with its own complete header.
  element meiCorpus {
    mei_meiHead,
    mei_mei*,
    mei_att.common.attributes,
    mei_att.meiVersion.attributes,
    empty
  }
mei_att.crit.attributes =
  mei_att.handIdent.attributes,
  mei_att.sequence.attributes,
  mei_att.source.attributes,
  mei_att.crit.attribute.cause
mei_att.crit.attribute.cause =
  
  ## Classifies the cause for the variant reading, according to any appropriate typology of possible origins.
  attribute cause { xsd:NMTOKEN }?
mei_att.rdg.log.attributes = empty
mei_model.appLike = mei_app
mei_model.rdgPart =
  mei_model.rdgPart.music | mei_model.rdgPart.text | mei_model.sylLike
mei_model.rdgPart.music =
  mei_model.controlEventLike.cmn
  | mei_model.verseLike
  | mei_volta
  | mei_model.controlEventLike
  | mei_model.layerLike
mei_model.rdgPart.text =
  mei_model.textComponentLike | mei_model.textPhraseLike.limited
mei_app =
  
  ## (apparatus)  Contains one or more alternative encodings.
  element app {
    mei_lem?, mei_rdg, mei_rdg*, mei_att.common.attributes, empty
  }
mei_lem =
  
  ## (lemma)  Contains the lemma, or base text, of a textual variation.
  element lem {
    (text
     | mei_model.appLike
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.rdgPart
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike
     | mei_expansion)*,
    mei_att.common.attributes,
    mei_att.crit.attributes,
    mei_att.pointing.attributes,
    mei_att.rdg.anl.attributes,
    mei_att.rdg.ges.attributes,
    mei_att.rdg.log.attributes,
    mei_att.rdg.vis.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_rdg =
  
  ## (reading)  Contains a single reading within a textual variation.
  element rdg {
    (text
     | mei_model.appLike
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.rdgPart
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike
     | mei_expansion)*,
    mei_att.common.attributes,
    mei_att.crit.attributes,
    mei_att.pointing.attributes,
    mei_att.rdg.anl.attributes,
    mei_att.rdg.ges.attributes,
    mei_att.rdg.log.attributes,
    mei_att.rdg.vis.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_att.sp.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.stageDir.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_model.stageDirLike = mei_stageDir
mei_model.stageDirLike_alternation = mei_stageDir
mei_model.stageDirLike_sequence = mei_stageDir
mei_model.stageDirLike_sequenceOptional = mei_stageDir?
mei_model.stageDirLike_sequenceOptionalRepeatable = mei_stageDir*
mei_model.stageDirLike_sequenceRepeatable = mei_stageDir+
mei_sp =
  
  ## (speech)  Contains an individual speech in a performance text.
  element sp {
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.figureLike
     | mei_model.milestoneLike.text)*,
    (mei_speaker,
     (mei_model.annotLike
      | mei_model.appLike
      | mei_model.figureLike
      | mei_model.milestoneLike.text)*)*,
    (mei_model.lgLike
     | mei_model.lLike
     | mei_model.pLike
     | mei_model.quoteLike
     | mei_model.stageDirLike
     | mei_list)+,
    ((mei_model.annotLike
      | mei_model.appLike
      | mei_model.figureLike
      | mei_model.milestoneLike.text)*)
    >> sch:pattern [
         id =
           "mei-sp-sp_start-type_attributes_required-constraint-rule-36"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:sp[ancestor::mei:layer or ancestor::mei:measure or ancestor::mei:staff][not(ancestor::mei:sp)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-sp-sp_start-type_attributes_forbidden-constraint-rule-37"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:sp[not(ancestor::mei:layer or ancestor::mei:measure or ancestor::mei:staff)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@startid or @endid or @tstamp or @tstamp2 or @tstamp.ges or @tstamp.real or                @startho or @endho or @to or @startto or @endto or @staff or @layer or @place or @plist)"
             "Must not have any of the attributes: startid, endid, tstamp, tstamp2, tstamp.ges,\x{a}" ~
             "            tstamp.real, startho, endho, to, startto, endto, staff, layer, place, or\x{a}" ~
             "            plist."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.sp.anl.attributes,
    mei_att.sp.ges.attributes,
    mei_att.sp.log.attributes,
    mei_att.sp.vis.attributes,
    empty
  }
mei_stageDir =
  
  ## (stage direction)  Contains any kind of stage direction within a dramatic text or fragment.
  element stageDir {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-stageDir-stageDir_start-type_attributes_required-constraint-rule-38"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:stageDir[ancestor::mei:layer or ancestor::mei:measure or ancestor::mei:staff][not(ancestor::mei:sp)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-stageDir-stageDir_start-type_attributes_forbidden-constraint-rule-39"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:stageDir[not(ancestor::mei:layer or ancestor::mei:measure or ancestor::mei:staff) or ancestor::mei:sp]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@startid or @endid or @tstamp or @tstamp2 or @tstamp.ges or @tstamp.real or @startho or @endho or @to or                @startto or @endto or @staff or @layer or @place or @plist)"
             "Must not have any of the attributes: startid, endid, tstamp, tstamp2, tstamp.ges,\x{a}" ~
             "            tstamp.real, startho, endho, to, startto, endto, staff, layer, place, or\x{a}" ~
             "            plist."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.stageDir.anl.attributes,
    mei_att.stageDir.ges.attributes,
    mei_att.stageDir.log.attributes,
    mei_att.stageDir.vis.attributes,
    empty
  }
mei_att.agentIdent.attributes = mei_att.agentIdent.attribute.agent
mei_att.agentIdent.attribute.agent =
  
  ## Signifies the causative agent of damage, illegibility, or other loss of original text.
  attribute agent { xsd:string }?
mei_att.cpMark.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.origin.timestamp.logical.attributes,
  mei_att.origin.staffIdent.attributes,
  mei_att.origin.layerIdent.attributes,
  mei_att.origin.startEndId.attributes,
  mei_att.octaveDisplacement.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.edit.attributes =
  mei_att.source.attributes, mei_att.evidence.attributes
mei_att.metaMark.anl.attributes = empty
mei_att.metaMark.ges.attributes = mei_att.duration.gestural.attributes
mei_att.metaMark.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.gestural.attributes,
  mei_att.edit.attributes,
  mei_att.trans.attributes
mei_att.metaMark.vis.attributes = mei_att.placement.attributes
mei_att.reasonIdent.attributes = mei_att.reasonIdent.attribute.reason
mei_att.reasonIdent.attribute.reason =
  
  ## Holds a short phrase describing the reason for missing textual material (gap), why material is supplied (supplied), or why transcription is difficult (unclear).
  attribute reason { xsd:string }?
mei_att.trans.attributes =
  mei_att.geneticState.attributes,
  mei_att.handIdent.attributes,
  mei_att.metadataPointing.attributes,
  mei_att.sequence.attributes
mei_model.choicePart =
  mei_model.editLike
  | mei_corr
  | mei_orig
  | mei_reg
  | mei_sic
  | mei_unclear
  | mei_model.editorialLike
mei_model.editLike = mei_choice | mei_subst
mei_model.editTransPart =
  mei_model.editTransPart.music
  | mei_model.editTransPart.text
  | mei_model.sylLike
mei_model.editTransPart.music =
  mei_model.controlEventLike.cmn
  | mei_model.verseLike
  | mei_volta
  | mei_model.controlEventLike
  | mei_model.layerLike
  | mei_model.noteModifierLike
mei_model.editTransPart.text =
  mei_model.textComponentLike | mei_model.textPhraseLike.limited
mei_model.transcriptionLike =
  mei_add
  | mei_corr
  | mei_damage
  | mei_del
  | mei_gap
  | mei_handShift
  | mei_orig
  | mei_reg
  | mei_restore
  | mei_sic
  | mei_supplied
  | mei_unclear
mei_abbr =
  
  ## (abbreviation)  A generic element for 1) a shortened form of a word, including an acronym or 2) a shorthand notation.
  element abbr {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.trans.attributes,
    
    ## Records the expansion of a text abbreviation.
    attribute expan { xsd:string }?,
    empty
  }
mei_add =
  
  ## (addition)  Marks an addition to the text.
  element add {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.lang.attributes,
    mei_att.trans.attributes,
    
    ## Location of the addition.
    attribute place {
      list { mei_data.PLACEMENT+ }
    }?,
    empty
  }
mei_choice =
  
  ## Groups a number of alternative encodings for the same point in a text.
  element choice {
    mei_model.choicePart*, mei_att.common.attributes, empty
  }
mei_corr =
  
  ## (correction)  Contains the correct form of an apparent erroneous passage.
  element corr {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.lang.attributes,
    mei_att.trans.attributes,
    empty
  }
mei_cpMark =
  
  ## (copy/colla parte mark)  A verbal or graphical indication to copy musical material written elsewhere.
  element cpMark {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-cpMark-cpMark_start-_and_end-type_attributes_required-constraint-rule-40"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:cpMark"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.cpMark.log.attributes,
    mei_att.cpMark.vis.attributes,
    mei_att.cpMark.ges.attributes,
    mei_att.cpMark.anl.attributes,
    empty
  }
mei_damage =
  
  ## Contains an area of damage to the physical medium.
  element damage {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.agentIdent.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.handIdent.attributes,
    mei_att.lang.attributes,
    
    ## Records the degree of damage.
    attribute degree { xsd:string }?,
    empty
  }
mei_del =
  
  ## (deletion)  Contains information deleted, marked as deleted, or otherwise indicated as superfluous or spurious in the copy text by an author, scribe, annotator, or corrector.
  element del {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.textRendition.attributes,
    mei_att.trans.attributes,
    empty
  }
mei_expan =
  
  ## (expansion)  Contains the expansion of an abbreviation.
  element expan {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.trans.attributes,
    
    ## Captures the abbreviated form of the text.
    attribute abbr { xsd:string }?,
    empty
  }
mei_gap =
  
  ## Indicates a point where material has been omitted in a transcription, whether as part of sampling practice or for editorial reasons described in the MEI header.
  element gap {
    empty,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.handIdent.attributes,
    mei_att.reasonIdent.attributes,
    empty
  }
mei_handShift =
  
  ## Marks the beginning of a passage written in a new hand, or of a change in the scribe, writing style, ink or character of the document hand.
  element handShift {
    empty,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.medium.attributes,
    
    ## Describes the character of the new hand.
    attribute character { text }?,
    (
     ## Identifies the new hand. The value must contain the ID of a hand element given elsewhere in the document.
     attribute new { mei_data.URI }?)
    >> sch:pattern [
         id = "mei-handShift-new-check_newTarget-constraint-rule-41"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "@new"
           "\x{a}" ~
           "              "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@new attribute should\x{a}" ~
             "                have content."
           ]
           "\x{a}" ~
           "              "
           sch:assert [
             role = "warning"
             test =
               "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
             "The value in @new should correspond to the @xml:id attribute of a hand\x{a}" ~
             "                element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    (
     ## Identifies the old hand. The value must contain the ID of a hand element given elsewhere in the document.
     attribute old { mei_data.URI }?)
    >> sch:pattern [
         id = "mei-handShift-old-check_oldTarget-constraint-rule-42"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "@old"
           "\x{a}" ~
           "              "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@old attribute should\x{a}" ~
             "                have content."
           ]
           "\x{a}" ~
           "              "
           sch:assert [
             role = "warning"
             test =
               "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
             "The value in @old should correspond to the @xml:id attribute of a hand\x{a}" ~
             "                element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    empty
  }
mei_metaMark =
  
  ## A graphical or textual statement with additional / explanatory information about the musical text. The textual consequences of this intervention are encoded independently via other means; that is, with elements such as <add>, <del>, etc.
  element metaMark {
    ((text
      | mei_model.editLike
      | mei_model.sectionLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-metaMark-metaMark_start-type_attributes_required-constraint-rule-43"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:metaMark"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metaMark.log.attributes,
    mei_att.metaMark.vis.attributes,
    mei_att.metaMark.ges.attributes,
    mei_att.metaMark.anl.attributes,
    mei_att.pointing.attributes,
    
    ## Describes the purpose of the metaMark.
    ## Suggested values include: 1] confirmation; 2] addition; 3] deletion; 4] substitution; 5] clarification; 6] question; 7] investigation; 8] restoration; 9] navigation
    attribute function {
      
      ## confirmation of a previous textual decision; i.e., cancellation of a deleted passage in a different writing medium.
      "confirmation"
      | 
        ## denoted material is to be inserted in the musical text.
        "addition"
      | 
        ## denoted material is no longer part of the musical text.
        "deletion"
      | 
        ## denoted material is replaced, either by the musical text pointed at with the @target attribute or the musical content of the metaMark element itself.
        "substitution"
      | 
        ## attempt to clarify a potentially illegible or otherwise unclear part of the musical text.
        "clarification"
      | 
        ## marks a section of the musical text which is to be considered further.
        "question"
      | 
        ## marks a section of the musical text as an investigation of the consequences of certain compositional decisions or potential alternatives.
        "investigation"
      | 
        ## declares a formerly cancelled part of the musical text as valid again.
        "restoration"
      | 
        ## clarification of the reading order of the musical text.
        "navigation"
      | xsd:NMTOKEN
    }?,
    empty
  }
mei_orig =
  
  ## (original)  Contains material which is marked as following the original, rather than being normalized or corrected.
  element orig {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_reg =
  
  ## (regularization)  Contains material which has been regularized or normalized in some sense.
  element reg {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_restore =
  
  ## Indicates restoration of material to an earlier state by cancellation of an editorial or authorial marking or instruction.
  element restore {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.trans.attributes,
    
    ## Provides a description of the means of restoration, 'stet' or 'strike-down', for example.
    attribute desc { xsd:string }?,
    empty
  }
mei_sic =
  
  ## Contains apparently incorrect or inaccurate material.
  element sic {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_subst =
  
  ## (substitution)  Groups transcriptional elements when the combination is to be regarded as a single intervention in the text.
  element subst {
    mei_model.transcriptionLike,
    mei_model.transcriptionLike+,
    mei_att.common.attributes,
    mei_att.edit.attributes,
    mei_att.trans.attributes,
    empty
  }
mei_supplied =
  
  ## Contains material supplied by the transcriber or editor for any reason.
  element supplied {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.agentIdent.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.reasonIdent.attributes,
    empty
  }
mei_unclear =
  
  ## Contains material that cannot be transcribed with certainty because it is illegible or inaudible in the source.
  element unclear {
    (text
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.editTransPart
     | mei_model.fLike
     | mei_model.graphicPrimitiveLike
     | mei_model.keyAccidLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.sectionPart
     | mei_model.staffGrpLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.agentIdent.attributes,
    mei_att.edit.attributes,
    mei_att.extent.attributes,
    mei_att.facsimile.attributes,
    mei_att.handIdent.attributes,
    mei_att.lang.attributes,
    mei_att.reasonIdent.attributes,
    empty
  }
mei_att.extSym.attributes =
  mei_att.extSym.attribute.glyph.auth,
  mei_att.extSym.attribute.glyph.name,
  mei_att.extSym.attribute.glyph.num,
  mei_att.extSym.attribute.glyph.uri
mei_att.extSym.attribute.glyph.auth =
  
  ## A name or label associated with the controlled vocabulary from which the value of glyph.name or glyph.num is taken.
  ## Suggested values include: 1] smufl
  attribute glyph.auth {
    
    ## Standard Music Font Layout.
    "smufl"
    | xsd:NMTOKEN
  }?
mei_att.extSym.attribute.glyph.name =
  
  ## Glyph name.
  attribute glyph.name { xsd:string }?
sch:pattern [
  id = "mei-att.extSym-glyph.name-check_glyph.name-constraint-rule-44"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@glyph.name"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@glyph.name attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.extSym.attribute.glyph.num =
  
  ## Numeric glyph reference in hexadecimal notation, e.g. "#xE000" or "U+E000". N.B. SMuFL version 1.18 uses the range U+E000 - U+ECBF.
  attribute glyph.num { mei_data.HEXNUM }?
sch:pattern [
  id = "mei-att.extSym-glyph.num-check_glyph.num-constraint-rule-45"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "mei:*[@glyph.num and (lower-case(@glyph.auth) eq 'smufl' or @glyph.uri eq 'http://www.smufl.org/')]"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "matches(normalize-space(@glyph.num), '^(#x|U\+)E([0-9AB][0-9A-F][0-9A-F]|C[0-9A][0-9A-F]|CB[0-9A-F])$')"
      "SMuFL version 1.18 uses the range U+E000 - U+ECBF."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.extSym.attribute.glyph.uri =
  
  ## The web-accessible location of the controlled vocabulary from which the value of glyph.name or glyph.num is taken.
  attribute glyph.uri { mei_data.URI }?
mei_att.facsimile.attributes = mei_att.facsimile.attribute.facs
mei_att.facsimile.attribute.facs =
  
  ## Permits the current element to reference a facsimile surface or image zone which corresponds to it.
  attribute facs {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.facsimile-facs-check_facsTarget-constraint-rule-46"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@facs"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@facs attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name() eq 'surface' or local-name() eq 'zone']/@xml:id"
      "Each value in @facs should correspond to the @xml:id attribute of a surface or zone\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_facsimile =
  
  ## Contains a representation of a written source in the form of a set of images rather than as transcribed or encoded text.
  element facsimile {
    mei_graphic*,
    mei_surface*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_surface =
  
  ## Defines a writing surface in terms of a rectangular coordinate space, optionally grouping one or more graphic representations of that space, and rectangular zones of interest within it.
  element surface {
    mei_model.figDescLike*,
    mei_model.graphicLike*,
    mei_zone*,
    mei_att.common.attributes,
    mei_att.coordinated.attributes,
    mei_att.dataPointing.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.startId.attributes,
    empty
  }
mei_zone =
  
  ## Defines an area of interest within a surface or graphic file.
  element zone {
    mei_model.figDescLike*,
    mei_model.graphicLike*,
    mei_att.common.attributes,
    mei_att.coordinated.attributes,
    mei_att.dataPointing.attributes,
    empty
  }
mei_att.tabular.attributes =
  mei_att.tabular.attribute.colspan, mei_att.tabular.attribute.rowspan
mei_att.tabular.attribute.colspan =
  
  ## The number of columns spanned by this cell.
  attribute colspan { xsd:positiveInteger }?
mei_att.tabular.attribute.rowspan =
  
  ## The number of rows spanned by this cell.
  attribute rowspan { xsd:positiveInteger }?
mei_model.figDescLike = mei_figDesc
mei_model.figureLike = mei_fig
mei_model.figureLike_alternation = mei_fig
mei_model.figureLike_sequence = mei_fig
mei_model.figureLike_sequenceOptional = mei_fig?
mei_model.figureLike_sequenceOptionalRepeatable = mei_fig*
mei_model.figureLike_sequenceRepeatable = mei_fig+
mei_model.graphicLike = mei_graphic
mei_model.tableLike = mei_table
mei_model.tableLike_alternation = mei_table
mei_model.tableLike_sequence = mei_table
mei_model.tableLike_sequenceOptional = mei_table?
mei_model.tableLike_sequenceOptionalRepeatable = mei_table*
mei_model.tableLike_sequenceRepeatable = mei_table+
mei_fig =
  
  ## (figure)  Groups elements representing or containing graphic information such as an illustration or figure.
  element fig {
    (mei_figDesc
     | mei_model.captionLike
     | mei_model.graphicLike
     | mei_model.scoreLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.horizontalAlign.attributes,
    mei_att.verticalAlign.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_figDesc =
  
  ## (figure description)  Contains a brief prose description of the appearance or content of a graphic figure, for use when documenting an image without displaying it.
  element figDesc {
    (mei_model.textComponentLike*
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_graphic =
  
  ## Indicates the location of an inline graphic.
  element graphic {
    (mei_zone*)
    >> sch:pattern [
         id = "mei-graphic-graphic_attributes-constraint-rule-47"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:zone/mei:graphic"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:*) = 0"
             "Graphic child of zone should not have\x{a}" ~
             "            children."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-graphic-graphic_attributes-constraint-rule-48"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:symbolDef/mei:graphic"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "@startid or (@ulx and @uly)"
             "Graphic should have either a\x{a}" ~
             "            startid attribute or ulx and uly attributes."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-graphic-graphic_attributes-constraint-rule-49"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:graphic[not(ancestor::mei:symbolDef or ancestor::mei:zone)]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(@ulx or @uly)"
             "Graphic should not have @ulx or @uly\x{a}" ~
             "            attributes."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(@ho or @vo)"
             "Graphic should not have @ho or @vo\x{a}" ~
             "            attributes."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.dimensions.attributes,
    mei_att.internetMedia.attributes,
    mei_att.facsimile.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.startId.attributes,
    mei_att.visualOffset.attributes,
    
    ## Indicates the upper-left corner x coordinate.
    attribute ulx { xsd:nonNegativeInteger }?,
    
    ## Indicates the upper-left corner y coordinate.
    attribute uly { xsd:nonNegativeInteger }?,
    empty
  }
mei_table =
  
  ## Contains text displayed in tabular form.
  element table {
    mei_model.captionLike?,
    mei_tr+,
    mei_model.captionLike?,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_td =
  
  ## (table data)  Designates a table cell that contains data as opposed to a cell that contains column or row heading information.
  element td {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.xy.attributes,
    mei_att.tabular.attributes,
    empty
  }
mei_th =
  
  ## (table header)  Designates a table cell containing column or row heading information as opposed to one containing data.
  element th {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.xy.attributes,
    mei_att.tabular.attributes,
    empty
  }
mei_tr =
  
  ## (table row)  A formatting element that contains one or more cells (intersection of a row and a column) in a table.
  element tr {
    (mei_th | mei_td)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_att.fing.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.fingGrp.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.fingGrp.log.attribute.form
mei_att.fingGrp.log.attribute.form =
  
  ##
  attribute form {
    
    ## alternation of fingers.
    "alter"
    | 
      ## combination of fingers.
      "combi"
    | 
      ## substitution of fingers.
      "subst"
  }?
mei_model.fingeringLike = mei_fing | mei_fingGrp
mei_model.fingeringLike_alternation = mei_fing | mei_fingGrp
mei_model.fingeringLike_sequence = mei_fing, mei_fingGrp
mei_model.fingeringLike_sequenceOptional = mei_fing?, mei_fingGrp?
mei_model.fingeringLike_sequenceOptionalRepeatable =
  mei_fing*, mei_fingGrp*
mei_model.fingeringLike_sequenceRepeatable = mei_fing+, mei_fingGrp+
mei_fing =
  
  ## finger  An individual finger in a fingering indication.
  element fing {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-fing-fing_start-type_attributes_required-constraint-rule-50"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:fing[not(ancestor::mei:fingGrp)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-fing-stack_exclusion-constraint-rule-51"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:fing"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(descendant::mei:stack)"
             "The stack element is not allowed as a\x{a}" ~
             "            descendant of fing."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.fing.anl.attributes,
    mei_att.fing.ges.attributes,
    mei_att.fing.log.attributes,
    mei_att.fing.vis.attributes,
    empty
  }
mei_fingGrp =
  
  ## (finger group) A group of individual fingers in a fingering indication.
  element fingGrp {
    ((mei_model.fingeringLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-fingGrp-require_fingeringLike_children-constraint-rule-52"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:fingGrp"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:fing) + count(mei:fingGrp) > 1"
             "At least 2 fing or fingGrp\x{a}" ~
             "            elements are required."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:fingGrp[not(ancestor::mei:fingGrp)][@tstamp or @startid]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(child::mei:*[@tstamp or @startid])"
             "When @tstamp or @startid is\x{a}" ~
             "              present on fingGrp, its child elements cannot have a @tstamp or @startid\x{a}" ~
             "              attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:fingGrp[not(ancestor::mei:fingGrp)][not(@tstamp or @startid)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::mei:*[@tstamp or @startid]) = count(child::mei:*[local-name()='fing' or local-name()='fingGrp'])"
             "When @tstamp or @startid is not present on fingGrp, each of its child elements must\x{a}" ~
             "              have a @tstamp or @startid attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.fingGrp.anl.attributes,
    mei_att.fingGrp.ges.attributes,
    mei_att.fingGrp.log.attributes,
    mei_att.fingGrp.vis.attributes,
    empty
  }
mei_model.expressionLike = mei_expression
mei_model.itemLike = mei_item
mei_model.manifestationLike = mei_manifestation
mei_expression =
  
  ## Intellectual or artistic realization of a work.
  element expression {
    mei_model.headLike*,
    mei_model.identifierLike*,
    mei_model.titleLike+,
    mei_model.respLikePart*,
    mei_model.workIdent*,
    mei_otherChar*,
    mei_creation?,
    mei_history?,
    mei_langUsage?,
    mei_perfMedium?,
    mei_perfDuration?,
    mei_extent*,
    mei_scoreFormat?,
    mei_contents?,
    mei_context?,
    mei_biblList*,
    mei_notesStmt?,
    mei_classification?,
    mei_componentList?,
    mei_relationList?,
    mei_extMeta*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    empty
  }
mei_expressionList =
  
  ## Gathers bibliographic expression entities.
  element expressionList {
    mei_model.headLike*,
    mei_model.expressionLike*,
    mei_att.common.attributes,
    empty
  }
mei_item =
  
  ## Single instance or exemplar of a source/manifestation.
  element item {
    mei_model.headLike*,
    mei_model.identifierLike*,
    mei_availability?,
    mei_physDesc?,
    mei_physLoc?,
    mei_history?,
    mei_notesStmt?,
    mei_classification?,
    mei_componentList?,
    mei_relationList?,
    mei_extMeta*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_itemList =
  
  ## Gathers bibliographic item entities.
  element itemList {
    mei_model.headLike*,
    mei_model.itemLike*,
    mei_att.common.attributes,
    empty
  }
mei_manifestation =
  
  ## A bibliographic description of a physical embodiment of an expression of a work.
  element manifestation {
    mei_model.headLike*,
    (mei_locus | mei_locusGrp)*,
    mei_model.identifierLike*,
    mei_titleStmt?,
    mei_macro.bibldescPart,
    mei_creation?,
    mei_history?,
    mei_langUsage?,
    mei_contents?,
    mei_biblList*,
    mei_notesStmt?,
    mei_classification?,
    mei_itemList?,
    mei_componentList?,
    mei_relationList?,
    (mei_extMeta*)
    >> sch:pattern [
         id = "mei-manifestation-check_singleton-constraint-rule-55"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:manifestation[@singleton eq 'true']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(mei:itemList)"
             "Item children are not permitted when @singleton\x{a}" ~
             '            equals "true".'
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.componentType.attributes,
    mei_att.dataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.recordType.attributes,
    mei_att.targetEval.attributes,
    
    ##
    attribute singleton { mei_data.BOOLEAN }?,
    empty
  }
mei_manifestationList =
  
  ## A container for the descriptions of physical embodiments of an expression of a work.
  element manifestationList {
    mei_model.headLike*,
    mei_model.manifestationLike+,
    mei_att.common.attributes,
    empty
  }
mei_att.geneticState.attributes =
  mei_att.geneticState.attribute.instant,
  mei_att.geneticState.attribute.state
mei_att.geneticState.attribute.instant =
  
  ## The @instant attribute is syntactic sugar for classifying a scribal intervention as an ad-hoc modification; that is, one which does not interrupt the writing process.
  attribute instant { mei_data.BOOLEAN | "unknown" }?
mei_att.geneticState.attribute.state =
  
  ## Points to the genetic state that results from this modification.
  attribute state {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id =
    "mei-att.geneticState-check_changeState.targets-constraint-rule-56"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@state"
    "\x{a}" ~
    "          "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@state attribute should\x{a}" ~
      "            have content."
    ]
    "\x{a}" ~
    "          "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:genState/@xml:id"
      "The value in @state should correspond to the @xml:id attribute of a genState\x{a}" ~
      "            element."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
mei_genDesc =
  
  ## (genetic description) - Bundles information about the textual development of a work.
  element genDesc {
    (mei_genDesc | mei_genState)*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    
    ## When set to "true" the child elements are known to be in chronological order. When set to "false" or when not provided, the order of child elements is unknown.
    attribute ordered { mei_data.BOOLEAN }?,
    empty
  }
mei_genState =
  
  ## Describes a distinctive state in the textual development of a work.
  element genState {
    mei_desc*,
    mei_respStmt*,
    mei_model.dateLike?,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.dataPointing.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    empty
  }
mei_att.accid.ges.attributes = mei_att.accidental.gestural.attributes
mei_att.accidental.gestural.attributes =
  mei_att.accidental.gestural.attribute.accid.ges
mei_att.accidental.gestural.attribute.accid.ges =
  
  ## Records the performed pitch inflection.
  attribute accid.ges { mei_data.ACCIDENTAL.GESTURAL }?
sch:pattern [
  id =
    "mei-att.accidental.gestural-accid.ges-check_accid_duplication-constraint-rule-57"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@accid.ges"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(. eq ../@accid)"
      "The value of @accid.ges should\x{a}" ~
      "                not duplicate the value of @accid."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.ambNote.ges.attributes = empty
mei_att.annot.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.arpeg.ges.attributes = empty
mei_att.artic.ges.attributes = mei_att.articulation.gestural.attributes
mei_att.articulation.gestural.attributes =
  mei_att.articulation.gestural.attribute.artic.ges
mei_att.articulation.gestural.attribute.artic.ges =
  
  ## Records performed articulation that differs from the written value.
  attribute artic.ges {
    list { mei_data.ARTICULATION+ }
  }?
mei_att.attacca.ges.attributes = mei_att.timestamp2.gestural.attributes
mei_att.barLine.ges.attributes = empty
mei_att.beam.ges.attributes = empty
mei_att.beamSpan.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.beatRpt.ges.attributes = empty
mei_att.bend.ges.attributes =
  mei_att.timestamp2.gestural.attributes,
  mei_att.bend.ges.attribute.amount
mei_att.bend.ges.attribute.amount =
  
  ## Records the amount of detuning. The decimal values should be rendered as a fraction (or an integer plus a fraction) along with the bend symbol.
  attribute amount { mei_data.BEND.AMOUNT }?
mei_att.bracketSpan.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.breath.ges.attributes = mei_att.timestamp.gestural.attributes
mei_att.bTrem.ges.attributes = mei_att.tremMeasured.attributes
mei_att.caesura.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp.gestural.attributes
mei_att.chord.ges.attributes =
  mei_att.articulation.gestural.attributes,
  mei_att.duration.gestural.attributes,
  mei_att.instrumentIdent.attributes,
  mei_att.chord.ges.cmn.attributes
mei_att.chordDef.ges.attributes = empty
mei_att.chordMember.ges.attributes =
  mei_att.accidental.gestural.attributes
mei_att.clef.ges.attributes = empty
mei_att.clefGrp.ges.attributes = empty
mei_att.cpMark.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.curve.ges.attributes = empty
mei_att.custos.ges.attributes = empty
mei_att.mdiv.ges.attributes = mei_att.mdiv.ges.attribute.attacca
mei_att.mdiv.ges.attribute.attacca =
  
  ## Indicates that the performance of the next musical division should begin immediately following this one.
  attribute attacca { mei_data.BOOLEAN }?
mei_att.dir.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.dot.ges.attributes = empty
mei_att.duration.gestural.attributes =
  mei_att.duration.gestural.attribute.dur.ges,
  mei_att.duration.gestural.attribute.dots.ges,
  mei_att.duration.gestural.attribute.dur.metrical,
  mei_att.duration.gestural.attribute.dur.ppq,
  mei_att.duration.gestural.attribute.dur.real,
  mei_att.duration.gestural.attribute.dur.recip
mei_att.duration.gestural.attribute.dur.ges =
  
  ## Records performed duration information that differs from the written duration.
  attribute dur.ges { mei_data.DURATION.gestural }?
mei_att.duration.gestural.attribute.dots.ges =
  
  ## Number of dots required for a gestural duration when different from that of the written duration.
  attribute dots.ges { mei_data.AUGMENTDOT }?
mei_att.duration.gestural.attribute.dur.metrical =
  
  ## Duration as a count of units provided in the time signature denominator.
  attribute dur.metrical {
    xsd:decimal { pattern = "\d+(\.\d+)?" }
  }?
mei_att.duration.gestural.attribute.dur.ppq =
  
  ## Duration recorded as pulses-per-quarter note, e.g. MIDI clicks or MusicXML divisions.
  attribute dur.ppq { xsd:nonNegativeInteger }?
mei_att.duration.gestural.attribute.dur.real =
  
  ## Duration in seconds, e.g. '1.732'.
  attribute dur.real {
    xsd:decimal { pattern = "\d+(\.\d+)?" }
  }?
mei_att.duration.gestural.attribute.dur.recip =
  
  ## Duration as an optionally dotted Humdrum *recip value.
  attribute dur.recip {
    xsd:token { pattern = "\d+(\.)*" }
  }?
mei_att.dynam.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.midiValue.attributes,
  mei_att.midiValue2.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.ending.ges.attributes = empty
mei_att.f.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.fermata.ges.attributes = mei_att.duration.gestural.attributes
mei_att.fing.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.fingGrp.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.fTrem.ges.attributes = mei_att.tremMeasured.attributes
mei_att.gliss.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.grpSym.ges.attributes = empty
mei_att.hairpin.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.midiValue.attributes,
  mei_att.midiValue2.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.halfmRpt.ges.attributes = mei_att.duration.gestural.attributes
mei_att.harm.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.harpPedal.ges.attributes = mei_att.duration.gestural.attributes
mei_att.instrDef.ges.attributes =
  mei_att.channelized.attributes,
  mei_att.midiInstrument.attributes,
  mei_att.soundLocation.attributes
mei_att.keyAccid.ges.attributes = empty
mei_att.keySig.ges.attributes = empty
mei_att.layer.ges.attributes = empty
mei_att.layerDef.ges.attributes = mei_att.instrumentIdent.attributes
mei_att.line.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.lv.ges.attributes = mei_att.timestamp2.gestural.attributes
mei_att.lyrics.ges.attributes = empty
mei_att.measure.ges.attributes = mei_att.timestamp.gestural.attributes
mei_att.meterSig.ges.attributes = empty
mei_att.meterSigGrp.ges.attributes = empty
mei_att.midi.ges.attributes = empty
mei_att.mordent.ges.attributes = empty
mei_att.mRest.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.instrumentIdent.attributes
mei_att.mRpt.ges.attributes = empty
mei_att.mRpt2.ges.attributes = empty
mei_att.mSpace.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.instrumentIdent.attributes
mei_att.multiRest.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.instrumentIdent.attributes
mei_att.multiRpt.ges.attributes = empty
mei_att.note.ges.attributes =
  mei_att.accidental.gestural.attributes,
  mei_att.articulation.gestural.attributes,
  mei_att.duration.gestural.attributes,
  mei_att.instrumentIdent.attributes,
  mei_att.midiVelocity.attributes,
  mei_att.stringtab.attributes,
  mei_att.note.ges.attribute.extremis,
  mei_att.note.ges.attribute.oct.ges,
  mei_att.note.ges.attribute.pname.ges,
  mei_att.note.ges.attribute.pnum
mei_att.note.ges.attribute.extremis =
  
  ## Indicates an extreme, indefinite performed pitch.
  attribute extremis {
    
    ## Highest note the performer can play.
    "highest"
    | 
      ## Lowest note the performer can play.
      "lowest"
  }?
mei_att.note.ges.attribute.oct.ges =
  
  ## Records performed octave information that differs from the written value.
  attribute oct.ges { mei_data.OCTAVE }?
mei_att.note.ges.attribute.pname.ges =
  
  ## Contains a performed pitch name that differs from the written value.
  attribute pname.ges { mei_data.PITCHNAME.GES }?
mei_att.note.ges.attribute.pnum =
  
  ## Holds a pitch-to-number mapping, a base-40 or MIDI note number, for example.
  attribute pnum { mei_data.PITCHNUMBER }?
sch:pattern [
  id =
    "mei-att.note.ges-extremis_disallows_gestural_pitch-constraint-rule-58"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:note[@extremis]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "not(@pname.ges) and not(@oct.ges)"
      "When the @extremis attribute is used,\x{a}" ~
      "            the @pname.ges and @oct.ges attributes are not allowed."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
mei_att.octave.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.ornam.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.ossia.ges.attributes = empty
mei_att.pad.ges.attributes = empty
mei_att.part.ges.attributes = empty
mei_att.parts.ges.attributes = empty
mei_att.pb.ges.attributes = empty
mei_att.pedal.ges.attributes = mei_att.timestamp2.gestural.attributes
mei_att.phrase.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.rdg.ges.attributes = empty
mei_att.refrain.ges.attributes = empty
mei_att.reh.ges.attributes = empty
mei_att.rest.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.instrumentIdent.attributes
mei_att.sb.ges.attributes = empty
mei_att.score.ges.attributes = empty
mei_att.scoreDef.ges.attributes =
  mei_att.channelized.attributes,
  mei_att.timeBase.attributes,
  mei_att.midiTempo.attributes,
  mei_att.mmTempo.attributes,
  mei_att.scoreDef.ges.attribute.tune.pname,
  mei_att.scoreDef.ges.attribute.tune.Hz,
  mei_att.scoreDef.ges.attribute.tune.temper
mei_att.scoreDef.ges.attribute.tune.pname =
  
  ## Holds the pitch name of a tuning reference pitch.
  attribute tune.pname { mei_data.PITCHNAME }?
mei_att.scoreDef.ges.attribute.tune.Hz =
  
  ## Holds a value for cycles per second, i.e., Hertz, for a tuning reference pitch.
  attribute tune.Hz { xsd:decimal }?
mei_att.scoreDef.ges.attribute.tune.temper =
  
  ## Provides an indication of the tuning system, 'just', for example.
  attribute tune.temper { mei_data.TEMPERAMENT }?
mei_att.section.ges.attributes = mei_att.section.ges.attribute.attacca
mei_att.section.ges.attribute.attacca =
  
  ## Indicates that the performance of the next section should begin immediately following this one.
  attribute attacca { mei_data.BOOLEAN }?
mei_att.slur.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.soundLocation.attributes =
  mei_att.soundLocation.attribute.azimuth,
  mei_att.soundLocation.attribute.elevation
mei_att.soundLocation.attribute.azimuth =
  
  ## The lateral or left-to-right plane.
  attribute azimuth { mei_data.DEGREES }?
mei_att.soundLocation.attribute.elevation =
  
  ## The above-to-below axis.
  attribute elevation { mei_data.DEGREES }?
mei_att.sp.ges.attributes = mei_att.timestamp2.gestural.attributes
mei_att.space.ges.attributes = mei_att.duration.gestural.attributes
mei_att.staff.ges.attributes = empty
mei_att.staffDef.ges.attributes =
  mei_att.instrumentIdent.attributes,
  mei_att.stringtab.tuning.attributes,
  mei_att.timeBase.attributes
mei_att.staffGrp.ges.attributes = mei_att.instrumentIdent.attributes
mei_att.stageDir.ges.attributes = mei_att.timestamp2.gestural.attributes
mei_att.syl.ges.attributes = empty
mei_att.symbol.ges.attributes = empty
mei_att.tempo.ges.attributes = mei_att.midiTempo.attributes
mei_att.tie.ges.attributes = mei_att.timestamp2.gestural.attributes
mei_att.timestamp.gestural.attributes =
  mei_att.timestamp.gestural.attribute.tstamp.ges,
  mei_att.timestamp.gestural.attribute.tstamp.real
mei_att.timestamp.gestural.attribute.tstamp.ges =
  
  ## Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
  attribute tstamp.ges { mei_data.BEAT }?
mei_att.timestamp.gestural.attribute.tstamp.real =
  
  ## Records the onset time in terms of ISO time.
  attribute tstamp.real { mei_data.ISOTIME }?
mei_att.timestamp2.gestural.attributes =
  mei_att.timestamp2.gestural.attribute.tstamp2.ges,
  mei_att.timestamp2.gestural.attribute.tstamp2.real
mei_att.timestamp2.gestural.attribute.tstamp2.ges =
  
  ## Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
  attribute tstamp2.ges { mei_data.MEASUREBEAT }?
mei_att.timestamp2.gestural.attribute.tstamp2.real =
  
  ## Records the ending point of an event in terms of ISO time.
  attribute tstamp2.real { mei_data.ISOTIME }?
mei_att.trill.ges.attributes =
  mei_att.duration.gestural.attributes,
  mei_att.timestamp2.gestural.attributes
mei_att.tuplet.ges.attributes = mei_att.duration.gestural.attributes
mei_att.tupletSpan.ges.attributes =
  mei_att.timestamp2.gestural.attributes, mei_att.tuplet.ges.attributes
mei_att.turn.ges.attributes = empty
mei_att.verse.ges.attributes = empty
mei_att.volta.ges.attributes = empty
mei_att.chordDef.log.attributes =
  mei_att.stringtab.position.attributes,
  mei_att.stringtab.tuning.attributes
mei_att.chordMember.log.attributes =
  mei_att.pitched.attributes, mei_att.stringtab.attributes
mei_att.f.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.harm.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.harm.log.attribute.chordref
mei_att.harm.log.attribute.chordref =
  
  ## Contains a reference to a chordDef element elsewhere in the document.
  attribute chordref { mei_data.URI }?
sch:pattern [
  id =
    "mei-att.harm.log-chordref-check_chordrefTarget-constraint-rule-59"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@chordref"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@chordref attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:chordDef/@xml:id"
      "The value in @chordref should correspond to the @xml:id attribute of a chordDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_model.chordTableLike = mei_chordTable
mei_model.controlEventLike.harmony = mei_model.harmLike
mei_model.controlEventLike.harmony_alternation =
  mei_model.harmLike_alternation
mei_model.controlEventLike.harmony_sequence =
  mei_model.harmLike_sequence
mei_model.controlEventLike.harmony_sequenceOptional =
  mei_model.harmLike_sequenceOptional?
mei_model.controlEventLike.harmony_sequenceOptionalRepeatable =
  mei_model.harmLike_sequenceOptionalRepeatable*
mei_model.controlEventLike.harmony_sequenceRepeatable =
  mei_model.harmLike_sequenceRepeatable+
mei_model.figbassLike = mei_fb
mei_model.fLike = mei_f
mei_model.harmLike = mei_harm
mei_model.harmLike_alternation = mei_harm
mei_model.harmLike_sequence = mei_harm
mei_model.harmLike_sequenceOptional = mei_harm?
mei_model.harmLike_sequenceOptionalRepeatable = mei_harm*
mei_model.harmLike_sequenceRepeatable = mei_harm+
mei_chordDef =
  
  ## (chord definition)  Chord tablature definition.
  element chordDef {
    mei_chordMember*,
    mei_barre*,
    mei_att.common.attributes,
    mei_att.chordDef.anl.attributes,
    mei_att.chordDef.ges.attributes,
    mei_att.chordDef.log.attributes,
    mei_att.chordDef.vis.attributes,
    empty
  }
mei_chordMember =
  
  ## An individual pitch in a chord defined by a chordDef element.
  element chordMember {
    empty,
    mei_att.common.attributes,
    mei_att.chordMember.anl.attributes,
    mei_att.chordMember.ges.attributes,
    mei_att.chordMember.log.attributes,
    mei_att.chordMember.vis.attributes,
    empty
  }
mei_chordTable =
  
  ## Chord/tablature look-up table.
  element chordTable { mei_chordDef+, mei_att.common.attributes, empty }
mei_f =
  
  ## (figure)  Single element of a figured bass indication.
  element f {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.f.anl.attributes,
    mei_att.f.ges.attributes,
    mei_att.f.log.attributes,
    mei_att.f.vis.attributes,
    empty
  }
mei_fb =
  
  ## (figured bass)  Symbols added to a bass line that indicate harmony. Used to improvise a chordal accompaniment. Sometimes called Generalbass, thoroughbass, or basso continuo.
  element fb {
    (mei_model.fLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_harm =
  
  ## (harmony)  An indication of harmony, e.g., chord names, tablature grids, harmonic analysis, figured bass.
  element harm {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.graphicPrimitiveLike
      | mei_model.editLike
      | mei_model.transcriptionLike
      | mei_model.figbassLike)*)
    >> sch:pattern [
         id =
           "mei-harm-harm_start-type_attributes_required-constraint-rule-60"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:harm"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.harm.log.attributes,
    mei_att.harm.vis.attributes,
    mei_att.harm.ges.attributes,
    mei_att.harm.anl.attributes,
    empty
  }
mei_att.bifoliumSurfaces.attributes =
  mei_att.bifoliumSurfaces.attribute.outer.recto,
  mei_att.bifoliumSurfaces.attribute.inner.verso,
  mei_att.bifoliumSurfaces.attribute.inner.recto,
  mei_att.bifoliumSurfaces.attribute.outer.verso
mei_att.bifoliumSurfaces.attribute.outer.recto =
  
  ## A reference to a surface element positioned on the outer recto side of a (folded) sheet.
  attribute outer.recto { mei_data.URI }?
mei_att.bifoliumSurfaces.attribute.inner.verso =
  
  ## A reference to a surface element positioned on the inner verso side of a (folded) sheet.
  attribute inner.verso { mei_data.URI }?
mei_att.bifoliumSurfaces.attribute.inner.recto =
  
  ## A reference to a surface element positioned on the inner recto side of a (folded) sheet.
  attribute inner.recto { mei_data.URI }?
mei_att.bifoliumSurfaces.attribute.outer.verso =
  
  ## A reference to a surface element positioned on the outer verso side of a (folded) sheet.
  attribute outer.verso { mei_data.URI }?
mei_att.foliumSurfaces.attributes =
  mei_att.foliumSurfaces.attribute.recto,
  mei_att.foliumSurfaces.attribute.verso
mei_att.foliumSurfaces.attribute.recto =
  
  ## A reference to a surface element positioned on the recto side of the sheet.
  attribute recto { mei_data.URI }?
mei_att.foliumSurfaces.attribute.verso =
  
  ## A reference to a surface element positioned on the verso side of the sheet.
  attribute verso { mei_data.URI }?
mei_att.recordType.attributes = mei_att.recordType.attribute.recordtype
mei_att.recordType.attribute.recordtype =
  
  ##
  attribute recordtype {
    
    ## Language material.
    "a"
    | 
      ## Notated music.
      "c"
    | 
      ## Manuscript notated music.
      "d"
    | 
      ## Non-manuscript cartographic material.
      "e"
    | 
      ## Manuscript cartographic material.
      "f"
    | 
      ## Projected medium.
      "g"
    | 
      ## Nonmusical sound recording.
      "i"
    | 
      ## Musical sound recording.
      "j"
    | 
      ## Two-dimensional nonprojectable graphic.
      "k"
    | 
      ## Computer file.
      "m"
    | 
      ## Kit.
      "o"
    | 
      ## Mixed materials.
      "p"
    | 
      ## Three-dimensional artifact or naturally occurring object.
      "r"
    | 
      ## Manuscript language material. 
      "t"
  }?
mei_att.regularMethod.attributes =
  mei_att.regularMethod.attribute.method
mei_att.regularMethod.attribute.method =
  
  ## Indicates the method employed to mark corrections and normalizations.
  attribute method {
    
    ## Corrections and normalizations made silently.
    "silent"
    | 
      ## Corrections and normalizations indicated using elements.
      "tags"
  }?
mei_model.bifoliumLike = mei_bifolium
mei_model.editorialDeclPart =
  mei_correction
  | mei_interpretation
  | mei_normalization
  | mei_segmentation
  | mei_stdVals
mei_model.eventPart =
  mei_model.nameLike.agent
  | mei_model.nameLike.geogName
  | mei_model.addressLike
  | mei_model.dateLike
  | mei_desc
  | mei_name
mei_model.foliumLike = mei_folium
mei_model.frontAndBackPart = mei_titlePage
mei_model.paperModLike = mei_cutout | mei_patch
mei_model.physDescPart =
  mei_captureMode
  | mei_carrierForm
  | mei_condition
  | mei_exhibHist
  | mei_fileChar
  | mei_fingerprint
  | mei_foliaDesc
  | mei_handList
  | mei_inscription
  | mei_perfDuration
  | mei_physMedium
  | mei_plateNum
  | mei_playingSpeed
  | mei_scoreFormat
  | mei_soundChan
  | mei_specRepro
  | mei_trackConfig
  | mei_treatHist
  | mei_treatSched
  | mei_watermark
  | mei_accMat
  | mei_addDesc
  | mei_bindingDesc
  | mei_catchwords
  | mei_colophon
  | mei_decoDesc
  | mei_explicit
  | mei_heraldry
  | mei_layoutDesc
  | mei_rubric
  | mei_scriptDesc
  | mei_sealDesc
  | mei_secFolio
  | mei_signatures
  | mei_stamp
  | mei_supportDesc
  | mei_typeDesc
  | mei_model.incipLike
  | mei_dimensions
  | mei_extent
  | mei_titlePage
mei_model.pubStmtPart =
  mei_availability
  | mei_model.addressLike
  | mei_model.dateLike
  | mei_model.identifierLike
  | mei_distributor
  | mei_publisher
  | mei_pubPlace
  | mei_respStmt
mei_model.workIdent =
  mei_key
  | mei_mensuration
  | mei_meter
  | mei_model.incipLike
  | mei_tempo
mei_model.workLike = mei_work
mei_componentList =
  
  ## Container for intellectual or physical component parts of a bibliographic entity.
  element componentList {
    mei_model.headLike*,
    ((mei_model.workLike* | mei_model.expressionLike*)
     | (mei_model.manifestationLike* | mei_model.itemLike*))
    >> sch:pattern [
         id = "mei-componentList-checkComponentList-constraint-rule-61"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:componentList"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "every $i in ./child::mei:*[not(local-name()='head')] satisfies              $i/local-name() eq ./parent::mei:*/local-name()"
             "Only child elements of the same name as the parent of the componentList are\x{a}" ~
             "            allowed."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-componentList-checkComponents-constraint-rule-62"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:componentList[mei:*[@comptype]]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test =
               "count(mei:*[@comptype]) = count(mei:*[local-name() ne 'head'])"
             "When any child\x{a}" ~
             "            element has a comptype attribute, it is recommended that comptype appear on all child\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    empty
  }
mei_accessRestrict =
  
  ## (access restriction)  Describes the conditions that affect the accessibility of material.
  element accessRestrict {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_acquisition =
  
  ## Records information concerning the process by which an item was acquired by the holding institution.
  element acquisition {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_altId =
  
  ## (alternative identifier)  May contain a bibliographic identifier that does not fit within the meiHead element's id attribute, for example because the identifier does not fit the definition of an XML id or because multiple identifiers are needed.
  element altId {
    (text | mei_model.lbLike | mei_model.rendLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_appInfo =
  
  ## (application information)  Groups information about applications which have acted upon the MEI file.
  element appInfo {
    mei_model.headLike*,
    mei_application*,
    mei_att.common.attributes,
    empty
  }
mei_application =
  
  ## Provides information about an application which has acted upon the current document.
  element application {
    mei_name+,
    (mei_model.locrefLike* | mei_model.pLike*),
    mei_att.common.attributes,
    mei_att.datable.attributes,
    
    ## Supplies a version number for an application, independent of its identifier or display name.
    attribute version { xsd:NMTOKEN }?,
    empty
  }
mei_attUsage =
  
  ## Documents the usage of a specific attribute of the element.
  element attUsage {
    (mei_desc?)
    >> sch:pattern [
         id =
           "mei-attUsage-context_attribute_requires_content-constraint-rule-63"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "@context"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@context attribute should\x{a}" ~
             "            contain an XPath expression."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    
    ## Name of the attribute.
    attribute name { mei_data.NMTOKEN },
    
    ## Circumstances in which the element appears, an XPath expression.
    attribute context { xsd:string }?,
    empty
  }
mei_audience =
  
  ## Defines the class of user for which the work is intended, as defined by age group (e.g., children, young adults, adults, etc.), educational level (e.g., primary, secondary, etc.), or other categorization.
  element audience {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_availability =
  
  ## Groups elements that describe the availability of and access to a bibliographic item, including an MEI-encoded document.
  element availability {
    mei_macro.availabilityPart,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    empty
  }
mei_bifolium =
  
  ## Describes a folded sheet of paper.
  element bifolium {
    (mei_model.foliumLike
     | mei_model.bifoliumLike
     | mei_model.paperModLike
     | mei_del
     | mei_add
     | mei_damage
     | mei_gap
     | mei_restore)*,
    mei_att.common.attributes,
    mei_att.dimensions.attributes,
    mei_att.measurement.attributes,
    mei_att.bifoliumSurfaces.attributes,
    empty
  }
mei_byline =
  
  ## Contains the primary statement of responsibility given for a work on its title page.
  element byline {
    (text | mei_model.textPhraseLike.limited | mei_model.respLikePart)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_captureMode =
  
  ## (capture mode)  The means used to record notation, sound, or images in the production of a source/manifestation (e.g., analogue, acoustic, electric, digital, optical etc.).
  element captureMode {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_carrierForm =
  
  ## (carrier form)  The specific class of material to which the physical carrier of the source/manifestation belongs (e.g., sound cassette, videodisc, microfilm cartridge, transparency, etc.). The carrier for a manifestation comprising multiple physical components may include more than one form (e.g., a filmstrip with an accompanying booklet, a separate sound disc carrying the sound track for a film, etc.).
  element carrierForm {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_category =
  
  ## Contains an individual descriptive category in a user-defined taxonomy, possibly nested within a superordinate category.
  element category {
    mei_altId*,
    mei_label*,
    mei_desc*,
    mei_catRel*,
    (mei_category*)
    >> sch:pattern [
         id = "mei-category-category_id-constraint-rule-64"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:category"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@xml:id"
             role = "warning"
             "To be addressable, the category element must\x{a}" ~
             "            have an xml:id attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    empty
  }
mei_catRel =
  
  ## (category relationship)  Contains the name of a related category.
  element catRel {
    mei_label*,
    mei_desc*,
    mei_att.authorized.attributes,
    mei_att.basic.attributes,
    mei_att.bibl.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    
    ## Provides a description of the relationship between the current and the target categories.
    attribute type {
      
      ## Category to which the current category is hierarchically subordinate.
      "broader"
      | 
        ## Category which is hierarchically subordinate to the current category.
        "narrower"
      | 
        ## Category that is associatively but not hierarchically linked to the current category.
        "related"
      | 
        ## Non-preferred category; often a synonym or near-synonym for the preferred category label.
        "usefor"
    },
    empty
  }
mei_change =
  
  ## Individual change within the revision description.
  element change {
    mei_respStmt?,
    mei_changeDesc,
    (mei_model.dateLike?)
    >> sch:pattern [
         id = "mei-change-check_change-constraint-rule-65"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:change"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@isodate or mei:date"
             "The date of the change must be recorded in an\x{a}" ~
             "            isodate attribute or date element."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@resp or mei:respStmt[mei:name or mei:corpName or mei:persName]"
             role = "warning"
             "It is recommended that the agent responsible for the change be recorded\x{a}" ~
             "            in a resp attribute or in a name, corpName, or persName element in the respStmt\x{a}" ~
             "            element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    empty
  }
mei_changeDesc =
  
  ## (change description)  Description of a revision of the MEI file.
  element changeDesc {
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_classDecls =
  
  ## Groups information which describes the nature or topic of an entity.
  element classDecls {
    mei_model.headLike*,
    mei_taxonomy*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_classification =
  
  ## Groups information which describes the nature or topic of an entity.
  element classification {
    mei_model.headLike*,
    mei_termList+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    empty
  }
mei_condition =
  
  ## The physical condition of an item, particularly any variances between the physical make-up of the item and that of other copies of the same item (e.g., missing pages or plates, brittleness, faded images, etc.).
  element condition {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_contentItem =
  
  ## Contains a single entry within a content description element.
  element contentItem {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_contents =
  
  ## List of the material contained within a resource.
  element contents {
    mei_model.headLike*,
    (mei_model.pLike? | (mei_label?, mei_contentItem)+)
    >> sch:pattern [
         id = "mei-contents-checkContentsLabels-constraint-rule-66"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:contents[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:contentItem)"
             "When labels\x{a}" ~
             "            are used, usually each content item has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.pointing.attributes,
    empty
  }
mei_context =
  
  ## The historical, social, intellectual, artistic, or other context within which the work was originally conceived (e.g., the 17th century restoration of the monarchy in England, the aesthetic movement of the late 19th century, etc.) or the historical, social, intellectual, artistic, or other context within which the expression was realized.
  element context {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_correction =
  
  ## States how and under what circumstances corrections have been made in the text.
  element correction {
    mei_model.headLike*,
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    mei_att.regularMethod.attributes,
    
    ## Indicates the degree of correction applied to the text.
    attribute corrlevel {
      
      ## The text has been thoroughly checked and proofread.
      "high"
      | 
        ## The text has been checked at least once.
        "medium"
      | 
        ## The text has not been checked.
        "low"
      | 
        ## The correction status of the text is unknown.
        "unknown"
    }?,
    empty
  }
mei_cutout =
  
  ## A cutout is a section of a document sheet that has been removed and is now missing.
  element cutout {
    (mei_model.foliumLike | mei_model.bifoliumLike)*,
    mei_att.common.attributes,
    mei_att.dimensions.attributes,
    mei_att.evidence.attributes,
    mei_att.measurement.attributes,
    mei_att.trans.attributes,
    mei_att.xy.attributes,
    
    ## Describes the position of the cutout on the parent folium / bifolium.
    attribute removed.from {
      
      ## removed from outer recto side of bifolium.
      "outer.recto"
      | 
        ## removed from inner verso side of bifolium.
        "inner.verso"
      | 
        ## removed from inner recto side of bifolium.
        "inner.recto"
      | 
        ## removed from outer verso side of bifolium.
        "outer.verso"
      | 
        ## removed from recto side of folium.
        "recto"
      | 
        ## removed from verso side of folium.
        "verso"
    },
    
    ## Describes the method of removing the cutout.
    ## Suggested values include: 1] cut; 2] rip
    attribute removed.by {
      
      ## section is cleanly cut by a knife, scissor or other sharp blade.
      "cut"
      | 
        ## section is ripped off the page, leaving a rough edge.
        "rip"
      | xsd:NMTOKEN
    }?,
    empty
  }
mei_dedication =
  
  ## Contains a dedicatory statement.
  element dedication {
    ((mei_model.headLike*, mei_model.textComponentLike*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_domainsDecl =
  
  ## (domains declaration)  Indicates which domains are included in the encoding.
  element domainsDecl {
    empty,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    
    ##
    attribute anl { mei_data.BOOLEAN },
    
    ##
    attribute ges { mei_data.BOOLEAN },
    
    ##
    attribute vis { mei_data.BOOLEAN },
    empty
  }
mei_editionStmt =
  
  ## (edition statement)  Container for meta-data pertaining to a particular edition of the material being described.
  element editionStmt {
    mei_model.headLike*,
    (mei_model.editionLike, (mei_model.respLikePart | mei_respStmt)*)+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_editorialDecl =
  
  ## (editorial declaration)  Used to provide details of editorial principles and practices applied during the encoding of musical text.
  element editorialDecl {
    mei_model.headLike*,
    (mei_model.pLike+
     | (mei_model.editorialDeclPart+, mei_model.pLike*)),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_encodingDesc =
  
  ## (encoding description)  Documents the relationship between an electronic file and the source or sources from which it was derived as well as applications used in the encoding/editing process.
  element encodingDesc {
    mei_model.headLike*,
    mei_appInfo?,
    mei_editorialDecl?,
    mei_projectDesc?,
    mei_samplingDecl?,
    mei_domainsDecl*,
    mei_tagsDecl?,
    mei_classDecls?,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_exhibHist =
  
  ## (exhibition history)  A record of public exhibitions, including dates, venues, etc.
  element exhibHist {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_extMeta =
  
  ## (extended metadata)  Provides a container element for non-MEI metadata formats.
  element extMeta {
    (text | mei_macro.anyXML)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.whitespace.attributes,
    empty
  }
mei_fileChar =
  
  ## (file characteristics)  Standards or schemes used to encode the file (e.g., ASCII, SGML, etc.), physical characteristics of the file (e.g., recording density, parity, blocking, etc.), and other characteristics that have a bearing on how the file can be processed.
  element fileChar {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_fileDesc =
  
  ## (file description)  Contains a full bibliographic description of the MEI file.
  element fileDesc {
    mei_titleStmt,
    mei_editionStmt?,
    mei_extent?,
    mei_pubStmt,
    mei_seriesStmt?,
    mei_notesStmt?,
    mei_sourceDesc?,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_fingerprint =
  
  ## Contains a string that uniquely identifies an item, such as those constructed by combining groups of characters transcribed from specified pages of a printed item or a file's checksum.
  element fingerprint {
    text,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_foliaDesc =
  
  ## Describes the order of folia and bifolia making up the text block of a manuscript or print.
  element foliaDesc {
    (mei_model.foliumLike
     | mei_model.bifoliumLike
     | mei_del
     | mei_add
     | mei_damage
     | mei_gap
     | mei_restore)*,
    mei_att.common.attributes,
    empty
  }
mei_folium =
  
  ## Describes a single leaf of paper.
  element folium {
    mei_model.paperModLike*,
    mei_att.common.attributes,
    mei_att.dimensions.attributes,
    mei_att.measurement.attributes,
    mei_att.foliumSurfaces.attributes,
    empty
  }
mei_hand =
  
  ## Defines a distinct scribe or handwriting style.
  element hand {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.lang.attributes,
    mei_att.medium.attributes,
    
    ## Marks this hand as the first one of the document.
    attribute initial { mei_data.BOOLEAN }?,
    empty
  }
mei_handList =
  
  ## Container for one or more hand elements.
  element handList {
    mei_model.headLike*,
    ((mei_label?, mei_hand)*)
    >> sch:pattern [
         id = "mei-handList-checkHandListLabels-constraint-rule-67"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:handList[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:hand)"
             "When labels are used,\x{a}" ~
             "            usually each hand has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_history =
  
  ## Provides a container for information about the history of a resource other than the circumstances of its creation.
  element history {
    mei_model.headLike*,
    ((mei_acquisition
      | mei_provenance
      | mei_model.divLike
      | mei_model.textComponentLike)*)
    >> sch:pattern [
         id = "mei-history-history_restriction-constraint-rule-68"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:history[parent::mei:work or parent::mei:expression]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(mei:acquisition or mei:provenance)"
             "The acquisition and provenance\x{a}" ~
             "            elements are not permitted in the work or expression context."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_incipCode =
  
  ## Incipit coded in a non-XML, plain text format, such as Plaine & Easie Code.
  element incipCode {
    text
    >> sch:pattern [
         id =
           "mei-incipCode-Check_incipCode_form_mimetype-constraint-rule-69"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:incipCode"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@form or @mimetype"
             "incipCode must have a form or mimetype\x{a}" ~
             "            attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.internetMedia.attributes,
    mei_att.pointing.attributes,
    mei_att.whitespace.attributes,
    
    ## Form of the encoded incipit.
    ## Suggested values include: 1] plaineAndEasie; 2] humdrumKern; 3] parsons
    attribute form {
      
      ## Plaine & Easie Code.
      "plaineAndEasie"
      | 
        ## Humdrum Kern format.
        "humdrumKern"
      | 
        ## Parsons code.
        "parsons"
      | xsd:NMTOKEN
    }?,
    empty
  }
mei_incipText =
  
  ## Opening words of a musical composition.
  element incipText {
    mei_model.headLike*,
    (mei_model.pLike | mei_model.lgLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.pointing.attributes,
    mei_att.internetMedia.attributes,
    empty
  }
mei_inscription =
  
  ## An inscription added to an item, such as a bookplate, a note designating the item as a gift, and/or the author's signature.
  element inscription {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_interpretation =
  
  ## Describes the scope of any analytic or interpretive information added to the transcription of the music.
  element interpretation {
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_key =
  
  ## Key captures information about tonal center and mode.
  element key {
    text,
    mei_att.common.attributes,
    mei_att.accidental.attributes,
    mei_att.bibl.attributes,
    mei_att.pitch.attributes,
    
    ## Indicates major, minor, or other tonality.
    attribute mode { mei_data.MODE }?,
    empty
  }
mei_language =
  
  ## Description of a language used in the document.
  element language {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_langUsage =
  
  ## (language usage)  Groups elements describing the languages, sub-languages, dialects, etc., represented within the encoded resource.
  element langUsage {
    mei_model.headLike*,
    mei_language+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    empty
  }
mei_meiHead =
  
  ## (MEI header)  Supplies the descriptive and declarative metadata prefixed to every MEI-conformant text.
  element meiHead {
    mei_altId*,
    mei_fileDesc,
    mei_encodingDesc?,
    mei_workList?,
    mei_manifestationList?,
    mei_extMeta*,
    (mei_revisionDesc?)
    >> sch:pattern [
         id = "mei-meiHead-check_meiHead_type-constraint-rule-70"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meiHead[@type eq 'music']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:mei"
             "The meiHead type attribute can have the value 'music'\x{a}" ~
             '            only when the document element is "mei".'
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-meiHead-check_meiHead_type-constraint-rule-71"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meiHead[@type eq 'corpus']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:meiCorpus"
             "The meiHead type attribute can have the value\x{a}" ~
             """            'corpus' only when the document element is "meiCorpus"."""
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-meiHead-check_meiHead_type-constraint-rule-72"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:meiHead[@type eq 'independent']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(ancestor::mei:*)"
             "The meiHead type attribute can have the value\x{a}" ~
             """            'independent' only when the document element is "meiHead"."""
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.basic.attributes,
    mei_att.bibl.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.meiVersion.attributes,
    mei_att.responsibility.attributes,
    
    ## Specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.
    attribute type {
      
      ## Header is attached to a music document.
      "music"
      | 
        ## Header is attached to a corpus.
        "corpus"
      | 
        ## Header is independent; i.e., not attached to either a music or a corpus document.
        "independent"
    }?,
    empty
  }
mei_mensuration =
  
  ## Captures information about mensuration within bibliographic descriptions.
  element mensuration {
    text,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.mensur.log.attributes,
    empty
  }
mei_meter =
  
  ## Captures information about the time signature within bibliographic descriptions.
  element meter {
    text,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.meterSig.log.attributes,
    empty
  }
mei_namespace =
  
  ## Supplies the formal name of the namespace to which the elements documented by its children belong.
  element namespace {
    mei_desc?,
    (mei_tagUsage+ | mei_attUsage+),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    
    ## Formal namespace identifier; that is, a uniform resource identifier (URI).
    attribute name { mei_data.URI },
    
    ## Prefix associated with the formal identifier.
    attribute prefix { mei_data.NMTOKEN }?,
    empty
  }
mei_normalization =
  
  ## Indicates the extent of normalization or regularization of the original source carried out in converting it to electronic form.
  element normalization {
    mei_model.headLike*,
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    mei_att.regularMethod.attributes,
    empty
  }
mei_notesStmt =
  
  ## (notes statement) Collects any notes providing information about a text additional to that recorded in other parts of the bibliographic description.
  element notesStmt {
    mei_model.headLike*,
    mei_model.annotLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_otherChar =
  
  ## (other distinguishing characteristic)  Any characteristic that serves to differentiate a work or expression from another.
  element otherChar {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_patch =
  
  ## Describes a physical writing surface attached to the original document.
  element patch {
    (mei_model.foliumLike | mei_model.bifoliumLike)
    >> sch:pattern [
         id = "mei-patch-check_attached_position-constraint-rule-73"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:patch"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "(parent::mei:folium and @attached.to = ('recto','verso')) or              (parent::mei:bifolium and @attached.to = ('outer.recto','inner.verso','inner.recto','outer.verso'))"
             "The allowed positions of a patch depend on its parent element."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(child::node()) gt 0"
             "A patch element must contain either a folium\x{a}" ~
             "            or a bifolium element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.evidence.attributes,
    mei_att.measurement.attributes,
    mei_att.trans.attributes,
    mei_att.xy.attributes,
    
    ## Describes the position of the patch on the parent folium / bifolium.
    attribute attached.to {
      
      ## patch attached to outer recto side of bifolium.
      "outer.recto"
      | 
        ## patch attached to inner verso side of bifolium.
        "inner.verso"
      | 
        ## patch attached to inner recto side of bifolium.
        "inner.recto"
      | 
        ## patch attached to outer verso side of bifolium.
        "outer.verso"
      | 
        ## patch attached to recto side of folium.
        "recto"
      | 
        ## patch attached to verso side of folium.
        "verso"
    },
    
    ## Describes the method of attachment of the patch.
    ## Suggested values include: 1] glue; 2] thread; 3] needle; 4] tape; 5] staple
    attribute attached.by {
      
      ## patch is glued on surface beneath.
      "glue"
      | 
        ## patch is sewn on surface beneath.
        "thread"
      | 
        ## patch is pinned to the surface beneath.
        "needle"
      | 
        ## patch is taped on surface beneath using an adhesive strip.
        "tape"
      | 
        ## patch is attached on surface beneath using a staple.
        "staple"
      | xsd:NMTOKEN
    }?,
    empty
  }
mei_perfDuration =
  
  ## (performance duration)  Used to express the duration of performance of printed or manuscript music or the playing time for a sound recording, videorecording, etc.
  element perfDuration {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Holds a W3C duration value, e.g., "PT2H34M45.67S".
    attribute isodur { xsd:duration }?,
    empty
  }
mei_perfMedium =
  
  ## (performance medium)  Indicates the number and character of the performing forces used in a musical composition.
  element perfMedium {
    mei_model.headLike*,
    mei_castList?,
    mei_perfResList?,
    mei_model.annotLike*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_perfRes =
  
  ## (performance resource)  Name of an instrument on which a performer plays, a performer's voice range, or a standard performing ensemble designation.
  element perfRes {
    (text | mei_model.textPhraseLike.limited | mei_perfRes)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.lang.attributes,
    
    ## Indicates the number of performers.
    attribute count { xsd:positiveInteger }?,
    
    ## Marks this instrument or vocal part as a soloist. Do not use this attribute for a solo instrument which is not accompanied.
    attribute solo { mei_data.BOOLEAN }?,
    empty
  }
mei_perfResList =
  
  ## Several instrumental or vocal resources treated as a group.
  element perfResList {
    mei_model.headLike*,
    (mei_annot | mei_perfRes | mei_perfResList)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.lang.attributes,
    
    ## Indicates the number of performers.
    attribute count { xsd:positiveInteger }?,
    empty
  }
mei_physDesc =
  
  ## (physical description)  Container for information about the appearance, construction, or handling of physical materials, such as their dimension, quantity, color, style, and technique of creation.
  element physDesc {
    mei_model.headLike*,
    mei_model.pLike*,
    mei_model.physDescPart*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_physMedium =
  
  ## (physical medium)  Records the physical materials used in the source, such as ink and paper.
  element physMedium {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_plateNum =
  
  ## (plate number)  Designation assigned to a resource by a music publisher, usually printed at the bottom of each page, and sometimes appearing also on the title page.
  element plateNum {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_playingSpeed =
  
  ## Playing speed for a sound recording is the speed at which the carrier must be operated to produce the sound intended (e.g., 33 1/3 rpm, 19 cm/s, etc.).
  element playingSpeed {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_price =
  
  ## The cost of access to a bibliographic item.
  element price {
    mei_model.headLike*,
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Numeric value capturing a cost. Can only be interpreted in combination with the currency attribute.
    attribute amount {
      xsd:decimal { pattern = "[0-9]+\.[0-9]{2}" }
    }?,
    
    ## Monetary unit.
    attribute currency { xsd:NMTOKEN }?,
    empty
  }
mei_projectDesc =
  
  ## (project description)  Project-level meta-data describing the aim or purpose for which the electronic file was encoded, funding agencies, etc. together with any other relevant information concerning the process by which it was assembled or collected.
  element projectDesc {
    mei_model.headLike*,
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_provenance =
  
  ## The record of ownership or custodianship of an item.
  element provenance {
    ((mei_model.headLike*, (mei_eventList | mei_model.pLike)*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_pubStmt =
  
  ## (publication statement)  Container for information regarding the publication or distribution of a bibliographic item, including the publisher's name and address, the date of publication, and other relevant details.
  element pubStmt {
    mei_model.headLike*,
    (mei_unpub? | mei_model.pubStmtPart*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_revisionDesc =
  
  ## (revision description)  Container for information about alterations that have been made to an MEI file.
  element revisionDesc {
    mei_model.headLike*,
    mei_change+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_samplingDecl =
  
  ## (sampling declaration)  Contains a prose description of the rationale and methods used in sampling texts in the creation of a corpus or collection.
  element samplingDecl {
    mei_model.headLike*,
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_scoreFormat =
  
  ## Describes the type of score used to represent a musical composition (e.g., short score, full score, condensed score, close score, etc.).
  element scoreFormat {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_segmentation =
  
  ## Describes the principles according to which the musical text has been segmented, for example into movements, sections, etc.
  element segmentation {
    mei_model.headLike*,
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_seriesStmt =
  
  ## (series statement)  Groups information about the series, if any, to which a publication belongs.
  element seriesStmt {
    mei_model.headLike*,
    mei_model.titleLike+,
    (mei_model.respLikePart | mei_respStmt)*,
    (mei_model.identifierLike
     | mei_biblScope
     | mei_contents
     | mei_seriesStmt)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_soundChan =
  
  ## (sound channels)  Reflects the number of apparent sound channels in the playback of a recording (monaural, stereophonic, quadraphonic, etc.).
  element soundChan {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Records the channel configuration in numeric form.
    attribute num { xsd:positiveInteger }?,
    empty
  }
mei_source =
  
  ## A bibliographic description of a source used in the creation of the electronic file.
  element source {
    mei_model.headLike*,
    (mei_locus | mei_locusGrp)*,
    (mei_model.biblLike*)
    >> sch:pattern [
         id = "mei-source-check_source_target-constraint-rule-74"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:source/@target"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@target attribute should\x{a}" ~
             "            have content."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test =
               "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name()              eq 'source' or local-name() eq 'manifestation']/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')"
             "Each value in @target should correspond to the @xml:id attribute of a source or\x{a}" ~
             "            manifestation element or be an external URI."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.componentType.attributes,
    mei_att.dataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.recordType.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_sourceDesc =
  
  ## (source description)  A container for the descriptions of the source(s) used in the creation of the electronic file.
  element sourceDesc {
    mei_model.headLike*, mei_source+, mei_att.common.attributes, empty
  }
mei_specRepro =
  
  ## (special reproduction characteristic)  The equalization system, noise reduction system, etc. used in making the recording (e.g., NAB, DBX, Dolby, etc.).
  element specRepro {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_stdVals =
  
  ## (standard values)  Specifies the format used when standardized date or number values are supplied.
  element stdVals {
    mei_model.headLike*,
    mei_model.pLike+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_sysReq =
  
  ## (system requirements)  System requirements for using the electronic item.
  element sysReq {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_tagsDecl =
  
  ## (tagging declaration)  Provides detailed information about the tagging applied to a document.
  element tagsDecl {
    mei_model.headLike*,
    mei_desc?,
    mei_namespace*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_tagUsage =
  
  ## Documents the usage of a specific element within the document.
  element tagUsage {
    mei_desc?,
    (mei_attUsage*)
    >> sch:pattern [
         id =
           "mei-tagUsage-context_attribute_requires_content-constraint-rule-75"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "@context"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@context attribute should\x{a}" ~
             "            contain an XPath expression."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    
    ## Name of the element.
    attribute name { mei_data.NMTOKEN },
    
    ## Circumstances in which the element appears, an XPath expression.
    attribute context { xsd:string }?,
    
    ## Number of occurrences in the defined context.
    attribute occurs { xsd:nonNegativeInteger }?,
    
    ## Number of occurrences in the defined context that have an xml:id attribute.
    attribute withid { xsd:nonNegativeInteger }?,
    empty
  }
mei_taxonomy =
  
  ## Defines a typology either implicitly, by means of a bibliographic citation, or explicitly by a structured taxonomy.
  element taxonomy {
    mei_model.headLike*,
    mei_model.biblLike?,
    mei_desc*,
    (mei_category | mei_taxonomy)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_termList =
  
  ## Collection of text phrases which describe a resource.
  element termList {
    mei_model.headLike*,
    ((mei_label?, mei_term)*)
    >> sch:pattern [
         id = "mei-termList-checkTermListLabels-constraint-rule-76"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:termList[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:term)"
             "When labels are used,\x{a}" ~
             "            usually each term has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.pointing.attributes,
    empty
  }
mei_titleStmt =
  
  ## (title statement)  Container for title and responsibility meta-data.
  element titleStmt {
    mei_model.headLike*,
    mei_model.titleLike+,
    mei_model.respLike*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_trackConfig =
  
  ## (track configuration)  Number of physical/input tracks on a sound medium (e.g., eight track, twelve track).
  element trackConfig {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Records the track configuration in numeric form.
    attribute num { xsd:positiveInteger }?,
    empty
  }
mei_treatHist =
  
  ## (treatment history)  A record of the treatment the item has undergone (e.g., de-acidification, restoration, etc.).
  element treatHist {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_treatSched =
  
  ## (treatment scheduled)  Scheduled treatment, e.g. de-acidification, restoration, etc., for an item.
  element treatSched {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_unpub =
  
  ## (unpublished)  Used to explicitly indicate that a bibliographic resource is unpublished.
  element unpub {
    text,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_useRestrict =
  
  ## (usage restrictions)  Container for information about the conditions that affect use of a bibliographic item after access has been granted.
  element useRestrict {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_watermark =
  
  ## Contains a description of a watermark or similar device.
  element watermark {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_work =
  
  ## Provides a detailed description of a work  a distinct intellectual or artistic creation  specifically its history, language use, and high-level musical attributes (e.g., key, tempo, meter, medium of performance, and intended duration).
  element work {
    mei_model.headLike*,
    mei_model.identifierLike*,
    mei_model.titleLike+,
    mei_model.respLikePart*,
    mei_model.workIdent*,
    mei_otherChar*,
    mei_creation?,
    mei_history?,
    mei_langUsage?,
    mei_perfMedium?,
    mei_perfDuration?,
    mei_audience?,
    mei_contents?,
    mei_context?,
    mei_biblList*,
    mei_notesStmt?,
    mei_classification?,
    mei_expressionList?,
    mei_componentList?,
    mei_relationList?,
    mei_extMeta*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_workList =
  
  ## (work list)  Grouping mechanism for information describing non-bibliographic aspects of a text.
  element workList {
    mei_model.headLike*, mei_work+, mei_att.common.attributes, empty
  }
mei_att.lyrics.log.attributes =
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes
mei_att.refrain.log.attributes = empty
mei_att.verse.log.attributes = empty
mei_att.volta.log.attributes = empty
mei_model.verseLike = mei_refrain | mei_verse
mei_model.verseLike_alternation = mei_refrain | mei_verse
mei_model.verseLike_sequence = mei_refrain, mei_verse
mei_model.verseLike_sequenceOptional = mei_refrain?, mei_verse?
mei_model.verseLike_sequenceOptionalRepeatable =
  mei_refrain*, mei_verse*
mei_model.verseLike_sequenceRepeatable = mei_refrain+, mei_verse+
mei_refrain =
  
  ## Recurring lyrics, especially at the end of each verse or stanza of a poem or song lyrics; a chorus.
  element refrain {
    (mei_dir | mei_dynam | mei_tempo | mei_space)*,
    (mei_volta | mei_model.sylLike | mei_model.appLike)+,
    mei_model.lbLike*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.refrain.log.attributes,
    mei_att.refrain.vis.attributes,
    mei_att.refrain.ges.attributes,
    mei_att.refrain.anl.attributes,
    empty
  }
mei_verse =
  
  ## Division of a poem or song lyrics, sometimes having a fixed length, meter or rhyme scheme; a stanza.
  element verse {
    mei_label*,
    mei_labelAbbr*,
    (mei_dir | mei_dynam | mei_tempo | mei_space)*,
    (mei_volta | mei_model.sylLike | mei_model.appLike)+,
    mei_model.lbLike*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.verse.log.attributes,
    mei_att.verse.vis.attributes,
    mei_att.verse.ges.attributes,
    mei_att.verse.anl.attributes,
    empty
  }
mei_volta =
  
  ## Sung text for a specific iteration of a repeated section of music.
  element volta {
    (mei_dir | mei_dynam | mei_tempo | mei_space)*,
    (mei_model.sylLike | mei_model.appLike)+,
    mei_model.lbLike*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.volta.log.attributes,
    mei_att.volta.vis.attributes,
    mei_att.volta.ges.attributes,
    mei_att.volta.anl.attributes,
    empty
  }
mei_att.channelized.attributes =
  mei_att.channelized.attribute.midi.channel,
  mei_att.channelized.attribute.midi.duty,
  mei_att.channelized.attribute.midi.port,
  mei_att.channelized.attribute.midi.track
mei_att.channelized.attribute.midi.channel =
  
  ## Records a MIDI channel value.
  attribute midi.channel { mei_data.MIDICHANNEL }?
mei_att.channelized.attribute.midi.duty =
  
  ## Specifies the 'on' part of the duty cycle as a percentage of a note's duration.
  attribute midi.duty { mei_data.PERCENT.LIMITED }?
mei_att.channelized.attribute.midi.port =
  
  ## Sets the MIDI port value.
  attribute midi.port { mei_data.MIDIVALUE_NAME }?
mei_att.channelized.attribute.midi.track =
  
  ## Sets the MIDI track.
  attribute midi.track { xsd:positiveInteger }?
mei_att.instrDef.log.attributes = empty
mei_att.instrumentIdent.attributes =
  mei_att.instrumentIdent.attribute.instr
mei_att.instrumentIdent.attribute.instr =
  
  ## Provides a way of pointing to a MIDI instrument definition. It must contain the ID of an instrDef element elsewhere in the document.
  attribute instr { mei_data.URI }?
sch:pattern [
  id =
    "mei-att.instrumentIdent-instr-check_instrTarget-constraint-rule-77"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@instr"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@instr attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:instrDef/@xml:id"
      "The value in @instr should correspond to the @xml:id attribute of an instrDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.midi.event.attributes =
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes,
  mei_att.timestamp.logical.attributes,
  mei_att.timestamp.gestural.attributes
mei_att.midi.log.attributes =
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes
mei_att.midiInstrument.attributes =
  mei_att.midiInstrument.attribute.midi.instrnum,
  mei_att.midiInstrument.attribute.midi.instrname,
  mei_att.midiInstrument.attribute.midi.pan,
  mei_att.midiInstrument.attribute.midi.patchname,
  mei_att.midiInstrument.attribute.midi.patchnum,
  mei_att.midiInstrument.attribute.midi.volume
mei_att.midiInstrument.attribute.midi.instrnum =
  
  ## Captures the General MIDI instrument number. Use an integer for a 0-based value. An integer preceded by "in" indicates a 1-based value.
  attribute midi.instrnum { mei_data.MIDIVALUE }?
mei_att.midiInstrument.attribute.midi.instrname =
  
  ## Provides a General MIDI label for the MIDI instrument.
  attribute midi.instrname { mei_data.MIDINAMES }?
mei_att.midiInstrument.attribute.midi.pan =
  
  ## Sets the instrument's position in a stereo field. MIDI values of 0 and 1 both pan left, 127 or 128 pans right, and 63 or 64 pans to the center. Positve percentage values pan to the right, negative ones to the left. 0% is centered.
  attribute midi.pan { mei_data.MIDIVALUE_PAN }?
mei_att.midiInstrument.attribute.midi.patchname =
  
  ## Records a non-General MIDI patch/instrument name.
  attribute midi.patchname { xsd:NMTOKEN }?
mei_att.midiInstrument.attribute.midi.patchnum =
  
  ## Records a non-General MIDI patch/instrument number.
  attribute midi.patchnum { mei_data.MIDIVALUE }?
mei_att.midiInstrument.attribute.midi.volume =
  
  ## Sets the instrument's volume.
  attribute midi.volume { text }?
sch:pattern [
  id =
    "mei-att.midiInstrument-One_of_instrname_or_instrnum-constraint-rule-78"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@midi.instrname]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "not(@midi.instrnum)"
      "Only one of @midi.instrname and @midi.instrnum\x{a}" ~
      "            allowed."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id =
    "mei-att.midiInstrument-One_of_patchname_or_patchnum-constraint-rule-79"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@midi.patchname]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "not(@midi.patchnum)"
      "Only one of @midi.patchname and @midi.patchnum\x{a}" ~
      "            allowed."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
mei_att.midiNumber.attributes = mei_att.midiNumber.attribute.num
mei_att.midiNumber.attribute.num =
  
  ## MIDI number in the range set by data.MIDIVALUE.
  attribute num { mei_data.MIDIVALUE }
mei_att.midiTempo.attributes =
  mei_att.midiTempo.attribute.midi.bpm,
  mei_att.midiTempo.attribute.midi.mspb
mei_att.midiTempo.attribute.midi.bpm =
  
  ## Captures the number of *quarter notes* per minute. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*.
  attribute midi.bpm { mei_data.MIDIBPM }?
mei_att.midiTempo.attribute.midi.mspb =
  
  ## Records the number of microseconds per *quarter note*. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*. At 120 quarter notes per minute, each quarter note will last 500,000 microseconds.
  attribute midi.mspb { mei_data.MIDIMSPB }?
mei_att.midiValue.attributes = mei_att.midiValue.attribute.val
mei_att.midiValue.attribute.val =
  
  ## MIDI number.
  attribute val { mei_data.MIDIVALUE }?
mei_att.midiValue2.attributes = mei_att.midiValue2.attribute.val2
mei_att.midiValue2.attribute.val2 =
  
  ## MIDI number.
  attribute val2 { mei_data.MIDIVALUE }?
mei_att.midiVelocity.attributes = mei_att.midiVelocity.attribute.vel
mei_att.midiVelocity.attribute.vel =
  
  ## MIDI Note-on/off velocity.
  attribute vel { mei_data.MIDIVALUE }?
mei_att.timeBase.attributes = mei_att.timeBase.attribute.ppq
mei_att.timeBase.attribute.ppq =
  
  ## Indicates the number of pulses (sometimes referred to as ticks or divisions) per quarter note. Unlike MIDI, MEI permits different values for a score and individual staves.
  attribute ppq { xsd:positiveInteger }?
mei_model.midiLike = mei_midi
mei_cc =
  
  ## (control change)  MIDI parameter/control change.
  element cc {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    mei_att.midiValue.attributes,
    empty
  }
mei_chan =
  
  ## (channel)  MIDI channel assignment.
  element chan {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    
    ## MIDI number in the range set by data.MIDICHANNEL.
    attribute num { mei_data.MIDICHANNEL },
    empty
  }
mei_chanPr =
  
  ## (channel pressure)  MIDI channel pressure/after touch.
  element chanPr {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    empty
  }
mei_cue =
  
  ## MIDI cue point.
  element cue {
    text,
    mei_att.common.attributes,
    mei_att.lang.attributes,
    mei_att.midi.event.attributes,
    empty
  }
mei_hex =
  
  ## Arbitrary MIDI data in hexadecimal form.
  element hex {
    text,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    empty
  }
mei_instrDef =
  
  ## (instrument definition)  MIDI instrument declaration.
  element instrDef {
    empty,
    mei_att.common.attributes,
    mei_att.instrDef.anl.attributes,
    mei_att.instrDef.ges.attributes,
    mei_att.instrDef.log.attributes,
    mei_att.instrDef.vis.attributes,
    empty
  }
mei_instrGrp =
  
  ## (instrument group)  Collects MIDI instrument definitions.
  element instrGrp {
    mei_model.instrDefLike+, mei_att.common.attributes, empty
  }
mei_marker =
  
  ## MIDI marker meta-event.
  element marker {
    text,
    mei_att.common.attributes,
    mei_att.lang.attributes,
    mei_att.midi.event.attributes,
    empty
  }
mei_metaText =
  
  ## MIDI text meta-event.
  element metaText {
    text,
    mei_att.common.attributes,
    mei_att.lang.attributes,
    mei_att.midi.event.attributes,
    empty
  }
mei_midi =
  
  ## Container for elements that contain information useful when generating MIDI output.
  element midi {
    (mei_cc
     | mei_chan
     | mei_chanPr
     | mei_cue
     | mei_hex
     | mei_marker
     | mei_metaText
     | mei_noteOff
     | mei_noteOn
     | mei_port
     | mei_prog
     | mei_seqNum
     | mei_trkName
     | mei_vel)*,
    mei_att.common.attributes,
    mei_att.midi.log.attributes,
    mei_att.midi.vis.attributes,
    mei_att.midi.ges.attributes,
    mei_att.midi.anl.attributes,
    empty
  }
mei_noteOff =
  
  ## MIDI note-off event.
  element noteOff {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    empty
  }
mei_noteOn =
  
  ## MIDI note-on event.
  element noteOn {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    empty
  }
mei_port =
  
  ## MIDI port.
  element port {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    empty
  }
mei_prog =
  
  ## (program)  MIDI program change.
  element prog {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    empty
  }
mei_seqNum =
  
  ## (sequence number)  MIDI sequence number.
  element seqNum {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    
    ## Number in the range 0-65535.
    attribute num {
      xsd:nonNegativeInteger { maxInclusive = "65535" }
    },
    empty
  }
mei_trkName =
  
  ## (track name)  MIDI track/sequence name.
  element trkName {
    text,
    mei_att.common.attributes,
    mei_att.lang.attributes,
    mei_att.midi.event.attributes,
    empty
  }
mei_vel =
  
  ## (velocity)  MIDI Note-on/off velocity.
  element vel {
    empty,
    mei_att.common.attributes,
    mei_att.midi.event.attributes,
    mei_att.midiNumber.attributes,
    
    ## Indicates whether this is note-on or note-off velocity data.
    attribute form {
      
      ## Note-on velocity.
      "on"
      | 
        ## Note-off velocity.
        "off"
    },
    empty
  }
mei_att.componentType.attributes =
  mei_att.componentType.attribute.comptype
mei_att.componentType.attribute.comptype =
  
  ##
  attribute comptype {
    
    ## A physical and logical part of entity.
    "constituent"
    | 
      ## A physical, but not logical component of the entity, usually included as part of the binding process.
      "boundwith"
    | 
      ## A logical component of the entity physically held elsewhere.
      "separated"
  }?
sch:pattern [
  id =
    "mei-att.componentType-comptype-checkComponentType-constraint-rule-80"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@comptype]"
    "\x{a}" ~
    "              "
    sch:let [ name = "elementName" value = "local-name()" ]
    "\x{a}" ~
    "              "
    sch:assert [
      test = "ancestor::mei:componentList"
      "The comptype attribute may occur on\x{a}" ~
      "                "
      sch:value-of [ select = "$elementName" ]
      " only when it is a descendant of a\x{a}" ~
      "                componentList."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_model.msInline =
  mei_fingerprint
  | mei_watermark
  | mei_catchwords
  | mei_heraldry
  | mei_locus
  | mei_locusGrp
  | mei_secFolio
  | mei_signatures
  | mei_stamp
mei_model.msInline_alternation =
  mei_fingerprint
  | mei_watermark
  | mei_catchwords
  | mei_heraldry
  | mei_locus
  | mei_locusGrp
  | mei_secFolio
  | mei_signatures
  | mei_stamp
mei_model.msInline_sequence =
  mei_fingerprint,
  mei_watermark,
  mei_catchwords,
  mei_heraldry,
  mei_locus,
  mei_locusGrp,
  mei_secFolio,
  mei_signatures,
  mei_stamp
mei_model.msInline_sequenceOptional =
  mei_fingerprint?,
  mei_watermark?,
  mei_catchwords?,
  mei_heraldry?,
  mei_locus?,
  mei_locusGrp?,
  mei_secFolio?,
  mei_signatures?,
  mei_stamp?
mei_model.msInline_sequenceOptionalRepeatable =
  mei_fingerprint*,
  mei_watermark*,
  mei_catchwords*,
  mei_heraldry*,
  mei_locus*,
  mei_locusGrp*,
  mei_secFolio*,
  mei_signatures*,
  mei_stamp*
mei_model.msInline_sequenceRepeatable =
  mei_fingerprint+,
  mei_watermark+,
  mei_catchwords+,
  mei_heraldry+,
  mei_locus+,
  mei_locusGrp+,
  mei_secFolio+,
  mei_signatures+,
  mei_stamp+
mei_accMat =
  
  ## Holds a description of any additional material bound with an item, such as non-contemporaneous documents or fragments.
  element accMat {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_addDesc =
  
  ## (addition description)  Provides a description of significant additions found within an item, such as marginalia or other annotations.
  element addDesc {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_binding =
  
  ## (binding)  Contains a description of one binding, i.e. type of covering, boards, etc. applied to an item.
  element binding {
    mei_head*,
    (mei_condition | mei_decoNote | mei_dimensions | mei_p)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.lang.attributes,
    
    ##
    attribute contemporary { mei_data.BOOLEAN }?,
    empty
  }
mei_bindingDesc =
  
  ## (binding description)  Describes the present and former bindings of an item.
  element bindingDesc {
    mei_head*,
    ((mei_binding*, (mei_condition | mei_decoNote | mei_p)*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_catchwords =
  
  ## Describes the system used to ensure correct ordering of the quires making up an item, typically by means of annotations at the foot of the page.
  element catchwords {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_collation =
  
  ## Records a description of how the leaves or bifolia of an item are physically arranged.
  element collation {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_colophon =
  
  ## Contains a statement providing information regarding the date, place, agency, or reason for production of the item.
  element colophon {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_decoDesc =
  
  ## (decoration description)  Contains a description of the decoration of an item.
  element decoDesc {
    ((mei_head*, (mei_condition | mei_decoNote | mei_p)*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_decoNote =
  
  ## (decoration note)  Contains a description of one or more decorative features of an item.
  element decoNote {
    ((mei_head*, (mei_condition | mei_decoNote | mei_p)*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_explicit =
  
  ## Contains the explicit of a manuscript item; that is, the closing words of the text proper, exclusive of any rubric or colophon which might follow it.
  element explicit {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_foliation =
  
  ## Describes the numbering system or systems used to count the leaves or pages in a codex.
  element foliation {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_heraldry =
  
  ## Contains a heraldic formula or phrase, typically found as part of a blazon, coat of arms, etc.
  element heraldry {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_layout =
  
  ## Describes how text is laid out on the page, including information about any ruling, pricking, or other evidence of page-preparation techniques.
  element layout {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Specifies the number of columns per page.
    attribute cols {
      list { xsd:nonNegativeInteger, xsd:nonNegativeInteger? }
    }?,
    
    ## Specifies the number of ruled text lines per column.
    attribute ruledlines {
      list { xsd:nonNegativeInteger, xsd:nonNegativeInteger? }
    }?,
    
    ## Specifies the number of written text lines per column.
    attribute writtenlines {
      list { xsd:nonNegativeInteger, xsd:nonNegativeInteger? }
    }?,
    
    ## Specifies the number of ruled staves per column.
    attribute ruledstaves {
      list { xsd:nonNegativeInteger, xsd:nonNegativeInteger? }
    }?,
    
    ## Specifies the number of written staves per column.
    attribute writtenstaves {
      list { xsd:nonNegativeInteger, xsd:nonNegativeInteger? }
    }?,
    empty
  }
mei_layoutDesc =
  
  ## (layout description)  Collects layout descriptions.
  element layoutDesc {
    ((mei_head*, (mei_p | mei_layout)*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_locus =
  
  ## Defines a location within a manuscript or manuscript component, usually as a (possibly discontinuous) sequence of folio references.
  element locus {
    (text | mei_locus | mei_rend | mei_symbol)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Identifies the foliation scheme in terms of which the location is being specified by pointing to some foliation element defining it, or to some other equivalent resource.
    attribute scheme { mei_data.URI }?,
    
    ## Specifies the starting point of the location in a normalized form.
    attribute from { mei_data.WORD }?,
    
    ## Specifies the end-point of the location in a normalized form.
    attribute to { mei_data.WORD }?,
    empty
  }
mei_locusGrp =
  
  ## (locus group)  Groups locations which together form a distinct but discontinuous item within a manuscript or manuscript part, according to a specific foliation.
  element locusGrp {
    mei_locus*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Identifies the foliation scheme in terms of which the location is being specified by pointing to some foliation element defining it, or to some other equivalent resource.
    attribute scheme { mei_data.URI }?,
    empty
  }
mei_rubric =
  
  ## Contains a string of words through which a manuscript signals the beginning or end of a text division, often with an assertion as to its author and title, which is in some way set off from the text itself, usually in red ink, or by use of different size or type of script, or some other such visual device.
  element rubric {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ##
    attribute func {
      
      ## Signals beginning of a text division.
      "initial"
      | 
        ## Makrs the end of a text division.
        "final"
    }?,
    empty
  }
mei_scriptDesc =
  
  ## (script description)  Contains a description of the letters or characters used in an autographic item.
  element scriptDesc {
    ((mei_head*, mei_p*, mei_scriptNote*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_scriptNote =
  
  ## (script note)  Describes a particular script distinguished within the description of an autographic item.
  element scriptNote {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_seal =
  
  ## A single seal or similar attachment.
  element seal {
    ((mei_head*, (mei_condition | mei_decoNote | mei_p)*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.lang.attributes,
    
    ##
    attribute contemporary { mei_data.BOOLEAN }?,
    empty
  }
mei_sealDesc =
  
  ## (seal description)  Describes the seals or similar external attachments applied to an item.
  element sealDesc {
    ((mei_head*,
      (mei_seal* | (mei_condition | mei_decoNote | mei_p)*))
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_secFolio =
  
  ## (second folio)  Marks the word or words taken from a fixed point in a codex (typically the beginning of the second leaf) in order to provide a unique identifier for the item.
  element secFolio {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_signatures =
  
  ## Provides a description of the leaf or quire signatures found within a codex.
  element signatures {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_stamp =
  
  ## Contains a word or phrase describing an official mark indicating ownership, genuineness, validity, etc.
  element stamp {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_support =
  
  ## Provides a description of the physical support material of a written item.
  element support {
    mei_head*,
    (mei_condition | mei_decoNote | mei_dimensions | mei_p)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_supportDesc =
  
  ## (support description)  Groups elements describing the physical support material of an item.
  element supportDesc {
    ((mei_head*,
      (mei_p*
       | (mei_support?,
          mei_foliation?,
          mei_collation?,
          mei_condition?)))
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    
    ## Short, project-defined name for the material composing the majority of the support.
    ## Suggested values include: 1] paper; 2] parch; 3] mixed
    attribute material {
      
      ## Paper.
      "paper"
      | 
        ## Parchment.
        "parch"
      | 
        ## Mixed materials.
        "mixed"
      | xsd:NMTOKEN
    }?,
    empty
  }
mei_typeDesc =
  
  ## (type description)  Contains a description of the typefaces or other aspects of the printing of a printed source.
  element typeDesc {
    ((mei_head*, mei_p*, mei_typeNote*)
     | (text | mei_model.textPhraseLike.limited)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_typeNote =
  
  ## (type note)  Describes a particular font or other significant typographic feature of a printed resource.
  element typeNote {
    mei_macro.struc-unstrucContent,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_model.addressPart =
  mei_model.geogNamePart | mei_postBox | mei_postCode | mei_street
mei_model.addressPart_alternation =
  mei_model.geogNamePart_alternation
  | mei_postBox
  | mei_postCode
  | mei_street
mei_model.addressPart_sequence =
  mei_model.geogNamePart_sequence, mei_postBox, mei_postCode, mei_street
mei_model.addressPart_sequenceOptional =
  mei_model.geogNamePart_sequenceOptional?,
  mei_postBox?,
  mei_postCode?,
  mei_street?
mei_model.addressPart_sequenceOptionalRepeatable =
  mei_model.geogNamePart_sequenceOptionalRepeatable*,
  mei_postBox*,
  mei_postCode*,
  mei_street*
mei_model.addressPart_sequenceRepeatable =
  mei_model.geogNamePart_sequenceRepeatable+,
  mei_postBox+,
  mei_postCode+,
  mei_street+
mei_model.geogNamePart =
  mei_bloc
  | mei_country
  | mei_district
  | mei_geogFeat
  | mei_region
  | mei_settlement
mei_model.geogNamePart_alternation =
  mei_bloc
  | mei_country
  | mei_district
  | mei_geogFeat
  | mei_region
  | mei_settlement
mei_model.geogNamePart_sequence =
  mei_bloc,
  mei_country,
  mei_district,
  mei_geogFeat,
  mei_region,
  mei_settlement
mei_model.geogNamePart_sequenceOptional =
  mei_bloc?,
  mei_country?,
  mei_district?,
  mei_geogFeat?,
  mei_region?,
  mei_settlement?
mei_model.geogNamePart_sequenceOptionalRepeatable =
  mei_bloc*,
  mei_country*,
  mei_district*,
  mei_geogFeat*,
  mei_region*,
  mei_settlement*
mei_model.geogNamePart_sequenceRepeatable =
  mei_bloc+,
  mei_country+,
  mei_district+,
  mei_geogFeat+,
  mei_region+,
  mei_settlement+
mei_model.nameLike.agent = mei_corpName | mei_persName
mei_model.nameLike.agent_alternation = mei_corpName | mei_persName
mei_model.nameLike.agent_sequence = mei_corpName, mei_persName
mei_model.nameLike.agent_sequenceOptional = mei_corpName?, mei_persName?
mei_model.nameLike.agent_sequenceOptionalRepeatable =
  mei_corpName*, mei_persName*
mei_model.nameLike.agent_sequenceRepeatable =
  mei_corpName+, mei_persName+
mei_model.nameLike.geogName = mei_geogName
mei_model.nameLike.geogName_alternation = mei_geogName
mei_model.nameLike.geogName_sequence = mei_geogName
mei_model.nameLike.geogName_sequenceOptional = mei_geogName?
mei_model.nameLike.geogName_sequenceOptionalRepeatable = mei_geogName*
mei_model.nameLike.geogName_sequenceRepeatable = mei_geogName+
mei_model.nameLike.label = mei_periodName | mei_styleName
mei_model.nameLike.label_alternation = mei_periodName | mei_styleName
mei_model.nameLike.label_sequence = mei_periodName, mei_styleName
mei_model.nameLike.label_sequenceOptional =
  mei_periodName?, mei_styleName?
mei_model.nameLike.label_sequenceOptionalRepeatable =
  mei_periodName*, mei_styleName*
mei_model.nameLike.label_sequenceRepeatable =
  mei_periodName+, mei_styleName+
mei_model.nameLike.place =
  mei_model.nameLike.geogName | mei_model.repositoryLike
mei_model.nameLike.place_alternation =
  mei_model.nameLike.geogName_alternation
  | mei_model.repositoryLike_alternation
mei_model.nameLike.place_sequence =
  mei_model.nameLike.geogName_sequence,
  mei_model.repositoryLike_sequence
mei_model.nameLike.place_sequenceOptional =
  mei_model.nameLike.geogName_sequenceOptional?,
  mei_model.repositoryLike_sequenceOptional?
mei_model.nameLike.place_sequenceOptionalRepeatable =
  mei_model.nameLike.geogName_sequenceOptionalRepeatable*,
  mei_model.repositoryLike_sequenceOptionalRepeatable*
mei_model.nameLike.place_sequenceRepeatable =
  mei_model.nameLike.geogName_sequenceRepeatable+,
  mei_model.repositoryLike_sequenceRepeatable+
mei_model.persNamePart =
  mei_addName
  | mei_famName
  | mei_foreName
  | mei_genName
  | mei_nameLink
  | mei_roleName
mei_addName =
  
  ## (additional name)  Contains an additional name component, such as a nickname, epithet, or alias, or any other descriptive phrase used within a personal name.
  element addName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_bloc =
  
  ## Contains the name of a geopolitical unit consisting of two or more nation states or countries.
  element bloc {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_corpName =
  
  ## (corporate name)  Identifies an organization or group of people that acts as a single entity.
  element corpName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_country =
  
  ## Contains the name of a geopolitical unit, such as a nation, country, colony, or commonwealth, larger than or administratively superior to a region and smaller than a bloc.
  element country {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_district =
  
  ## Contains the name of any kind of subdivision of a settlement, such as a parish, ward, or other administrative or geographic unit.
  element district {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_famName =
  
  ## (family name)  Contains a family (inherited) name, as opposed to a given, baptismal, or nick name.
  element famName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_nameLink)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_foreName =
  
  ## Contains a forename, given or baptismal name.
  element foreName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_genName =
  
  ## (generational name component)  Contains a name component used to distinguish otherwise similar names on the basis of the relative ages or generations of the persons named.
  element genName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_geogFeat =
  
  ## (geographical feature name)  Contains a common noun identifying a geographical feature.
  element geogFeat {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_geogName =
  
  ## (geographic name)  The proper noun designation for a place, natural feature, or political jurisdiction.
  element geogName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_nameLink =
  
  ## (name link)  Contains a connecting phrase or link used within a name but not regarded as part of it, such as "van der" or "of", "from", etc.
  element nameLink {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_periodName =
  
  ## (period name)  A label that describes a period of time, such as 'Baroque' or '3rd Style period'.
  element periodName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_persName =
  
  ## (personal name)  Designation for an individual, including any or all of that individual's forenames, surnames, honorific titles, and added names.
  element persName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_model.persNamePart)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_postBox =
  
  ## (postal box or post office box) contains a number or other identifier for some postal delivery point other than a street address.
  element postBox {
    (text | mei_model.editLike | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_postCode =
  
  ## (postal code) contains a numerical or alphanumeric code used as part of a postal address to simplify sorting or delivery of mail.
  element postCode {
    (text | mei_model.editLike | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_region =
  
  ## Contains the name of an administrative unit such as a state, province, or county, larger than a settlement, but smaller than a country.
  element region {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_roleName =
  
  ## (role name)  Contains a name component which indicates that the referent has a particular role or position in society, such as an official title or rank.
  element roleName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_settlement =
  
  ## Contains the name of a settlement such as a city, town, or village identified as a single geopolitical or administrative unit.
  element settlement {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_street =
  
  ## full street address including any name or number identifying a building as well as the name of the street or route on which it is located.
  element street {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_styleName =
  
  ## (style name)  A label for a characteristic style of writing or performance, such as 'bebop' or 'rock-n-roll'.
  element styleName {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_att.alignment.attributes = mei_att.alignment.attribute.when
mei_att.alignment.attribute.when =
  
  ## Indicates the point of occurrence of this feature along a time line. Its value must be the ID of a when element elsewhere in the document.
  attribute when { mei_data.URI }?
sch:pattern [
  id = "mei-att.alignment-check_whenTarget-constraint-rule-81"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@when"
    "\x{a}" ~
    "          "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@when attribute should\x{a}" ~
      "            have content."
    ]
    "\x{a}" ~
    "          "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:when/@xml:id"
      "A\x{a}" ~
      "            value in @when should correspond to the @xml:id attribute of a when\x{a}" ~
      "            element."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
mei_avFile =
  
  ## (audio/video file)  References an external digital audio or video file.
  element avFile {
    (mei_clip*)
    >> sch:pattern [
         id = "mei-avFile-avFile_child_of_clip-constraint-rule-82"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:clip/mei:avFile"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:*) = 0"
             "An avFile child of clip cannot have\x{a}" ~
             "            children."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.internetMedia.attributes,
    mei_att.facsimile.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    empty
  }
mei_clip =
  
  ## Defines a time segment of interest within a recording or within a digital audio or video file.
  element clip {
    mei_avFile*,
    (mei_when*)
    >> sch:pattern [
         id =
           "mei-clip-betype_required_when_begin_or_end-constraint-rule-83"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:clip[@begin or @end]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "@betype or ancestor::mei:*[@betype]"
             "When @begin or @end\x{a}" ~
             "            is used, @betype should appear on clip or one of its ancestors."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.dataPointing.attributes,
    mei_att.mediaBounds.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.startId.attributes,
    empty
  }
mei_performance =
  
  ## A presentation of one or more musical works.
  element performance {
    mei_recording*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_recording =
  
  ## A recorded performance.
  element recording {
    mei_avFile*,
    mei_when*,
    (mei_clip*)
    >> sch:pattern [
         id =
           "mei-recording-betype_required_when_begin_or_end-constraint-rule-84"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:recording[@begin or @end]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "@betype"
             "When @begin or @end is used, @betype should be\x{a}" ~
             "            present."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.dataPointing.attributes,
    mei_att.mediaBounds.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.startId.attributes,
    empty
  }
mei_when =
  
  ## Indicates a point in time either absolutely (using the absolute attribute), or relative to another when element (using the since, interval and inttype attributes).
  element when {
    empty
    >> sch:pattern [
         id = "mei-when-check_when_interval-constraint-rule-85"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:when[@interval]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@since"
             "@since must be present when @interval is used."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test =
               "every $i in tokenize(@since, '\s+') satisfies substring($i,2)=//mei:when/@xml:id"
             "The value in @since should correspond to the @xml:id attribute of a when\x{a}" ~
             "            element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-when-check_when_interval-constraint-rule-86"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:when[matches(@interval, '^[0-9]+$')]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(@inttype eq 'time')"
             "When @interval contains an integer value,\x{a}" ~
             "            @inttype cannot be 'time'."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-when-check_when_interval-constraint-rule-87"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:when[matches(@interval, ':')]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@inttype eq 'time'"
             "When @interval contains a time value, @inttype must\x{a}" ~
             "            be 'time'."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-when-check_when_absolute-constraint-rule-88"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:when[@absolute]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "@abstype or ancestor::mei:*[@betype]"
             "When @absolute is\x{a}" ~
             "            present, @abstype should be present or @betype should be present on an\x{a}" ~
             "            ancestor."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.dataPointing.attributes,
    
    ## Provides an absolute value for the time point.
    attribute absolute { text }?,
    
    ## Specifies the time interval between this time point and the one designated by the since attribute. This attribute can only be interpreted meaningfully in conjunction with the inttype attribute.
    attribute interval {
      xsd:decimal { minInclusive = "1" }
      | xsd:time
    }?,
    
    ## Specifies the kind of values used in the absolute attribute.
    attribute abstype { mei_data.BETYPE }?,
    
    ## Specifies the kind of values used in the interval attribute.
    attribute inttype { mei_data.BETYPE }?,
    (
     ## Identifies the reference point for determining the time of the current when element, which is obtained by adding the interval to the time of the reference point. The value should be the ID of another when element within the same parent element. If the since attribute is omitted and the absolute attribute is not specified, then the reference point is understood to be the immediately preceding when element.
     attribute since { mei_data.URI }?)
    >> sch:pattern [
         id = "mei-when-since-check_sinceTarget-constraint-rule-89"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "@since"
           "\x{a}" ~
           "              "
           sch:assert [
             role = "warning"
             test = "not(normalize-space(.) eq '')"
             "@since attribute\x{a}" ~
             "                should have content."
           ]
           "\x{a}" ~
           "              "
           sch:assert [
             role = "warning"
             test =
               "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:when/@xml:id"
             "The value in @since should correspond to the @xml:id attribute of a when\x{a}" ~
             "                element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    empty
  }
mei_model.locrefLike = mei_ptr | mei_ref
mei_model.locrefLike_alternation = mei_ptr | mei_ref
mei_model.locrefLike_sequence = mei_ptr, mei_ref
mei_model.locrefLike_sequenceOptional = mei_ptr?, mei_ref?
mei_model.locrefLike_sequenceOptionalRepeatable = mei_ptr*, mei_ref*
mei_model.locrefLike_sequenceRepeatable = mei_ptr+, mei_ref+
mei_ptr =
  
  ## (pointer)  Defines a traversible pointer to another location, using only attributes to describe the destination.
  element ptr {
    empty,
    mei_att.common.attributes,
    mei_att.internetMedia.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_ref =
  
  ## (reference)  Defines a traversible reference to another location. May contain text and sub-elements that describe the destination.
  element ref {
    (text | mei_model.textPhraseLike)*,
    mei_att.common.attributes,
    mei_att.internetMedia.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_att.accid.log.attributes =
  mei_att.accidental.attributes,
  mei_att.controlEvent.attributes,
  mei_att.accid.log.attribute.func
mei_att.accid.log.attribute.func =
  
  ## Records the function of an accidental.
  attribute func {
    
    ## Cautionary accidental.
    "caution"
    | 
      ## Editorial accidental.
      "edit"
  }?
mei_att.accidental.attributes = mei_att.accidental.attribute.accid
mei_att.accidental.attribute.accid =
  
  ## Captures a written accidental.
  attribute accid { mei_data.ACCIDENTAL.WRITTEN }?
mei_att.ambitus.anl.attributes = mei_att.intervalHarmonic.attributes
mei_att.ambitus.ges.attributes = empty
mei_att.ambitus.log.attributes = empty
mei_att.ambitus.vis.attributes = empty
mei_att.ambNote.log.attributes =
  mei_att.accidental.attributes,
  mei_att.coloration.attributes,
  mei_att.duration.logical.attributes,
  mei_att.pitched.attributes
mei_att.anchoredText.anl.attributes = empty
mei_att.anchoredText.ges.attributes = empty
mei_att.anchoredText.vis.attributes =
  mei_att.visualOffset.attributes, mei_att.xy.attributes
mei_att.annot.log.attributes =
  mei_att.alignment.attributes,
  mei_att.duration.additive.attributes,
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp.logical.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.artic.log.attributes =
  mei_att.articulation.attributes, mei_att.controlEvent.attributes
mei_att.articulation.attributes = mei_att.articulation.attribute.artic
mei_att.articulation.attribute.artic =
  
  ## Encodes the written articulation(s). Articulations are normally encoded in order from the note head outward; that is, away from the stem. See additional notes at att.vis.note. Only articulations should be encoded in the artic attribute; for example, fingerings should be encoded using the fing element.
  attribute artic {
    list { mei_data.ARTICULATION+ }
  }?
mei_att.attacca.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.attacca.log.attribute.target
mei_att.attacca.log.attribute.target =
  
  ## Indicates the next section or movement to be performed.
  attribute target { mei_data.URI }?
sch:pattern [
  id =
    "mei-att.attacca.log-target-check_attaccaTarget-constraint-rule-90"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:attacca/@target"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@target attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name()                    eq 'section' or local-name() eq 'mdiv']/@xml:id"
      "The value in @target should correspond to the @xml:id attribute of a section or\x{a}" ~
      "                mdiv element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.audience.attributes = mei_att.audience.attribute.audience
mei_att.audience.attribute.audience =
  
  ## The intended audience.
  attribute audience {
    
    ## Internal use only.
    "private"
    | 
      ## Available to all audiences.
      "public"
  }?
mei_att.augmentDots.attributes = mei_att.augmentDots.attribute.dots
mei_att.augmentDots.attribute.dots =
  
  ## Records the number of augmentation dots required by a written dotted duration.
  attribute dots { mei_data.AUGMENTDOT }?
sch:pattern [
  id =
    "mei-att.augmentDots-dots-dots_attribute_requires_dur-constraint-rule-91"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@dots]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@dur"
      "An element with a dots attribute must also have a dur\x{a}" ~
      "                attribute."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.authorized.attributes =
  mei_att.canonical.attributes,
  mei_att.authorized.attribute.auth,
  mei_att.authorized.attribute.auth.uri
mei_att.authorized.attribute.auth =
  
  ## A name or label associated with a controlled vocabulary or other authoritative source for this element or its content.
  attribute auth { xsd:string }?
mei_att.authorized.attribute.auth.uri =
  
  ## A web-accessible location of the controlled vocabulary or other authoritative source of identification or definition for this element or its content. This attribute may contain a complete URI or a partial URI which is completed by the value of the codedval attribute.
  attribute auth.uri { mei_data.URI }?
mei_att.barLine.log.attributes =
  mei_att.meterConformance.bar.attributes,
  mei_att.barLine.log.attribute.form
mei_att.barLine.log.attribute.form =
  
  ## Records the appearance and usually the function of the bar line.
  attribute form { mei_data.BARRENDITION }?
mei_att.barring.attributes =
  mei_att.barring.attribute.bar.len,
  mei_att.barring.attribute.bar.method,
  mei_att.barring.attribute.bar.place
mei_att.barring.attribute.bar.len =
  
  ## States the length of barlines in virtual units. The value must be greater than 0 and is typically equal to 2 times (the number of staff lines - 1); e.g., a value of '8' for a 5-line staff.
  attribute bar.len {
    xsd:decimal { minExclusive = "0" }
  }?
mei_att.barring.attribute.bar.method =
  
  ## Records the method of barring.
  attribute bar.method { mei_data.BARMETHOD }?
sch:pattern [
  id = "mei-att.barring-bar.method-check_barmethod-constraint-rule-92"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "@bar.method[parent::*[matches(local-name(), '(staffDef|measure)')]]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "not(. eq 'mensur')"
      '"mensur" not allowed in this\x{a}' ~
      "                context."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.barring.attribute.bar.place =
  
  ## Denotes the staff location of bar lines, if the length is non-standard; that is, not equal to 2 times (the number of staff lines - 1).
  attribute bar.place { mei_data.STAFFLOC }?
mei_att.basic.attributes =
  mei_att.id.attributes, mei_att.basic.attribute.xmlbase
mei_att.basic.attribute.xmlbase =
  
  ## Provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
  attribute xml:base { mei_data.URI }?
mei_att.bibl.attributes = mei_att.bibl.attribute.analog
mei_att.bibl.attribute.analog =
  
  ## Contains a reference to a field or element in another descriptive encoding system to which this MEI element is comparable.
  attribute analog { xsd:string }?
mei_att.caesura.log.attributes =
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.staffIdent.attributes,
  mei_att.startId.attributes,
  mei_att.timestamp.logical.attributes
mei_att.calendared.attributes = mei_att.calendared.attribute.calendar
mei_att.calendared.attribute.calendar =
  
  ## Indicates the calendar system to which a date belongs, for example, Gregorian, Julian, Roman, Mosaic, Revolutionary, Islamic, etc.
  attribute calendar { xsd:NMTOKEN }?
mei_att.canonical.attributes = mei_att.canonical.attribute.codedval
mei_att.canonical.attribute.codedval =
  
  ## A value that represents or identifies other data. Often, it is a primary key in the database or a unique value in the coded list identified by the auth or auth.uri attributes.
  attribute codedval {
    list { xsd:NMTOKEN+ }
  }?
mei_att.chord.log.attributes =
  mei_att.articulation.attributes,
  mei_att.augmentDots.attributes,
  mei_att.chord.log.cmn.attributes,
  mei_att.cue.attributes,
  mei_att.duration.logical.attributes,
  mei_att.event.attributes,
  mei_att.sylText.attributes
mei_att.classed.attributes = mei_att.classed.attribute.class
mei_att.classed.attribute.class =
  
  ## Contains one or more URIs which denote classification terms that apply to the entity bearing this attribute.
  attribute class {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.classed-class-check_classURI-constraint-rule-93"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@class"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:category/@xml:id or matches($i, '^([a-z]+://|\.{1,2}/)')"
      "The value in @class must either correspond to the @xml:id attribute of a category\x{a}" ~
      "                element or be an external URL."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.clef.log.attributes =
  mei_att.clefShape.attributes,
  mei_att.lineLoc.attributes,
  mei_att.octave.attributes,
  mei_att.octaveDisplacement.attributes,
  mei_att.clef.log.attribute.cautionary
mei_att.clef.log.attribute.cautionary =
  
  ## Records the function of the clef. A "cautionary" clef does not change the following pitches.
  attribute cautionary { mei_data.BOOLEAN }?
mei_att.cleffing.log.attributes =
  mei_att.cleffing.log.attribute.clef.shape,
  mei_att.cleffing.log.attribute.clef.line,
  mei_att.cleffing.log.attribute.clef.dis,
  mei_att.cleffing.log.attribute.clef.dis.place
mei_att.cleffing.log.attribute.clef.shape =
  
  ## Encodes a value for the clef symbol.
  attribute clef.shape { mei_data.CLEFSHAPE }?
mei_att.cleffing.log.attribute.clef.line =
  
  ## Contains a default value for the position of the clef. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
  attribute clef.line { mei_data.CLEFLINE }?
mei_att.cleffing.log.attribute.clef.dis =
  
  ## Records the amount of octave displacement to be applied to the clef.
  attribute clef.dis { mei_data.OCTAVE.DIS }?
mei_att.cleffing.log.attribute.clef.dis.place =
  
  ## Records the direction of octave displacement to be applied to the clef.
  attribute clef.dis.place { mei_data.STAFFREL.basic }?
sch:pattern [
  id =
    "mei-att.cleffing.log-clef_shape_requires_clef_line-constraint-rule-94"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[matches(@clef.shape, '[FCG]')]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "@clef.line"
      "An 'F', 'C', or 'G' clef requires that its position be\x{a}" ~
      "            specified."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id =
    "mei-att.cleffing.log-clef_shape_requires_clef_line-constraint-rule-95"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[matches(@clef.shape, '(TAB|perc)')]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "@lines"
      "A TAB or percussion clef requires that the number of lines be\x{a}" ~
      "            specified."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
mei_att.clefGrp.log.attributes = empty
mei_att.clefShape.attributes = mei_att.clefShape.attribute.shape
mei_att.clefShape.attribute.shape =
  
  ## Describes a clef's shape.
  attribute shape { mei_data.CLEFSHAPE }?
sch:pattern [
  id = "mei-att.clefShape-shape_requires_line-constraint-rule-96"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:clef[matches(@shape, '[FCG]')]"
    "\x{a}" ~
    "          "
    sch:assert [
      test = "@line"
      "When @shape is present, @line must also be\x{a}" ~
      "            specified."
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "   "
]
mei_att.color.attributes = mei_att.color.attribute.color
mei_att.color.attribute.color =
  
  ## Used to indicate visual appearance. Do not confuse this with the musical term 'color' as used in pre-CMN notation.
  attribute color { mei_data.COLOR }?
mei_att.coloration.attributes = mei_att.coloration.attribute.colored
mei_att.coloration.attribute.colored =
  
  ## Indicates this feature is 'colored'; that is, it is a participant in a change in rhythmic values. In mensural notation, coloration is indicated by colored notes (red, black, etc.) where void notes would otherwise occur. In CMN, coloration is indicated by an inverse color; that is, the note head is void when it would otherwise be filled and vice versa.
  attribute colored { mei_data.BOOLEAN }?
mei_att.common.attributes =
  mei_att.basic.attributes,
  mei_att.labelled.attributes,
  mei_att.linking.attributes,
  mei_att.nNumberLike.attributes,
  mei_att.responsibility.attributes,
  mei_att.typed.attributes
mei_att.controlEvent.attributes =
  mei_att.alignment.attributes,
  mei_att.layerIdent.attributes,
  mei_att.partIdent.attributes,
  mei_att.plist.attributes,
  mei_att.staffIdent.attributes,
  mei_att.targetEval.attributes,
  mei_att.timestamp.logical.attributes,
  mei_att.timestamp.gestural.attributes
mei_att.coordinated.attributes =
  mei_att.coordinated.attribute.ulx,
  mei_att.coordinated.attribute.uly,
  mei_att.coordinated.attribute.lrx,
  mei_att.coordinated.attribute.lry
mei_att.coordinated.attribute.ulx =
  
  ## Indicates the upper-left corner x coordinate.
  attribute ulx { xsd:nonNegativeInteger }?
mei_att.coordinated.attribute.uly =
  
  ## Indicates the upper-left corner y coordinate.
  attribute uly { xsd:nonNegativeInteger }?
mei_att.coordinated.attribute.lrx =
  
  ## Indicates the lower-right corner x coordinate.
  attribute lrx { xsd:nonNegativeInteger }?
mei_att.coordinated.attribute.lry =
  
  ## Indicates the lower-left corner x coordinate.
  attribute lry { xsd:nonNegativeInteger }?
mei_att.cue.attributes = mei_att.cue.attribute.cue
mei_att.cue.attribute.cue =
  
  ##
  attribute cue { mei_data.BOOLEAN }?
mei_att.curvature.attributes =
  mei_att.curvature.attribute.bezier,
  mei_att.curvature.attribute.bulge,
  mei_att.curvature.attribute.curvedir
mei_att.curvature.attribute.bezier =
  
  ## Records the placement of Bezier control points as a series of pairs of space-separated values; e.g., 19 45 -32 118.
  attribute bezier {
    list { (xsd:decimal, xsd:decimal)+ }
  }?
mei_att.curvature.attribute.bulge =
  
  ## Describes a curve as one or more pairs of values with respect to an imaginary line connecting the starting and ending points of the curve. The first value captures a distance to the left (positive value) or right (negative value) of the line, expressed in virtual units. The second value of each pair represents a point along the line, expressed as a percentage of the line's length. N.B. An MEI virtual unit (VU) is half the distance between adjacent staff lines.
  attribute bulge {
    list { (xsd:decimal, mei_data.PERCENT)+ }
  }?
mei_att.curvature.attribute.curvedir =
  
  ## Describes a curve with a generic term indicating the direction of curvature.
  attribute curvedir {
    
    ## Upward curve.
    "above"
    | 
      ## Downward curve.
      "below"
    | 
      ## A "meandering" curve, both above and below the items it pertains to.
      "mixed"
  }?
mei_att.curveRend.attributes =
  mei_att.curveRend.attribute.lform, mei_att.curveRend.attribute.lwidth
mei_att.curveRend.attribute.lform =
  
  ## Describes the line style of a curve.
  attribute lform { mei_data.LINEFORM }?
mei_att.curveRend.attribute.lwidth =
  
  ## Width of a curved line.
  attribute lwidth { mei_data.LINEWIDTH }?
mei_att.custos.log.attributes =
  mei_att.pitched.attributes, mei_att.custos.log.attribute.target
mei_att.custos.log.attribute.target =
  
  ## Encodes the target note when its pitch differs from the pitch at which the custos appears.
  attribute target { mei_data.URI }?
sch:pattern [
  id = "mei-att.custos.log-target-check_custosTarget-constraint-rule-97"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:custos/@target"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@target attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:note/@xml:id"
      "The value in @target should correspond to the @xml:id attribute of a note\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.datable.attributes =
  mei_att.datable.attribute.enddate,
  mei_att.datable.attribute.isodate,
  mei_att.datable.attribute.notafter,
  mei_att.datable.attribute.notbefore,
  mei_att.datable.attribute.startdate
mei_att.datable.attribute.enddate =
  
  ## Contains the end point of a date range in standard ISO form.
  attribute enddate { mei_data.ISODATE }?
mei_att.datable.attribute.isodate =
  
  ## Provides the value of a textual date in standard ISO form.
  attribute isodate { mei_data.ISODATE }?
mei_att.datable.attribute.notafter =
  
  ## Contains an upper boundary for an uncertain date in standard ISO form.
  attribute notafter { mei_data.ISODATE }?
mei_att.datable.attribute.notbefore =
  
  ## Contains a lower boundary, in standard ISO form, for an uncertain date.
  attribute notbefore { mei_data.ISODATE }?
mei_att.datable.attribute.startdate =
  
  ## Contains the starting point of a date range in standard ISO form.
  attribute startdate { mei_data.ISODATE }?
mei_att.dataPointing.attributes = mei_att.dataPointing.attribute.data
mei_att.dataPointing.attribute.data =
  
  ## Used to link metadata elements to one or more data-containing elements.
  attribute data {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.dataPointing-data-check_dataTarget-constraint-rule-98"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@data"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@data attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:music]/@xml:id"
      "The value in @data should correspond to the @xml:id attribute of a descendant of\x{a}" ~
      "                the music element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.mdiv.log.attributes = mei_att.alignment.attributes
mei_att.metadataPointing.attributes =
  mei_att.metadataPointing.attribute.decls
mei_att.metadataPointing.attribute.decls =
  
  ## Identifies one or more metadata elements (other than classification terms) within the header, which are understood to apply to the element bearing this attribute and its content.
  attribute decls {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id =
    "mei-att.metadataPointing-decls-check_declsTarget-constraint-rule-99"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@decls"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@decls attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
      "Each value in @decls should correspond to the @xml:id attribute of an element\x{a}" ~
      "                within the metadata header."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "every $i in tokenize(., '\s+') satisfies not(substring($i,2)=//mei:term/@xml:id)"
      "No value in @decls should correspond to the @xml:id attribute of a classification\x{a}" ~
      "                term. Use @class for this purpose."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.dimensions.attributes =
  mei_att.height.attributes, mei_att.width.attributes
mei_att.dir.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.distances.attributes =
  mei_att.distances.attribute.dynam.dist,
  mei_att.distances.attribute.harm.dist,
  mei_att.distances.attribute.text.dist
mei_att.distances.attribute.dynam.dist =
  
  ## Records the default distance from the staff for dynamic marks.
  attribute dynam.dist { mei_data.MEASUREMENTREL }?
mei_att.distances.attribute.harm.dist =
  
  ## Records the default distance from the staff of harmonic indications, such as guitar chord grids or functional labels.
  attribute harm.dist { mei_data.MEASUREMENTREL }?
mei_att.distances.attribute.text.dist =
  
  ## Determines how far from the staff to render text elements.
  attribute text.dist { mei_data.MEASUREMENTREL }?
mei_att.dot.log.attributes =
  mei_att.controlEvent.attributes, mei_att.dot.log.attribute.form
mei_att.dot.log.attribute.form =
  
  ## Records the function of the dot.
  attribute form {
    
    ## Augmentation dot.
    "aug"
    | 
      ## Dot of division.
      "div"
  }?
mei_att.duration.additive.attributes =
  mei_att.duration.additive.attribute.dur
mei_att.duration.additive.attribute.dur =
  
  ## When a duration cannot be represented as a single power-of-two value, multiple space-separated values that add up to the total duration may be used.
  attribute dur {
    list { mei_data.DURATION+ }
  }?
mei_att.duration.default.attributes =
  mei_att.duration.default.attribute.dur.default,
  mei_att.duration.default.attribute.num.default,
  mei_att.duration.default.attribute.numbase.default
mei_att.duration.default.attribute.dur.default =
  
  ## Contains a default duration in those situations when the first note, rest, chord, etc. in a measure does not have a duration specified.
  attribute dur.default { mei_data.DURATION }?
mei_att.duration.default.attribute.num.default =
  
  ## Along with numbase.default, describes the default duration as a ratio. num.default is the first value in the ratio.
  attribute num.default { xsd:positiveInteger }?
mei_att.duration.default.attribute.numbase.default =
  
  ## Along with num.default, describes the default duration as a ratio. numbase.default is the second value in the ratio.
  attribute numbase.default { xsd:positiveInteger }?
mei_att.duration.logical.attributes =
  mei_att.duration.logical.attribute.dur
mei_att.duration.logical.attribute.dur =
  
  ## Records the duration of a feature using the relative durational values provided by the data.DURATION datatype.
  attribute dur { mei_data.DURATION }?
mei_att.duration.ratio.attributes =
  mei_att.duration.ratio.attribute.num,
  mei_att.duration.ratio.attribute.numbase
mei_att.duration.ratio.attribute.num =
  
  ## Along with numbase, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
  attribute num { xsd:positiveInteger }?
mei_att.duration.ratio.attribute.numbase =
  
  ## Along with num, describes duration as a ratio. num is the first value in the ratio, while numbase is the second.
  attribute numbase { xsd:positiveInteger }?
mei_att.dynam.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.enclosingChars.attributes =
  mei_att.enclosingChars.attribute.enclose
mei_att.enclosingChars.attribute.enclose =
  
  ## Records the characters often used to mark accidentals, articulations, and sometimes notes as having a cautionary or editorial function. For an example of cautionary accidentals enclosed in parentheses, see Read, p. 131, ex. 9-14.
  attribute enclose { mei_data.ENCLOSURE }?
mei_att.ending.log.attributes = mei_att.alignment.attributes
mei_att.endings.attributes = mei_att.endings.attribute.ending.rend
mei_att.endings.attribute.ending.rend =
  
  ## Describes where ending marks should be displayed.
  attribute ending.rend {
    
    ## Ending rendered only above top staff.
    "top"
    | 
      ## Ending rendered above staves that have bar lines drawn across them.
      "barred"
    | 
      ## Endings rendered above staff groups.
      "grouped"
  }?
mei_att.event.attributes =
  mei_att.alignment.attributes,
  mei_att.layerIdent.attributes,
  mei_att.staffIdent.attributes,
  mei_att.timestamp.gestural.attributes,
  mei_att.timestamp.logical.attributes
mei_att.evidence.attributes =
  mei_att.evidence.attribute.cert, mei_att.evidence.attribute.evidence
mei_att.evidence.attribute.cert =
  
  ## Signifies the degree of certainty or precision associated with a feature.
  attribute cert { mei_data.CERTAINTY }?
mei_att.evidence.attribute.evidence =
  
  ## Indicates the nature of the evidence supporting the reliability or accuracy of the intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    
    ## There is evidence within the document to support the intervention.
    "internal"
    | 
      ## There is evidence outside the document to support the intervention.
      "external"
    | 
      ## The assertion has been made by the editor, cataloguer, or scholar on the basis of their expertise.
      "conjecture"
    | xsd:NMTOKEN
  }?
mei_att.extender.attributes =
  mei_att.lineRend.attributes, mei_att.extender.attribute.extender
mei_att.extender.attribute.extender =
  
  ## Indicates the presence of an extension symbol, typically a line.
  attribute extender { mei_data.BOOLEAN }?
mei_att.extent.attributes =
  mei_att.measurement.attributes,
  mei_att.ranging.attributes,
  mei_att.extent.attribute.extent
mei_att.extent.attribute.extent =
  
  ## Captures a measurement, count, or description. When extent contains a numeric value, use the unit attribute to indicate the measurement unit.
  attribute extent { xsd:string }?
sch:pattern [
  id = "mei-att.extent-extent-check_extent-constraint-rule-100"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@extent[matches(normalize-space(.), '^\d+(\.\d+)?$')]"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "../@unit"
      "The @unit attribute is\x{a}" ~
      "                recommended."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id = "mei-att.extent-extent-check_extent-constraint-rule-101"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@extent[matches(., '\d+(\.\d+)?\s')]"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "../@unit"
      "Separation into value (@extent) and unit\x{a}" ~
      "                (@unit) is recommended."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.fermataPresent.attributes =
  mei_att.fermataPresent.attribute.fermata
mei_att.fermataPresent.attribute.fermata =
  
  ## Indicates the attachment of a fermata to this element. If visual information about the fermata needs to be recorded, then a fermata element should be employed instead.
  attribute fermata { mei_data.STAFFREL.basic }?
mei_att.filing.attributes = mei_att.filing.attribute.nonfiling
mei_att.filing.attribute.nonfiling =
  
  ## Holds the number of initial characters (such as those constituting an article or preposition) that should not be used for sorting a title or name.
  attribute nonfiling { xsd:positiveInteger }?
mei_att.grpSym.log.attributes =
  mei_att.staffGroupingSym.attributes,
  mei_att.startEndId.attributes,
  mei_att.grpSym.log.attribute.level
mei_att.grpSym.log.attribute.level =
  
  ## Indicates the nesting level of staff grouping symbols.
  attribute level { xsd:positiveInteger }?
mei_att.handIdent.attributes = mei_att.handIdent.attribute.hand
mei_att.handIdent.attribute.hand =
  
  ## Signifies the hand responsible for an action. The value must be the ID of a hand element declared in the header.
  attribute hand { mei_data.URI }?
sch:pattern [
  id = "mei-att.handIdent-hand-check_handTarget-constraint-rule-102"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@hand"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@hand attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:hand/@xml:id"
      "Each value in @hand should correspond to the @xml:id attribute of a hand\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.height.attributes = mei_att.height.attribute.height
mei_att.height.attribute.height =
  
  ## Measurement of the vertical dimension of an entity.
  attribute height { mei_data.MEASUREMENTABS }?
mei_att.horizontalAlign.attributes =
  mei_att.horizontalAlign.attribute.halign
mei_att.horizontalAlign.attribute.halign =
  
  ## Records horizontal alignment.
  attribute halign { mei_data.HORIZONTALALIGNMENT }?
mei_att.id.attributes = mei_att.id.attribute.xmlid
mei_att.id.attribute.xmlid =
  
  ## Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.
  attribute xml:id { xsd:ID }?
mei_att.internetMedia.attributes =
  mei_att.internetMedia.attribute.mimetype
mei_att.internetMedia.attribute.mimetype =
  
  ## Specifies the applicable MIME (multimedia internet mail extension) type. The value should be a valid MIME media type defined by the Internet Engineering Task Force in RFC 2046.
  attribute mimetype { xsd:string }?
mei_att.joined.attributes = mei_att.joined.attribute.join
mei_att.joined.attribute.join =
  
  ## Used for linking visually separate entities that form a single logical entity, for example, multiple slurs broken across a system break that form a single musical phrase. Also used to indicate a measure which metrically completes the current one. Record the identifiers of the separately encoded components, excluding the one carrying the attribute.
  attribute join {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.joined-join-check_joinTarget-constraint-rule-103"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@join"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@join attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @join should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.keyAccid.log.attributes =
  mei_att.accidental.attributes, mei_att.pitched.attributes
mei_att.keySig.log.attributes = mei_att.keySig.log.attribute.sig
mei_att.keySig.log.attribute.sig =
  
  ## Written key signature.
  attribute sig {
    list { mei_data.KEYFIFTHS+ }
  }?
mei_att.keySigDefault.log.attributes =
  mei_att.keySigDefault.log.attribute.key.sig
mei_att.keySigDefault.log.attribute.key.sig =
  
  ## Written key signature.
  attribute key.sig {
    list { mei_data.KEYFIFTHS+ }
  }?
mei_att.labelled.attributes = mei_att.labelled.attribute.label
mei_att.labelled.attribute.label =
  
  ## Captures text to be used to generate a label for the element to which it's attached, a "tool tip" or prefatory text, for example. Should not be used to record document content.
  attribute label { xsd:string }?
mei_att.lang.attributes =
  mei_att.lang.attribute.xmllang, mei_att.lang.attribute.translit
mei_att.lang.attribute.xmllang =
  
  ## Identifies the language of the element's content. The values for this attribute are language 'tags' as defined in BCP 47. All language tags that make use of private use sub-tags must be documented in a corresponding language element in the MEI header whose id attribute is the same as the language tag's value.
  attribute xml:lang { xsd:language }?
mei_att.lang.attribute.translit =
  
  ## Specifies the transliteration technique used.
  attribute translit { xsd:NMTOKEN }?
mei_att.layer.log.attributes =
  mei_att.meterConformance.attributes, mei_att.layer.log.attribute.def
mei_att.layer.log.attribute.def =
  
  ## Provides a mechanism for linking the layer to a layerDef element.
  attribute def { mei_data.URI }?
sch:pattern [
  id = "mei-att.layer.log-def-check_defTarget_layer-constraint-rule-104"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:layer/@def"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@def attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:layerDef/@xml:id"
      "The value in @def should correspond to the @xml:id attribute of a layerDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.layerDef.log.attributes =
  mei_att.duration.default.attributes,
  mei_att.layerDef.log.cmn.attributes,
  mei_att.octaveDefault.attributes,
  mei_att.transposition.attributes
mei_att.layerIdent.attributes = mei_att.layerIdent.attribute.layer
mei_att.layerIdent.attribute.layer =
  
  ## Identifies the layer to which a feature applies.
  attribute layer {
    list { xsd:positiveInteger+ }
  }?
mei_att.lineLoc.attributes = mei_att.lineLoc.attribute.line
mei_att.lineLoc.attribute.line =
  
  ## Indicates the line upon which a feature stands. The value must be in the range between 1 and the number of lines on the staff. The numbering of lines starts with the lowest line of the staff.
  attribute line { mei_data.CLEFLINE }?
mei_att.lineRend.attributes =
  mei_att.lineRend.base.attributes,
  mei_att.lineRend.attribute.lendsym,
  mei_att.lineRend.attribute.lendsym.size,
  mei_att.lineRend.attribute.lstartsym,
  mei_att.lineRend.attribute.lstartsym.size
mei_att.lineRend.attribute.lendsym =
  
  ## Symbol rendered at end of line.
  attribute lendsym { mei_data.LINESTARTENDSYMBOL }?
mei_att.lineRend.attribute.lendsym.size =
  
  ## Holds the relative size of the line-end symbol.
  attribute lendsym.size { mei_data.FONTSIZESCALE }?
mei_att.lineRend.attribute.lstartsym =
  
  ## Symbol rendered at start of line.
  attribute lstartsym { mei_data.LINESTARTENDSYMBOL }?
mei_att.lineRend.attribute.lstartsym.size =
  
  ## Holds the relative size of the line-start symbol.
  attribute lstartsym.size { mei_data.FONTSIZESCALE }?
mei_att.lineRend.base.attributes =
  mei_att.lineRend.base.attribute.lform,
  mei_att.lineRend.base.attribute.lsegs,
  mei_att.lineRend.base.attribute.lwidth
mei_att.lineRend.base.attribute.lform =
  
  ## Describes the line style of a line.
  attribute lform { mei_data.LINEFORM }?
mei_att.lineRend.base.attribute.lsegs =
  
  ## Describes the number of segments into which a dashed or dotted line may be divided, or the number of "peaks" of a wavy line; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
  attribute lsegs {
    list {
      xsd:positiveInteger { minInclusive = "2" },
      xsd:positiveInteger { minInclusive = "2" }?
    }
  }?
sch:pattern [
  id = "mei-att.lineRend.base-lsegs-check_lsegs-constraint-rule-105"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@lsegs"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "matches(../@lform, '(dashed|dotted|wavy)')"
      "@lform attribute\x{a}" ~
      '                matching "dashed", "dotted", or "wavy" required.'
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.lineRend.base.attribute.lwidth =
  
  ## Width of a line.
  attribute lwidth { mei_data.LINEWIDTH }?
mei_att.linking.attributes =
  mei_att.linking.attribute.copyof,
  mei_att.linking.attribute.corresp,
  mei_att.linking.attribute.follows,
  mei_att.linking.attribute.next,
  mei_att.linking.attribute.precedes,
  mei_att.linking.attribute.prev,
  mei_att.linking.attribute.sameas,
  mei_att.linking.attribute.synch
mei_att.linking.attribute.copyof =
  
  ## Points to an element of which the current element is a copy.
  attribute copyof { mei_data.URI }?
sch:pattern [
  id =
    "mei-att.linking-copyof-When_copyof_element_empty-constraint-rule-106"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@copyof]"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "count(child::*[not(comment() or processing-instruction())]) = 0"
      "An\x{a}" ~
      "                element with a copyof attribute can only have comment or processing instruction\x{a}" ~
      "                descendents."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
sch:pattern [
  id = "mei-att.linking-copyof-check_copyofTarget-constraint-rule-107"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@copyof"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@copyof attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @copyof should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.corresp =
  
  ## Used to point to other elements that correspond to this one in a generic fashion.
  attribute corresp {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.linking-corresp-check_correspTarget-constraint-rule-108"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@corresp"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@corresp attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @corresp should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.follows =
  
  ## points to one or more events in a user-defined collection that are known to be predecessors of the current element.
  attribute follows {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.linking-follows-check_followsTarget-constraint-rule-109"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@follows"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@follows attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @follows must correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.next =
  
  ## Used to point to the next event(s) in a user-defined collection.
  attribute next {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.linking-next-check_nextTarget-constraint-rule-110"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@next"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@next attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @next should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.precedes =
  
  ## Points to one or more events in a user-defined collection that are known to be successors of the current element.
  attribute precedes {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id =
    "mei-att.linking-precedes-check_precedesTarget-constraint-rule-111"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@precedes"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@precedes attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @precedes must correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.prev =
  
  ## Points to the previous event(s) in a user-defined collection.
  attribute prev {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.linking-prev-check_prevTarget-constraint-rule-112"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@prev"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@prev attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @prev should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.sameas =
  
  ## Points to an element that is the same as the current element but is not a literal copy of the current element.
  attribute sameas {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.linking-sameas-check_sameasTarget-constraint-rule-113"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@sameas"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@sameas attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @sameas should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.linking.attribute.synch =
  
  ## Points to elements that are synchronous with the current element.
  attribute synch {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.linking-synch-check_synchTarget-constraint-rule-114"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@synch"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@synch attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @synch should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.lyricStyle.attributes =
  mei_att.lyricStyle.attribute.lyric.align,
  mei_att.lyricStyle.attribute.lyric.fam,
  mei_att.lyricStyle.attribute.lyric.name,
  mei_att.lyricStyle.attribute.lyric.size,
  mei_att.lyricStyle.attribute.lyric.style,
  mei_att.lyricStyle.attribute.lyric.weight
mei_att.lyricStyle.attribute.lyric.align =
  
  ## Describes the alignment of lyric syllables associated with a note or chord.
  attribute lyric.align { mei_data.MEASUREMENTREL }?
mei_att.lyricStyle.attribute.lyric.fam =
  
  ## Sets the font family default value for lyrics.
  attribute lyric.fam { mei_data.FONTFAMILY }?
mei_att.lyricStyle.attribute.lyric.name =
  
  ## Sets the font name default value for lyrics.
  attribute lyric.name { mei_data.FONTNAME }?
mei_att.lyricStyle.attribute.lyric.size =
  
  ## Sets the default font size value for lyrics.
  attribute lyric.size { mei_data.FONTSIZE }?
mei_att.lyricStyle.attribute.lyric.style =
  
  ## Sets the default font style value for lyrics.
  attribute lyric.style { mei_data.FONTSTYLE }?
mei_att.lyricStyle.attribute.lyric.weight =
  
  ## Sets the default font weight value for lyrics.
  attribute lyric.weight { mei_data.FONTWEIGHT }?
mei_att.measurement.attributes = mei_att.measurement.attribute.unit
mei_att.measurement.attribute.unit =
  
  ## Indicates the unit of measurement.
  ## Suggested values include: 1] byte; 2] char; 3] cm; 4] deg; 5] in; 6] issue; 7] ft; 8] m; 9] mm; 10] page; 11] pc; 12] pt; 13] px; 14] rad; 15] record; 16] vol; 17] vu
  attribute unit {
    
    ## Byte.
    "byte"
    | 
      ## Character.
      "char"
    | 
      ## Centimeter.
      "cm"
    | 
      ## Degree.
      "deg"
    | 
      ## Inch.
      "in"
    | 
      ## Serial issue.
      "issue"
    | 
      ## Foot.
      "ft"
    | 
      ## Meter.
      "m"
    | 
      ## Millimeter.
      "mm"
    | 
      ## Page.
      "page"
    | 
      ## Pica.
      "pc"
    | 
      ## Point.
      "pt"
    | 
      ## Pixel.
      "px"
    | 
      ## Radian.
      "rad"
    | 
      ## Record.
      "record"
    | 
      ## Serial volume.
      "vol"
    | 
      ## MEI virtual unit.
      "vu"
    | xsd:NMTOKEN
  }?
mei_att.measureNumbers.attributes =
  mei_att.measureNumbers.attribute.mnum.visible
mei_att.measureNumbers.attribute.mnum.visible =
  
  ## Indicates whether measure numbers should be displayed.
  attribute mnum.visible { mei_data.BOOLEAN }?
mei_att.mediaBounds.attributes =
  mei_att.mediaBounds.attribute.begin,
  mei_att.mediaBounds.attribute.end,
  mei_att.mediaBounds.attribute.betype
mei_att.mediaBounds.attribute.begin =
  
  ## Specifies a point where the relevant content begins. A numerical value must be less and a time value must be earlier than that given by the end attribute.
  attribute begin { text }?
mei_att.mediaBounds.attribute.end =
  
  ## Specifies a point where the relevant content ends. If not specified, the end of the content is assumed to be the end point. A numerical value must be greater and a time value must be later than that given by the begin attribute.
  attribute end { text }?
mei_att.mediaBounds.attribute.betype =
  
  ## Type of values used in the begin/end attributes. The begin and end attributes can only be interpreted meaningfully in conjunction with this attribute.
  attribute betype { mei_data.BETYPE }?
mei_att.medium.attributes = mei_att.medium.attribute.medium
mei_att.medium.attribute.medium =
  
  ## Describes the writing medium.
  attribute medium { xsd:string }?
mei_att.meiVersion.attributes = mei_att.meiVersion.attribute.meiversion
mei_att.meiVersion.attribute.meiversion =
  
  ## Specifies a generic MEI version label.
  [ a:defaultValue = "4.0.1" ]
  attribute meiversion {
    
    ## First release of MEI 4
    "4.0.0"
    | 
      ## Bugfix Release 4.0.1
      "4.0.1"
  }?
mei_att.mensur.log.attributes =
  mei_att.duration.ratio.attributes,
  mei_att.slashCount.attributes,
  mei_att.mensur.log.attribute.dot,
  mei_att.mensur.log.attribute.sign
mei_att.mensur.log.attribute.dot =
  
  ## Specifies whether a dot is to be added to the base symbol.
  attribute dot { mei_data.BOOLEAN }?
mei_att.mensur.log.attribute.sign =
  
  ## The base symbol in the mensuration sign/time signature of mensural notation.
  attribute sign { mei_data.MENSURATIONSIGN }?
mei_att.meterConformance.attributes =
  mei_att.meterConformance.attribute.metcon
mei_att.meterConformance.attribute.metcon =
  
  ## Indicates the relationship between the content of a staff or layer and the prevailing meter.
  attribute metcon {
    
    ## Complete; i.e., conformant with the prevailing meter.
    "c"
    | 
      ## Incomplete; i.e., not enough beats.
      "i"
    | 
      ## Overfull; i.e., too many beats.
      "o"
  }?
mei_att.meterConformance.bar.attributes =
  mei_att.meterConformance.bar.attribute.metcon,
  mei_att.meterConformance.bar.attribute.control
mei_att.meterConformance.bar.attribute.metcon =
  
  ## Indicates the relationship between the content of a measure and the prevailing meter.
  attribute metcon { mei_data.BOOLEAN }?
mei_att.meterConformance.bar.attribute.control =
  
  ## Indicates whether or not a bar line is "controlling"; that is, if it indicates a point of alignment across all the parts. Bar lines within a score are usually controlling; that is, they "line up". Bar lines within parts may or may not be controlling. When applied to measure, this attribute indicates the nature of the right barline but not the left.
  attribute control { mei_data.BOOLEAN }?
mei_att.meterSig.log.attributes =
  mei_att.meterSig.log.attribute.count,
  mei_att.meterSig.log.attribute.sym,
  mei_att.meterSig.log.attribute.unit
mei_att.meterSig.log.attribute.count =
  
  ## Captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an additive expression that evaluates to a decimal number, such as 2+3.
  attribute count {
    xsd:string { pattern = "\d+(\.\d+)?(\s*\+\s*\d+(\.\d+)?)*" }
  }?
mei_att.meterSig.log.attribute.sym =
  
  ## Indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
  attribute sym { mei_data.METERSIGN }?
mei_att.meterSig.log.attribute.unit =
  
  ## Contains the number indicating the beat unit, that is, the bottom number of the meter signature.
  attribute unit { xsd:decimal }?
mei_att.meterSigDefault.log.attributes =
  mei_att.meterSigDefault.log.attribute.meter.count,
  mei_att.meterSigDefault.log.attribute.meter.unit,
  mei_att.meterSigDefault.log.attribute.meter.sym
mei_att.meterSigDefault.log.attribute.meter.count =
  
  ## Captures the number of beats in a measure, that is, the top number of the meter signature. It must contain a decimal number or an additive expression that evaluates to a decimal number, such as 2+3.
  attribute meter.count {
    xsd:string { pattern = "\d+(\.\d+)?(\s*\+\s*\d+(\.\d+)?)*" }
  }?
mei_att.meterSigDefault.log.attribute.meter.unit =
  
  ## Contains the number indicating the beat unit, that is, the bottom number of the meter signature.
  attribute meter.unit { xsd:decimal }?
mei_att.meterSigDefault.log.attribute.meter.sym =
  
  ## Indicates the use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time or 'C' with a slash for cut time.
  attribute meter.sym { mei_data.METERSIGN }?
mei_att.mmTempo.attributes =
  mei_att.mmTempo.attribute.mm,
  mei_att.mmTempo.attribute.mm.unit,
  mei_att.mmTempo.attribute.mm.dots
mei_att.mmTempo.attribute.mm =
  
  ## Used to describe tempo in terms of beats (often the meter signature denominator) per minute, ala M.M. (Maezel's Metronome). Do not confuse this attribute with midi.bpm or midi.mspb. In MIDI, a beat is always defined as a quarter note, *not the numerator of the time signature or the metronomic indication*.
  attribute mm { mei_data.TEMPOVALUE }?
mei_att.mmTempo.attribute.mm.unit =
  
  ## Captures the metronomic unit.
  attribute mm.unit { mei_data.DURATION }?
mei_att.mmTempo.attribute.mm.dots =
  
  ## Records the number of augmentation dots required by a dotted metronome unit.
  attribute mm.dots { mei_data.AUGMENTDOT }?
mei_att.multinumMeasures.attributes =
  mei_att.multinumMeasures.attribute.multi.number
mei_att.multinumMeasures.attribute.multi.number =
  
  ## Indicates whether programmatically calculated counts of multiple measures of rest (mRest) and whole measure repeats (mRpt) in parts should be rendered.
  attribute multi.number { mei_data.BOOLEAN }?
mei_att.name.attributes =
  mei_att.authorized.attributes,
  mei_att.datable.attributes,
  mei_att.filing.attributes,
  mei_att.name.attribute.nymref,
  mei_att.name.attribute.role
mei_att.name.attribute.nymref =
  
  ## Used to record a pointer to the regularized form of the name elsewhere in the document.
  attribute nymref { mei_data.URI }?
sch:pattern [
  id = "mei-att.name-nymref-check_nymrefTarget-constraint-rule-115"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@nymref"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@nymref attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @nymref should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.name.attribute.role =
  
  ## Used to specify further information about the entity referenced by this name, for example, the occupation of a person or the status of a place.
  attribute role { text }?
mei_att.nInteger.attributes = mei_att.nInteger.attribute.n
mei_att.nInteger.attribute.n =
  
  ## Provides a numeric designation that indicates an element's position in a sequence of similar elements. Its value must be a non-negative integer.
  attribute n { xsd:nonNegativeInteger }?
mei_att.nNumberLike.attributes = mei_att.nNumberLike.attribute.n
mei_att.nNumberLike.attribute.n =
  
  ## Provides a number-like designation that indicates an element's position in a sequence of similar elements. May not contain space characters.
  attribute n { mei_data.WORD }?
mei_att.notationStyle.attributes =
  mei_att.notationStyle.attribute.music.name,
  mei_att.notationStyle.attribute.music.size
mei_att.notationStyle.attribute.music.name =
  
  ## Sets the default music font name.
  attribute music.name { mei_data.MUSICFONT }?
mei_att.notationStyle.attribute.music.size =
  
  ## Sets the default music font size.
  attribute music.size { mei_data.FONTSIZE }?
mei_att.note.log.attributes =
  mei_att.augmentDots.attributes,
  mei_att.coloration.attributes,
  mei_att.cue.attributes,
  mei_att.duration.logical.attributes,
  mei_att.event.attributes,
  mei_att.note.log.cmn.attributes,
  mei_att.pitched.attributes
mei_att.noteHeads.attributes =
  mei_att.noteHeads.attribute.head.altsym,
  mei_att.noteHeads.attribute.head.auth,
  mei_att.noteHeads.attribute.head.color,
  mei_att.noteHeads.attribute.head.fill,
  mei_att.noteHeads.attribute.head.fillcolor,
  mei_att.noteHeads.attribute.head.mod,
  mei_att.noteHeads.attribute.head.rotation,
  mei_att.noteHeads.attribute.head.shape,
  mei_att.noteHeads.attribute.head.visible
mei_att.noteHeads.attribute.head.altsym =
  
  ## Provides a way of pointing to a user-defined symbol. It must contain a reference to an ID of a symbolDef element elsewhere in the document.
  attribute head.altsym { mei_data.URI }?
sch:pattern [
  id =
    "mei-att.noteHeads-head.altsym-check_head.altsymTarget-constraint-rule-116"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@head.altsym"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@head.altsym attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:symbolDef/@xml:id"
      "The value in @head.altsym should correspond to the @xml:id attribute of a symbolDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.noteHeads.attribute.head.auth =
  
  ## A name or label associated with the controlled vocabulary from which a numerical value of head.shape is taken.
  ## Suggested values include: 1] smufl
  attribute head.auth {
    
    ## Standard Music Font Layout.
    "smufl"
    | xsd:NMTOKEN
  }?
sch:pattern [
  id = "mei-att.noteHeads-head.auth-check_head.auth-constraint-rule-117"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[lower-case(@head.auth) eq 'smufl']"
    "\x{a}" ~
    "              "
    sch:assert [
      test =
        "matches(@head.shape, '^#x') or matches(@head.shape, '^U+')"
      "When\x{a}" ~
      "                @head.auth matches 'smufl', @head.shape must contain a numeric glyph reference in\x{a}" ~
      '                hexadecimal notation, e.g. "#xE000" or "U+E000".'
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.noteHeads.attribute.head.color =
  
  ## Captures the overall color of a notehead.
  attribute head.color { mei_data.COLOR }?
mei_att.noteHeads.attribute.head.fill =
  
  ## Describes how/if the notehead is filled.
  attribute head.fill { mei_data.FILL }?
mei_att.noteHeads.attribute.head.fillcolor =
  
  ## Captures the fill color of a notehead if different from the overall note color.
  attribute head.fillcolor { mei_data.COLOR }?
mei_att.noteHeads.attribute.head.mod =
  
  ## Records any additional symbols applied to the notehead.
  attribute head.mod {
    list { mei_data.NOTEHEADMODIFIER+ }
  }?
mei_att.noteHeads.attribute.head.rotation =
  
  ## Describes rotation applied to the basic notehead shape. A positive value rotates the notehead in a counter-clockwise fashion, while negative values produce clockwise rotation.
  attribute head.rotation { mei_data.ROTATION }?
mei_att.noteHeads.attribute.head.shape =
  
  ## Used to override the head shape normally used for the given duration.
  attribute head.shape { mei_data.HEADSHAPE }?
sch:pattern [
  id =
    "mei-att.noteHeads-head.shape-check_headshape_num-constraint-rule-118"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "mei:*[(matches(@head.shape, '#x') or matches(@head.shape, 'U+')) and (lower-case(@head.auth) eq 'smufl')]"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "matches(normalize-space(@head.shape), '^(#x|U\+)E([0-9AB][0-9A-F][0-9A-F]|C[0-9A][0-9A-F]|CB[0-9A-F])$')"
      "SMuFL version 1.18 uses the range U+E000 - U+ECBF."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.noteHeads.attribute.head.visible =
  
  ## Indicates if a feature should be rendered when the notation is presented graphically or sounded when it is presented in an aural form.
  attribute head.visible { mei_data.BOOLEAN }?
mei_att.octave.attributes = mei_att.octave.attribute.oct
mei_att.octave.attribute.oct =
  
  ## Captures written octave information.
  attribute oct { mei_data.OCTAVE }?
mei_att.octaveDefault.attributes =
  mei_att.octaveDefault.attribute.oct.default
mei_att.octaveDefault.attribute.oct.default =
  
  ## Contains a default octave specification for use when the first note, rest, chord, etc. in a measure does not have an octave value specified.
  attribute oct.default { mei_data.OCTAVE }?
mei_att.octaveDisplacement.attributes =
  mei_att.octaveDisplacement.attribute.dis,
  mei_att.octaveDisplacement.attribute.dis.place
mei_att.octaveDisplacement.attribute.dis =
  
  ## Records the amount of octave displacement.
  attribute dis { mei_data.OCTAVE.DIS }?
mei_att.octaveDisplacement.attribute.dis.place =
  
  ## Records the direction of octave displacement.
  attribute dis.place { mei_data.STAFFREL.basic }?
mei_att.oneLineStaff.attributes =
  mei_att.oneLineStaff.attribute.ontheline
mei_att.oneLineStaff.attribute.ontheline =
  
  ## Determines the placement of notes on a 1-line staff. A value of 'true' places all notes on the line, while a value of 'false' places stems-up notes above the line and stems-down notes below the line.
  attribute ontheline { mei_data.BOOLEAN }?
mei_att.optimization.attributes =
  mei_att.optimization.attribute.optimize
mei_att.optimization.attribute.optimize =
  
  ## Indicates whether staves without notes, rests, etc. should be displayed. When the value is 'true', empty staves are displayed.
  attribute optimize { mei_data.BOOLEAN }?
mei_att.origin.layerIdent.attributes =
  mei_att.origin.layerIdent.attribute.origin.layer
mei_att.origin.layerIdent.attribute.origin.layer =
  
  ## identifies the layer on which referenced notation occurs.
  attribute origin.layer {
    list { xsd:positiveInteger+ }
  }?
mei_att.origin.staffIdent.attributes =
  mei_att.origin.staffIdent.attribute.origin.staff
mei_att.origin.staffIdent.attribute.origin.staff =
  
  ## signifies the staff on which referenced notation occurs. Defaults to the same value as the local staff. Mandatory when applicable.
  attribute origin.staff {
    list { xsd:positiveInteger+ }
  }?
mei_att.origin.startEndId.attributes =
  mei_att.origin.startEndId.attribute.origin.startid,
  mei_att.origin.startEndId.attribute.origin.endid
mei_att.origin.startEndId.attribute.origin.startid =
  
  ## indicates the first element in a sequence of events.
  attribute origin.startid { mei_data.URI }?
mei_att.origin.startEndId.attribute.origin.endid =
  
  ## indicates the final element in a sequence of events.
  attribute origin.endid { mei_data.URI }?
mei_att.origin.timestamp.logical.attributes =
  mei_att.origin.timestamp.logical.attribute.origin.tstamp,
  mei_att.origin.timestamp.logical.attribute.origin.tstamp2
mei_att.origin.timestamp.logical.attribute.origin.tstamp =
  
  ## encodes the starting point of musical material in terms of musical time, i.e., a (potentially negative) count of measures plus a beat location.
  attribute origin.tstamp { mei_data.MEASUREBEATOFFSET }?
mei_att.origin.timestamp.logical.attribute.origin.tstamp2 =
  
  ## encodes the ending point of musical material in terms of musical time, i.e., a count of measures plus a beat location. The values are relative to the measure identified by origin.tstamp.
  attribute origin.tstamp2 { mei_data.MEASUREBEAT }?
sch:pattern [
  id =
    "mei-att.origin.timestamp.logical-origin.tstamp2-origin.tstamp2_requires_origin.tstamp-constraint-rule-119"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@origin.tstamp2]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@origin.tstamp"
      "When @origin.tstamp2 is used @origin.tstamp must\x{a}" ~
      "                also be present."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.ornam.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.ornamentAccid.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.pad.log.attributes =
  mei_att.event.attributes, mei_att.width.attributes
mei_att.pages.attributes =
  mei_att.pages.attribute.page.height,
  mei_att.pages.attribute.page.width,
  mei_att.pages.attribute.page.topmar,
  mei_att.pages.attribute.page.botmar,
  mei_att.pages.attribute.page.leftmar,
  mei_att.pages.attribute.page.rightmar,
  mei_att.pages.attribute.page.panels,
  mei_att.pages.attribute.page.scale
mei_att.pages.attribute.page.height =
  
  ## Specifies the height of the page; may be expressed in real-world units or staff steps.
  attribute page.height { mei_data.MEASUREMENTABS }?
mei_att.pages.attribute.page.width =
  
  ## Describes the width of the page; may be expressed in real-world units or staff steps.
  attribute page.width { mei_data.MEASUREMENTABS }?
mei_att.pages.attribute.page.topmar =
  
  ## Indicates the amount of whitespace at the top of a page.
  attribute page.topmar { mei_data.MEASUREMENTABS }?
mei_att.pages.attribute.page.botmar =
  
  ## Indicates the amount of whitespace at the bottom of a page.
  attribute page.botmar { mei_data.MEASUREMENTABS }?
mei_att.pages.attribute.page.leftmar =
  
  ## Indicates the amount of whitespace at the left side of a page.
  attribute page.leftmar { mei_data.MEASUREMENTABS }?
mei_att.pages.attribute.page.rightmar =
  
  ## Indicates the amount of whitespace at the right side of a page.
  attribute page.rightmar { mei_data.MEASUREMENTABS }?
mei_att.pages.attribute.page.panels =
  
  ## Indicates the number of logical pages to be rendered on a single physical page.
  attribute page.panels { mei_data.PAGE.PANELS }?
mei_att.pages.attribute.page.scale =
  
  ## Indicates how the page should be scaled when rendered.
  attribute page.scale { mei_data.PGSCALE }?
mei_att.part.log.attributes = empty
mei_att.partIdent.attributes =
  mei_att.partIdent.attribute.part,
  mei_att.partIdent.attribute.partstaff
mei_att.partIdent.attribute.part =
  
  ## Indicates the part in which the current feature should appear. Use '%all' when the feature should occur in every part.
  attribute part {
    list {
      xsd:token { pattern = "(%all|#[\i][\c]+)" }+
    }
  }?
sch:pattern [
  id = "mei-att.partIdent-part-check_part_attr_all-constraint-rule-120"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "@part[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "count(tokenize(., '\s+')) = 1"
      "'%all' cannot be mixed with other\x{a}" ~
      "                values."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.partIdent.attribute.partstaff =
  
  ## Signifies the part staff on which a notated feature occurs. Use '%all' when the feature should occur on every staff.
  attribute partstaff {
    list {
      xsd:token { pattern = "(%all|\d+(-\d+)?)" }+
    }
  }?
sch:pattern [
  id =
    "mei-att.partIdent-partstaff-check_partstaff_attr_all-constraint-rule-121"
  "\x{a}" ~
  "      "
  sch:rule [
    context =
      "@partstaff[some $i in tokenize(., '\s+') satisfies (matches($i, '^%all$'))]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "count(tokenize(., '\s+')) = 1"
      "'%all' cannot be mixed with other\x{a}" ~
      "                values."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.parts.log.attributes = empty
mei_att.pb.log.attributes = mei_att.alignment.attributes
mei_att.phrase.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes
mei_att.pitch.attributes = mei_att.pitch.attribute.pname
mei_att.pitch.attribute.pname =
  
  ## Contains a written pitch name.
  attribute pname { mei_data.PITCHNAME }?
mei_att.pitched.attributes =
  mei_att.pitch.attributes, mei_att.octave.attributes
mei_att.placement.attributes = mei_att.placement.attribute.place
mei_att.placement.attribute.place =
  
  ## Captures the placement of the item with respect to the staff with which it is associated.
  attribute place { mei_data.STAFFREL }?
mei_att.plist.attributes = mei_att.plist.attribute.plist
mei_att.plist.attribute.plist =
  
  ## When the target attribute is present, plist identifies the active participants; that is, those entities pointed "from", in a relationship with the specified target(s). When the target attribute is not present, it identifies participants in a mutual relationship.
  attribute plist {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.plist-plist-check_plistTarget-constraint-rule-122"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@plist"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@plist attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "Each\x{a}" ~
      "                value in @plist should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.pointing.attributes =
  mei_att.pointing.attribute.xlinkactuate,
  mei_att.pointing.attribute.xlinkrole,
  mei_att.pointing.attribute.xlinkshow,
  mei_att.pointing.attribute.target,
  mei_att.pointing.attribute.targettype
mei_att.pointing.attribute.xlinkactuate =
  
  ## Defines whether a link occurs automatically or must be requested by the user.
  attribute xlink:actuate {
    
    ## Load the target resource(s) immediately.
    "onLoad"
    | 
      ## Load the target resource(s) upon user request.
      "onRequest"
    | 
      ## Do not permit loading of the target resource(s).
      "none"
    | 
      ## Behavior other than allowed by the other values of this attribute.
      "other"
  }?
mei_att.pointing.attribute.xlinkrole =
  
  ## Characterization of the relationship between resources. The value of the role attribute must be a URI.
  attribute xlink:role { mei_data.URI }?
mei_att.pointing.attribute.xlinkshow =
  
  ## Defines how a remote resource is rendered.
  attribute xlink:show {
    
    ## Open in a new window.
    "new"
    | 
      ## Load the referenced resource in the same window.
      "replace"
    | 
      ## Embed the referenced resource at the point of the link.
      "embed"
    | 
      ## Do not permit traversal to the referenced resource.
      "none"
    | 
      ## Behavior other than permitted by the other values of this attribute.
      "other"
  }?
mei_att.pointing.attribute.target =
  
  ## Identifies passive participants in a relationship; that is, the entities pointed "to".
  attribute target {
    list { mei_data.URI+ }
  }?
mei_att.pointing.attribute.targettype =
  
  ## Characterization of target resource(s) using any convenient classification scheme or typology.
  attribute targettype { xsd:NMTOKEN }?
mei_att.quantity.attributes =
  mei_att.measurement.attributes,
  mei_att.ranging.attributes,
  mei_att.quantity.attribute.quantity
mei_att.quantity.attribute.quantity =
  
  ## Numeric value capturing a measurement or count. Can only be interpreted in combination with the unit attribute.
  attribute quantity {
    xsd:decimal { minInclusive = "0" }
  }?
mei_att.ranging.attributes =
  mei_att.ranging.attribute.atleast,
  mei_att.ranging.attribute.atmost,
  mei_att.ranging.attribute.min,
  mei_att.ranging.attribute.max,
  mei_att.ranging.attribute.confidence
mei_att.ranging.attribute.atleast =
  
  ## Gives a minimum estimated value for an approximate measurement.
  attribute atleast { xsd:decimal }?
mei_att.ranging.attribute.atmost =
  
  ## Gives a maximum estimated value for an approximate measurement.
  attribute atmost { xsd:decimal }?
mei_att.ranging.attribute.min =
  
  ## Where the measurement summarizes more than one observation or a range of values, supplies the minimum value observed.
  attribute min { xsd:decimal }?
mei_att.ranging.attribute.max =
  
  ## Where the measurement summarizes more than one observation or a range of values, supplies the maximum value observed.
  attribute max { xsd:decimal }?
mei_att.ranging.attribute.confidence =
  
  ## Specifies the degree of statistical confidence (between zero and one) that a value falls within the range specified by min and max, or the proportion of observed values that fall within that range.
  attribute confidence { mei_data.CONFIDENCE }?
sch:pattern [
  id = "mei-att.ranging-confidence-check_confidence-constraint-rule-123"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:*[@confidence]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@min and @max"
      "The attributes @min and @max are required when\x{a}" ~
      "                @confidence is present."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.responsibility.attributes =
  mei_att.responsibility.attribute.resp
mei_att.responsibility.attribute.resp =
  
  ## Indicates the agent(s) responsible for some aspect of the text's transcription, editing, or encoding. Its value must point to one or more identifiers declared in the document header.
  attribute resp {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id =
    "mei-att.responsibility-resp-check_respTarget-constraint-rule-124"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@resp"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@resp attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[ancestor::mei:meiHead]/@xml:id"
      "The value in @resp should correspond to the @xml:id attribute of an element within\x{a}" ~
      "                the metadata header."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.rest.log.attributes =
  mei_att.augmentDots.attributes,
  mei_att.cue.attributes,
  mei_att.duration.logical.attributes,
  mei_att.event.attributes,
  mei_att.rest.log.cmn.attributes
mei_att.sb.log.attributes = mei_att.alignment.attributes
mei_att.scalable.attributes = mei_att.scalable.attribute.scale
mei_att.scalable.attribute.scale =
  
  ## Scale factor to be applied to the feature to make it the desired display size.
  attribute scale { mei_data.PERCENT }?
mei_att.score.log.attributes = empty
mei_att.scoreDef.log.attributes =
  mei_att.cleffing.log.attributes,
  mei_att.duration.default.attributes,
  mei_att.keySigDefault.log.attributes,
  mei_att.meterSigDefault.log.attributes,
  mei_att.octaveDefault.attributes,
  mei_att.transposition.attributes,
  mei_att.scoreDef.log.cmn.attributes
mei_att.section.log.attributes = mei_att.alignment.attributes
mei_att.sequence.attributes = mei_att.sequence.attribute.seq
mei_att.sequence.attribute.seq =
  
  ## Used to assign a sequence number related to the order in which the encoded features carrying this attribute are believed to have occurred.
  attribute seq { xsd:positiveInteger }?
mei_att.slashCount.attributes = mei_att.slashCount.attribute.slash
mei_att.slashCount.attribute.slash =
  
  ## Indicates the number of slashes present.
  attribute slash { mei_data.SLASH }?
mei_att.slurPresent.attributes = mei_att.slurPresent.attribute.slur
mei_att.slurPresent.attribute.slur =
  
  ## Indicates that this element participates in a slur. If visual information about the slur needs to be recorded, then a slur element should be employed.
  attribute slur {
    list { mei_data.SLUR+ }
  }?
mei_att.source.attributes = mei_att.source.attribute.source
mei_att.source.attribute.source =
  
  ## Contains a list of one or more pointers indicating the sources which attest to a given reading. Each value should correspond to the ID of a source or manifestationelement located in the document header.
  attribute source {
    list { mei_data.URI+ }
  }?
sch:pattern [
  id = "mei-att.source-source-check_sourceTarget-constraint-rule-125"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@source"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@source attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*[local-name() eq 'source' or local-name() eq 'manifestation']/@xml:id"
      "Each value in @source should correspond to the @xml:id attribute of a source or\x{a}" ~
      "                manifestation element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.space.log.attributes =
  mei_att.augmentDots.attributes,
  mei_att.duration.logical.attributes,
  mei_att.event.attributes
mei_att.spacing.attributes =
  mei_att.spacing.attribute.spacing.packexp,
  mei_att.spacing.attribute.spacing.packfact,
  mei_att.spacing.attribute.spacing.staff,
  mei_att.spacing.attribute.spacing.system
mei_att.spacing.attribute.spacing.packexp =
  
  ## Describes a note's spacing relative to its time value.
  attribute spacing.packexp { xsd:decimal }?
mei_att.spacing.attribute.spacing.packfact =
  
  ## Describes the note spacing of output.
  attribute spacing.packfact { xsd:decimal }?
mei_att.spacing.attribute.spacing.staff =
  
  ## Specifies the minimum amount of space between adjacent staves in the same system; measured from the bottom line of the staff above to the top line of the staff below.
  attribute spacing.staff { mei_data.MEASUREMENTREL }?
mei_att.spacing.attribute.spacing.system =
  
  ## Describes the space between adjacent systems; a pair of space-separated values (minimum and maximum, respectively) provides a range between which a rendering system-supplied value may fall, while a single value indicates a fixed amount of space; that is, the minimum and maximum values are equal.
  attribute spacing.system {
    list { mei_data.MEASUREMENTREL, mei_data.MEASUREMENTREL? }
  }?
mei_att.staff.log.attributes =
  mei_att.meterConformance.attributes, mei_att.staff.log.attribute.def
mei_att.staff.log.attribute.def =
  
  ## Provides a mechanism for linking the staff to a staffDef element.
  attribute def { mei_data.URI }?
sch:pattern [
  id = "mei-att.staff.log-def-check_defTarget_staff-constraint-rule-126"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:staff/@def"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@def attribute should\x{a}" ~
      "                have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:staffDef/@xml:id"
      "The value in @def should correspond to the @xml:id attribute of a staffDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.staffDef.log.attributes =
  mei_att.cleffing.log.attributes,
  mei_att.duration.default.attributes,
  mei_att.keySigDefault.log.attributes,
  mei_att.meterSigDefault.log.attributes,
  mei_att.notationType.attributes,
  mei_att.octaveDefault.attributes,
  mei_att.transposition.attributes,
  mei_att.staffDef.log.cmn.attributes,
  mei_att.staffDef.log.attribute.lines
mei_att.staffDef.log.attribute.lines =
  
  ## Indicates the number of staff lines.
  attribute lines { xsd:positiveInteger }?
mei_att.staffGroupingSym.attributes =
  mei_att.staffGroupingSym.attribute.symbol
mei_att.staffGroupingSym.attribute.symbol =
  
  ## Specifies the symbol used to group a set of staves.
  attribute symbol {
    
    ## Curved symbol, i.e., {.
    "brace"
    | 
      ## Square symbol, i.e., [, but with curved/angled top and bottom segments.
      "bracket"
    | 
      ## Square symbol, i.e., [, with horizontal top and bottom segments.
      "bracketsq"
    | 
      ## Line symbol, i.e., |, (wide) line without top and bottom curved/horizontal segments.
      "line"
    | 
      ## Grouping symbol missing.
      "none"
  }?
mei_att.staffGrp.log.attributes = empty
mei_att.staffIdent.attributes = mei_att.staffIdent.attribute.staff
mei_att.staffIdent.attribute.staff =
  
  ## Signifies the staff on which a notated event occurs or to which a control event applies. Mandatory when applicable.
  attribute staff {
    list { xsd:positiveInteger+ }
  }?
mei_att.staffItems.attributes =
  mei_att.staffItems.attribute.aboveorder,
  mei_att.staffItems.attribute.beloworder,
  mei_att.staffItems.attribute.betweenorder
mei_att.staffItems.attribute.aboveorder =
  
  ## Describes vertical order of items printed above a staff, from closest to farthest away from the staff.
  attribute aboveorder {
    list { mei_data.STAFFITEM+ }
  }?
mei_att.staffItems.attribute.beloworder =
  
  ## Describes vertical order of items printed below a staff, from closest to farthest away from the staff.
  attribute beloworder {
    list { mei_data.STAFFITEM+ }
  }?
mei_att.staffItems.attribute.betweenorder =
  
  ## Describes vertical order of items printed between staves, from top to bottom.
  attribute betweenorder {
    list { mei_data.STAFFITEM+ }
  }?
mei_att.staffLoc.attributes = mei_att.staffLoc.attribute.loc
mei_att.staffLoc.attribute.loc =
  
  ## Holds the staff location of the feature.
  attribute loc { mei_data.STAFFLOC }?
mei_att.staffLoc.pitched.attributes =
  mei_att.staffLoc.pitched.attribute.ploc,
  mei_att.staffLoc.pitched.attribute.oloc
mei_att.staffLoc.pitched.attribute.ploc =
  
  ## Captures staff location in terms of written pitch name.
  attribute ploc { mei_data.PITCHNAME }?
mei_att.staffLoc.pitched.attribute.oloc =
  
  ## Records staff location in terms of written octave.
  attribute oloc { mei_data.OCTAVE }?
mei_att.startEndId.attributes =
  mei_att.startId.attributes, mei_att.startEndId.attribute.endid
mei_att.startEndId.attribute.endid =
  
  ## Indicates the final element in a sequence of events to which the feature applies.
  attribute endid { mei_data.URI }?
sch:pattern [
  id = "mei-att.startEndId-endid-check_endidTarget-constraint-rule-127"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@endid"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@endid attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @endid should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.startId.attributes = mei_att.startId.attribute.startid
mei_att.startId.attribute.startid =
  
  ## Holds a reference to the first element in a sequence of events to which the feature applies.
  attribute startid { mei_data.URI }?
sch:pattern [
  id = "mei-att.startId-startid-check_startidTarget-constraint-rule-128"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@startid"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@startid attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:*/@xml:id"
      "The\x{a}" ~
      "                value in @startid should correspond to the @xml:id attribute of an\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.stems.attributes =
  mei_att.stems.cmn.attributes,
  mei_att.stems.attribute.stem.dir,
  mei_att.stems.attribute.stem.len,
  mei_att.stems.attribute.stem.mod,
  mei_att.stems.attribute.stem.pos,
  mei_att.stems.attribute.stem.visible,
  mei_att.stems.attribute.stem.x,
  mei_att.stems.attribute.stem.y
mei_att.stems.attribute.stem.dir =
  
  ## Describes the direction of a stem.
  attribute stem.dir { mei_data.STEMDIRECTION }?
mei_att.stems.attribute.stem.len =
  
  ## Encodes the stem length.
  attribute stem.len { mei_data.MEASUREMENTABS }?
mei_att.stems.attribute.stem.mod =
  
  ## Encodes any stem "modifiers"; that is, symbols rendered on the stem, such as tremolo or Sprechstimme indicators.
  attribute stem.mod { mei_data.STEMMODIFIER }?
mei_att.stems.attribute.stem.pos =
  
  ## Records the position of the stem in relation to the note head(s).
  attribute stem.pos { mei_data.STEMPOSITION }?
mei_att.stems.attribute.stem.visible =
  
  ## Determines whether a stem should be displayed.
  attribute stem.visible { mei_data.BOOLEAN }?
mei_att.stems.attribute.stem.x =
  
  ## Records the output x coordinate of the stem's attachment point.
  attribute stem.x { xsd:decimal }?
mei_att.stems.attribute.stem.y =
  
  ## Records the output y coordinate of the stem's attachment point.
  attribute stem.y { xsd:decimal }?
mei_att.syl.log.attributes =
  mei_att.syl.log.attribute.con, mei_att.syl.log.attribute.wordpos
mei_att.syl.log.attribute.con =
  
  ## Describes the symbols typically used to indicate breaks between syllables and their functions.
  attribute con {
    
    ## Space (word separator).
    "s"
    | 
      ## Dash (syllable separator).
      "d"
    | 
      ## Underscore (syllable extension).
      "u"
    | 
      ## Tilde (syllable elision).
      "t"
    | 
      ## Circumflex [angled line above] (syllable elision).
      "c"
    | 
      ## Caron [angled line below] (syllable elision).
      "v"
    | 
      ## Inverted breve [curved line above] (syllable elision).
      "i"
    | 
      ## Breve [curved line below] (syllable elision).
      "b"
  }?
mei_att.syl.log.attribute.wordpos =
  
  ## Records the position of a syllable within a word.
  attribute wordpos {
    
    ## (initial) first syllable.
    "i"
    | 
      ## (medial) neither first nor last syllable.
      "m"
    | 
      ## (terminal) last syllable.
      "t"
  }?
mei_att.sylText.attributes = mei_att.sylText.attribute.syl
mei_att.sylText.attribute.syl =
  
  ## Holds an associated sung text syllable.
  attribute syl { xsd:string }?
mei_att.symbol.log.attributes = mei_att.startId.attributes
mei_att.systems.attributes =
  mei_att.systems.attribute.system.leftline,
  mei_att.systems.attribute.system.leftmar,
  mei_att.systems.attribute.system.rightmar,
  mei_att.systems.attribute.system.topmar
mei_att.systems.attribute.system.leftline =
  
  ## Indicates whether the staves are joined at the left by a continuous line. The default value is "true". Do not confuse this with the heavy vertical line used as a grouping symbol.
  attribute system.leftline { mei_data.BOOLEAN }?
mei_att.systems.attribute.system.leftmar =
  
  ## Describes the amount of whitespace at the left system margin relative to page.leftmar.
  attribute system.leftmar { mei_data.MEASUREMENTABS }?
mei_att.systems.attribute.system.rightmar =
  
  ## Describes the amount of whitespace at the right system margin relative to page.rightmar.
  attribute system.rightmar { mei_data.MEASUREMENTABS }?
mei_att.systems.attribute.system.topmar =
  
  ## Describes the distance from page's top edge to the first system; used for first page only.
  attribute system.topmar { mei_data.MEASUREMENTABS }?
mei_att.targetEval.attributes = mei_att.targetEval.attribute.evaluate
mei_att.targetEval.attribute.evaluate =
  
  ## Specifies the intended meaning when a participant in a relationship is itself a pointer.
  attribute evaluate {
    
    ## If an element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.
    "all"
    | 
      ## If an element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.
      "one"
    | 
      ## No further evaluation of targets is carried out beyond that needed to find the element(s) specified in plist or target attribute.
      "none"
  }?
mei_att.tempo.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.mmTempo.attributes,
  mei_att.startId.attributes,
  mei_att.tempo.log.attribute.func
mei_att.tempo.log.attribute.func =
  
  ## Records the function of a tempo indication.
  attribute func {
    
    ## Marks a gradual change of tempo, such as "accel." or "rit."
    "continuous"
    | 
      ## Represents a static tempo instruction, such as a textual term like "Adagio", a metronome marking like "=70", or a combination of text and metronome indication.
      "instantaneous"
    | 
      ## Captures a change in pulse rate (tempo) and/or pulse grouping (subdivision) in an "equation" of the form [tempo before change] = [tempo after change].
      "metricmod"
    | 
      ## Indicates a change in pulse rate (tempo) and/or pulse grouping (subdivision) in an "equation" of the form [tempo after change] = [tempo before change]. The term "precedente" often appears following the "equation" to distinguish this kind of historical usage from the modern metric modulation form.
      "precedente"
  }?
mei_att.textRendition.attributes =
  mei_att.textRendition.attribute.altrend,
  mei_att.textRendition.attribute.rend
mei_att.textRendition.attribute.altrend =
  
  ## Used to extend the values of the rend attribute.
  attribute altrend {
    list { xsd:NMTOKEN+ }
  }?
mei_att.textRendition.attribute.rend =
  
  ## Captures the appearance of the element's contents using MEI-defined descriptors.
  attribute rend {
    list { mei_data.TEXTRENDITION+ }
  }?
mei_att.textStyle.attributes =
  mei_att.textStyle.attribute.text.fam,
  mei_att.textStyle.attribute.text.name,
  mei_att.textStyle.attribute.text.size,
  mei_att.textStyle.attribute.text.style,
  mei_att.textStyle.attribute.text.weight
mei_att.textStyle.attribute.text.fam =
  
  ## Provides a default value for the font family name of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.fam { mei_data.FONTFAMILY }?
mei_att.textStyle.attribute.text.name =
  
  ## Provides a default value for the font name of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.name { mei_data.FONTNAME }?
mei_att.textStyle.attribute.text.size =
  
  ## Provides a default value for the font size of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.size { mei_data.FONTSIZE }?
mei_att.textStyle.attribute.text.style =
  
  ## Provides a default value for the font style of text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.style { mei_data.FONTSTYLE }?
mei_att.textStyle.attribute.text.weight =
  
  ## Provides a default value for the font weight for text (other than lyrics) when this information is not provided on the individual elements.
  attribute text.weight { mei_data.FONTWEIGHT }?
mei_att.tiePresent.attributes = mei_att.tiePresent.attribute.tie
mei_att.tiePresent.attribute.tie =
  
  ## Indicates that this element participates in a tie. If visual information about the tie needs to be recorded, then a tie element should be employed.
  attribute tie {
    list { mei_data.TIE+ }
  }?
mei_att.timestamp.logical.attributes =
  mei_att.timestamp.logical.attribute.tstamp
mei_att.timestamp.logical.attribute.tstamp =
  
  ## Encodes the onset time in terms of musical time, i.e., beats[.fractional beat part], as expressed in the written time signature.
  attribute tstamp { mei_data.BEAT }?
mei_att.timestamp2.logical.attributes =
  mei_att.timestamp2.logical.attribute.tstamp2
mei_att.timestamp2.logical.attribute.tstamp2 =
  
  ## Encodes the ending point of an event, i.e., a count of measures plus a beat location in the ending measure.
  attribute tstamp2 { mei_data.MEASUREBEAT }?
mei_att.transposition.attributes =
  mei_att.transposition.attribute.trans.diat,
  mei_att.transposition.attribute.trans.semi
mei_att.transposition.attribute.trans.diat =
  
  ## Records the amount of diatonic pitch shift, e.g., C to C = 0, C to D = 1, necessary to calculate the sounded pitch from the written one.
  attribute trans.diat { xsd:decimal }?
mei_att.transposition.attribute.trans.semi =
  
  ## Records the amount of pitch shift in semitones, e.g., C to C = 1, C to D = 1, necessary to calculate the sounded pitch from the written one.
  attribute trans.semi { xsd:decimal }?
mei_att.tupletPresent.attributes =
  mei_att.tupletPresent.attribute.tuplet
mei_att.tupletPresent.attribute.tuplet =
  
  ## Indicates that this feature participates in a tuplet. If visual information about the tuplet needs to be recorded, then a tuplet element should be employed.
  attribute tuplet {
    list { mei_data.TUPLET+ }
  }?
mei_att.typed.attributes =
  mei_att.classed.attributes, mei_att.typed.attribute.type
mei_att.typed.attribute.type =
  
  ## Designation which characterizes the element in some sense, using any convenient classification scheme or typology that employs single-token labels.
  attribute type {
    list { xsd:NMTOKEN+ }
  }?
mei_att.typography.attributes =
  mei_att.typography.attribute.fontfam,
  mei_att.typography.attribute.fontname,
  mei_att.typography.attribute.fontsize,
  mei_att.typography.attribute.fontstyle,
  mei_att.typography.attribute.fontweight
mei_att.typography.attribute.fontfam =
  
  ## Contains the name of a font-family.
  attribute fontfam { mei_data.FONTFAMILY }?
mei_att.typography.attribute.fontname =
  
  ## Holds the name of a font.
  attribute fontname { mei_data.FONTNAME }?
mei_att.typography.attribute.fontsize =
  
  ## Indicates the size of a font expressed in printers' points, i.e., 1/72nd of an inch, relative terms, e.g., "small", "larger", etc., or percentage values relative to "normal" size, e.g., "125%". 
  attribute fontsize { mei_data.FONTSIZE }?
mei_att.typography.attribute.fontstyle =
  
  ## Records the style of a font, i.e, italic, oblique, or normal.
  attribute fontstyle { mei_data.FONTSTYLE }?
mei_att.typography.attribute.fontweight =
  
  ## Used to indicate bold type.
  attribute fontweight { mei_data.FONTWEIGHT }?
mei_att.verticalAlign.attributes =
  mei_att.verticalAlign.attribute.valign
mei_att.verticalAlign.attribute.valign =
  
  ## Records vertical alignment.
  attribute valign { mei_data.VERTICALALIGNMENT }?
mei_att.verticalGroup.attributes = mei_att.verticalGroup.attribute.vgrp
mei_att.verticalGroup.attribute.vgrp =
  
  ## Provides a label for members of a vertically aligned group.
  attribute vgrp { xsd:positiveInteger }?
mei_att.visibility.attributes = mei_att.visibility.attribute.visible
mei_att.visibility.attribute.visible =
  
  ## Indicates if a feature should be rendered when the notation is presented graphically or sounded when it is presented in an aural form.
  attribute visible { mei_data.BOOLEAN }?
mei_att.visualOffset.attributes =
  mei_att.visualOffset.ho.attributes,
  mei_att.visualOffset.to.attributes,
  mei_att.visualOffset.vo.attributes
mei_att.visualOffset.ho.attributes =
  mei_att.visualOffset.ho.attribute.ho
mei_att.visualOffset.ho.attribute.ho =
  
  ## Records a horizontal adjustment to a feature's programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
  attribute ho { mei_data.MEASUREMENTREL }?
mei_att.visualOffset.to.attributes =
  mei_att.visualOffset.to.attribute.to
mei_att.visualOffset.to.attribute.to =
  
  ## Records a timestamp adjustment of a feature's programmatically-determined location in terms of musical time; that is, beats.
  attribute to { mei_data.TSTAMPOFFSET }?
mei_att.visualOffset.vo.attributes =
  mei_att.visualOffset.vo.attribute.vo
mei_att.visualOffset.vo.attribute.vo =
  
  ## Records the vertical adjustment of a feature's programmatically-determined location in terms of staff interline distance; that is, in units of 1/2 the distance between adjacent staff lines.
  attribute vo { mei_data.MEASUREMENTREL }?
mei_att.visualOffset2.attributes =
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.visualOffset2.vo.attributes
mei_att.visualOffset2.ho.attributes =
  mei_att.visualOffset2.ho.attribute.startho,
  mei_att.visualOffset2.ho.attribute.endho
mei_att.visualOffset2.ho.attribute.startho =
  
  ## Records the horizontal adjustment of a feature's programmatically-determined start point.
  attribute startho { mei_data.MEASUREMENTREL }?
mei_att.visualOffset2.ho.attribute.endho =
  
  ## Records the horizontal adjustment of a feature's programmatically-determined end point.
  attribute endho { mei_data.MEASUREMENTREL }?
mei_att.visualOffset2.to.attributes =
  mei_att.visualOffset2.to.attribute.startto,
  mei_att.visualOffset2.to.attribute.endto
mei_att.visualOffset2.to.attribute.startto =
  
  ## Records a timestamp adjustment of a feature's programmatically-determined start point.
  attribute startto { mei_data.TSTAMPOFFSET }?
mei_att.visualOffset2.to.attribute.endto =
  
  ## Records a timestamp adjustment of a feature's programmatically-determined end point.
  attribute endto { mei_data.TSTAMPOFFSET }?
mei_att.visualOffset2.vo.attributes =
  mei_att.visualOffset2.vo.attribute.startvo,
  mei_att.visualOffset2.vo.attribute.endvo
mei_att.visualOffset2.vo.attribute.startvo =
  
  ## Records a vertical adjustment of a feature's programmatically-determined start point.
  attribute startvo { mei_data.MEASUREMENTREL }?
mei_att.visualOffset2.vo.attribute.endvo =
  
  ## Records a vertical adjustment of a feature's programmatically-determined end point.
  attribute endvo { mei_data.MEASUREMENTREL }?
mei_att.voltaGroupingSym.attributes =
  mei_att.voltaGroupingSym.attribute.voltasym
mei_att.voltaGroupingSym.attribute.voltasym =
  
  ## Specifies the symbol used to group lyrics.
  attribute voltasym {
    
    ## Curved symbol, i.e., {.
    "brace"
    | 
      ## Square symbol, i.e., [, but with curved/angled top and bottom segments.
      "bracket"
    | 
      ## Square symbol, i.e., [, with horizontal top and bottom segments.
      "bracketsq"
    | 
      ## Line symbol, i.e., |, (wide) line without top and bottom curved/horizontal segments.
      "line"
    | 
      ## Grouping symbol missing.
      "none"
  }?
mei_att.whitespace.attributes = mei_att.whitespace.attribute.xmlspace
mei_att.whitespace.attribute.xmlspace =
  
  ## Allows one to signal to an application whether an element's white space is "significant". The behavior of xml:space cascades to all descendant elements, but it can be turned off locally by setting the xml:space attribute to the value "default".
  attribute xml:space {
    
    ## Allows the application to handle white space as necessary. Not including an xml:space attribute produces the same result as using the default value.
    "default"
    | 
      ## Instructs the application to maintain white space "as-is", suggesting that it might have meaning.
      "preserve"
  }?
mei_att.width.attributes = mei_att.width.attribute.width
mei_att.width.attribute.width =
  
  ## Measurement of the horizontal dimension of an entity.
  attribute width { mei_data.MEASUREMENTABS }?
mei_att.xy.attributes = mei_att.xy.attribute.x, mei_att.xy.attribute.y
mei_att.xy.attribute.x =
  
  ## Encodes an x coordinate for a feature in an output coordinate system. When it is necessary to record the placement of a feature in a facsimile image, use the facs attribute.
  attribute x { xsd:decimal }?
mei_att.xy.attribute.y =
  
  ## Encodes a y coordinate for a feature in an output coordinate system. When it is necessary to record the placement of a feature in a facsimile image, use the facs attribute.
  attribute y { xsd:decimal }?
mei_att.xy2.attributes =
  mei_att.xy2.attribute.x2, mei_att.xy2.attribute.y2
mei_att.xy2.attribute.x2 =
  
  ## Encodes the optional 2nd x coordinate.
  attribute x2 { xsd:decimal }?
mei_att.xy2.attribute.y2 =
  
  ## Encodes the optional 2nd y coordinate.
  attribute y2 { xsd:decimal }?
mei_model.addressLike = mei_address
mei_model.addressLike_alternation = mei_address
mei_model.addressLike_sequence = mei_address
mei_model.addressLike_sequenceOptional = mei_address?
mei_model.addressLike_sequenceOptionalRepeatable = mei_address*
mei_model.addressLike_sequenceRepeatable = mei_address+
mei_model.annotLike = mei_annot
mei_model.annotLike_alternation = mei_annot
mei_model.annotLike_sequence = mei_annot
mei_model.annotLike_sequenceOptional = mei_annot?
mei_model.annotLike_sequenceOptionalRepeatable = mei_annot*
mei_model.annotLike_sequenceRepeatable = mei_annot+
mei_model.biblLike = mei_bibl | mei_biblStruct
mei_model.biblLike_alternation = mei_bibl | mei_biblStruct
mei_model.biblLike_sequence = mei_bibl, mei_biblStruct
mei_model.biblLike_sequenceOptional = mei_bibl?, mei_biblStruct?
mei_model.biblLike_sequenceOptionalRepeatable =
  mei_bibl*, mei_biblStruct*
mei_model.biblLike_sequenceRepeatable = mei_bibl+, mei_biblStruct+
mei_model.biblPart =
  mei_perfDuration
  | mei_model.editionLike
  | mei_model.respLike
  | mei_biblScope
  | mei_creation
  | mei_genre
  | mei_imprint
  | mei_physLoc
  | mei_recipient
  | mei_relatedItem
  | mei_series
  | mei_textLang
mei_model.captionLike = mei_caption
mei_model.chordPart = mei_artic | mei_note
mei_model.controlEventLike =
  mei_bend
  | mei_gliss
  | mei_model.stageDirLike
  | mei_sp
  | mei_cpMark
  | mei_metaMark
  | mei_model.fingeringLike
  | mei_model.controlEventLike.harmony
  | mei_caesura
  | mei_dir
  | mei_dynam
  | mei_ornam
  | mei_phrase
  | mei_tempo
mei_model.controlEventLike_alternation =
  mei_bend
  | mei_gliss
  | mei_model.stageDirLike_alternation
  | mei_sp
  | mei_cpMark
  | mei_metaMark
  | mei_model.fingeringLike_alternation
  | mei_model.controlEventLike.harmony_alternation
  | mei_caesura
  | mei_dir
  | mei_dynam
  | mei_ornam
  | mei_phrase
  | mei_tempo
mei_model.controlEventLike_sequence =
  mei_bend,
  mei_gliss,
  mei_model.stageDirLike_sequence,
  mei_sp,
  mei_cpMark,
  mei_metaMark,
  mei_model.fingeringLike_sequence,
  mei_model.controlEventLike.harmony_sequence,
  mei_caesura,
  mei_dir,
  mei_dynam,
  mei_ornam,
  mei_phrase,
  mei_tempo
mei_model.controlEventLike_sequenceOptional =
  mei_bend?,
  mei_gliss?,
  mei_model.stageDirLike_sequenceOptional?,
  mei_sp?,
  mei_cpMark?,
  mei_metaMark?,
  mei_model.fingeringLike_sequenceOptional?,
  mei_model.controlEventLike.harmony_sequenceOptional?,
  mei_caesura?,
  mei_dir?,
  mei_dynam?,
  mei_ornam?,
  mei_phrase?,
  mei_tempo?
mei_model.controlEventLike_sequenceOptionalRepeatable =
  mei_bend*,
  mei_gliss*,
  mei_model.stageDirLike_sequenceOptionalRepeatable*,
  mei_sp*,
  mei_cpMark*,
  mei_metaMark*,
  mei_model.fingeringLike_sequenceOptionalRepeatable*,
  mei_model.controlEventLike.harmony_sequenceOptionalRepeatable*,
  mei_caesura*,
  mei_dir*,
  mei_dynam*,
  mei_ornam*,
  mei_phrase*,
  mei_tempo*
mei_model.controlEventLike_sequenceRepeatable =
  mei_bend+,
  mei_gliss+,
  mei_model.stageDirLike_sequenceRepeatable+,
  mei_sp+,
  mei_cpMark+,
  mei_metaMark+,
  mei_model.fingeringLike_sequenceRepeatable+,
  mei_model.controlEventLike.harmony_sequenceRepeatable+,
  mei_caesura+,
  mei_dir+,
  mei_dynam+,
  mei_ornam+,
  mei_phrase+,
  mei_tempo+
mei_model.dateLike = mei_date
mei_model.dateLike_alternation = mei_date
mei_model.dateLike_sequence = mei_date
mei_model.dateLike_sequenceOptional = mei_date?
mei_model.dateLike_sequenceOptionalRepeatable = mei_date*
mei_model.dateLike_sequenceRepeatable = mei_date+
mei_model.dimLike = mei_depth | mei_dim | mei_height | mei_width
mei_model.dimLike_alternation =
  mei_depth | mei_dim | mei_height | mei_width
mei_model.dimLike_sequence = mei_depth, mei_dim, mei_height, mei_width
mei_model.dimLike_sequenceOptional =
  mei_depth?, mei_dim?, mei_height?, mei_width?
mei_model.dimLike_sequenceOptionalRepeatable =
  mei_depth*, mei_dim*, mei_height*, mei_width*
mei_model.dimLike_sequenceRepeatable =
  mei_depth+, mei_dim+, mei_height+, mei_width+
mei_model.editionLike = mei_edition
mei_model.editorialLike = mei_abbr | mei_expan
mei_model.editorialLike_alternation = mei_abbr | mei_expan
mei_model.editorialLike_sequence = mei_abbr, mei_expan
mei_model.editorialLike_sequenceOptional = mei_abbr?, mei_expan?
mei_model.editorialLike_sequenceOptionalRepeatable =
  mei_abbr*, mei_expan*
mei_model.editorialLike_sequenceRepeatable = mei_abbr+, mei_expan+
mei_model.endingLike = mei_ending
mei_model.eventLike =
  mei_model.keySigLike
  | mei_model.meterSigLike
  | mei_barLine
  | mei_chord
  | mei_clef
  | mei_clefGrp
  | mei_custos
  | mei_note
  | mei_pad
  | mei_rest
  | mei_space
mei_model.headLike = mei_head
mei_model.identifierLike = mei_identifier
mei_model.identifierLike_alternation = mei_identifier
mei_model.identifierLike_sequence = mei_identifier
mei_model.identifierLike_sequenceOptional = mei_identifier?
mei_model.identifierLike_sequenceOptionalRepeatable = mei_identifier*
mei_model.identifierLike_sequenceRepeatable = mei_identifier+
mei_model.imprintPart = mei_distributor | mei_publisher | mei_pubPlace
mei_model.incipLike = mei_incip
mei_model.instrDefLike = mei_instrDef
mei_model.keyAccidLike = mei_keyAccid
mei_model.keySigLike = mei_keySig
mei_model.keySigLike_alternation = mei_keySig
mei_model.keySigLike_sequence = mei_keySig
mei_model.keySigLike_sequenceOptional = mei_keySig?
mei_model.keySigLike_sequenceOptionalRepeatable = mei_keySig*
mei_model.keySigLike_sequenceRepeatable = mei_keySig+
mei_model.labelLike = mei_label | mei_labelAbbr
mei_model.layerDefLike = mei_layerDef
mei_model.layerLike = mei_layer
mei_model.layerLike_alternation = mei_layer
mei_model.layerLike_sequence = mei_layer
mei_model.layerLike_sequenceOptional = mei_layer?
mei_model.layerLike_sequenceOptionalRepeatable = mei_layer*
mei_model.layerLike_sequenceRepeatable = mei_layer+
mei_model.layerPart = mei_model.layerPart.cmn | mei_model.eventLike
mei_model.lbLike = mei_lb
mei_model.lbLike_alternation = mei_lb
mei_model.lbLike_sequence = mei_lb
mei_model.lbLike_sequenceOptional = mei_lb?
mei_model.lbLike_sequenceOptionalRepeatable = mei_lb*
mei_model.lbLike_sequenceRepeatable = mei_lb+
mei_model.mdivLike = mei_mdiv
mei_model.measurementLike = mei_model.numLike
mei_model.measurementLike_alternation = mei_model.numLike_alternation
mei_model.measurementLike_sequence = mei_model.numLike_sequence
mei_model.measurementLike_sequenceOptional =
  mei_model.numLike_sequenceOptional?
mei_model.measurementLike_sequenceOptionalRepeatable =
  mei_model.numLike_sequenceOptionalRepeatable*
mei_model.measurementLike_sequenceRepeatable =
  mei_model.numLike_sequenceRepeatable+
mei_model.meterSigLike = mei_meterSig | mei_meterSigGrp
mei_model.meterSigLike_alternation = mei_meterSig | mei_meterSigGrp
mei_model.meterSigLike_sequence = mei_meterSig, mei_meterSigGrp
mei_model.meterSigLike_sequenceOptional =
  mei_meterSig?, mei_meterSigGrp?
mei_model.meterSigLike_sequenceOptionalRepeatable =
  mei_meterSig*, mei_meterSigGrp*
mei_model.meterSigLike_sequenceRepeatable =
  mei_meterSig+, mei_meterSigGrp+
mei_model.milestoneLike.music =
  mei_model.pbLike | mei_cb | mei_colLayout | mei_sb
mei_model.milestoneLike.text =
  mei_model.lbLike | mei_model.pbLike | mei_cb | mei_colLayout
mei_model.nameLike =
  mei_model.nameLike.agent | mei_model.nameLike.place | mei_name
mei_model.nameLike_alternation =
  mei_model.nameLike.agent_alternation
  | mei_model.nameLike.place_alternation
  | mei_name
mei_model.nameLike_sequence =
  mei_model.nameLike.agent_sequence,
  mei_model.nameLike.place_sequence,
  mei_name
mei_model.nameLike_sequenceOptional =
  mei_model.nameLike.agent_sequenceOptional?,
  mei_model.nameLike.place_sequenceOptional?,
  mei_name?
mei_model.nameLike_sequenceOptionalRepeatable =
  mei_model.nameLike.agent_sequenceOptionalRepeatable*,
  mei_model.nameLike.place_sequenceOptionalRepeatable*,
  mei_name*
mei_model.nameLike_sequenceRepeatable =
  mei_model.nameLike.agent_sequenceRepeatable+,
  mei_model.nameLike.place_sequenceRepeatable+,
  mei_name+
mei_model.noteModifierLike = mei_accid | mei_artic | mei_dot
mei_model.noteModifierLike_alternation = mei_accid | mei_artic | mei_dot
mei_model.noteModifierLike_sequence = mei_accid, mei_artic, mei_dot
mei_model.noteModifierLike_sequenceOptional =
  mei_accid?, mei_artic?, mei_dot?
mei_model.noteModifierLike_sequenceOptionalRepeatable =
  mei_accid*, mei_artic*, mei_dot*
mei_model.noteModifierLike_sequenceRepeatable =
  mei_accid+, mei_artic+, mei_dot+
mei_model.numLike = mei_num
mei_model.numLike_alternation = mei_num
mei_model.numLike_sequence = mei_num
mei_model.numLike_sequenceOptional = mei_num?
mei_model.numLike_sequenceOptionalRepeatable = mei_num*
mei_model.numLike_sequenceRepeatable = mei_num+
mei_model.paracontentPart =
  mei_model.stageDirLike
  | mei_model.editLike
  | mei_model.transcriptionLike
  | mei_model.tableLike
  | mei_model.textPhraseLike
  | mei_model.lgLike
  | mei_model.listLike
  | mei_model.quoteLike
mei_model.partLike = mei_part
mei_model.partsLike = mei_parts
mei_model.pbLike = mei_pb
mei_model.pbLike_alternation = mei_pb
mei_model.pbLike_sequence = mei_pb
mei_model.pbLike_sequenceOptional = mei_pb?
mei_model.pbLike_sequenceOptionalRepeatable = mei_pb*
mei_model.pbLike_sequenceRepeatable = mei_pb+
mei_model.pLike = mei_p
mei_model.pLike_alternation = mei_p
mei_model.pLike_sequence = mei_p
mei_model.pLike_sequenceOptional = mei_p?
mei_model.pLike_sequenceOptionalRepeatable = mei_p*
mei_model.pLike_sequenceRepeatable = mei_p+
mei_model.relationLike = mei_relation | mei_relationList
mei_model.relationLike_alternation = mei_relation | mei_relationList
mei_model.relationLike_sequence = mei_relation, mei_relationList
mei_model.relationLike_sequenceOptional =
  mei_relation?, mei_relationList?
mei_model.relationLike_sequenceOptionalRepeatable =
  mei_relation*, mei_relationList*
mei_model.relationLike_sequenceRepeatable =
  mei_relation+, mei_relationList+
mei_model.rendLike = mei_rend | mei_stack
mei_model.rendLike_alternation = mei_rend | mei_stack
mei_model.rendLike_sequence = mei_rend, mei_stack
mei_model.rendLike_sequenceOptional = mei_rend?, mei_stack?
mei_model.rendLike_sequenceOptionalRepeatable = mei_rend*, mei_stack*
mei_model.rendLike_sequenceRepeatable = mei_rend+, mei_stack+
mei_model.repositoryLike = mei_repository
mei_model.repositoryLike_alternation = mei_repository
mei_model.repositoryLike_sequence = mei_repository
mei_model.repositoryLike_sequenceOptional = mei_repository?
mei_model.repositoryLike_sequenceOptionalRepeatable = mei_repository*
mei_model.repositoryLike_sequenceRepeatable = mei_repository+
mei_model.resourceLike = mei_facsimile | mei_genDesc | mei_performance
mei_model.respLike = mei_model.respLikePart | mei_respStmt
mei_model.respLikePart =
  mei_arranger
  | mei_author
  | mei_composer
  | mei_contributor
  | mei_editor
  | mei_funder
  | mei_librettist
  | mei_lyricist
  | mei_sponsor
mei_model.respLikePart_alternation =
  mei_arranger
  | mei_author
  | mei_composer
  | mei_contributor
  | mei_editor
  | mei_funder
  | mei_librettist
  | mei_lyricist
  | mei_sponsor
mei_model.respLikePart_sequence =
  mei_arranger,
  mei_author,
  mei_composer,
  mei_contributor,
  mei_editor,
  mei_funder,
  mei_librettist,
  mei_lyricist,
  mei_sponsor
mei_model.respLikePart_sequenceOptional =
  mei_arranger?,
  mei_author?,
  mei_composer?,
  mei_contributor?,
  mei_editor?,
  mei_funder?,
  mei_librettist?,
  mei_lyricist?,
  mei_sponsor?
mei_model.respLikePart_sequenceOptionalRepeatable =
  mei_arranger*,
  mei_author*,
  mei_composer*,
  mei_contributor*,
  mei_editor*,
  mei_funder*,
  mei_librettist*,
  mei_lyricist*,
  mei_sponsor*
mei_model.respLikePart_sequenceRepeatable =
  mei_arranger+,
  mei_author+,
  mei_composer+,
  mei_contributor+,
  mei_editor+,
  mei_funder+,
  mei_librettist+,
  mei_lyricist+,
  mei_sponsor+
mei_model.scoreDefLike = mei_scoreDef
mei_model.scoreLike = mei_score
mei_model.scorePart = mei_model.endingLike | mei_model.sectionLike
mei_model.sectionLike = mei_section
mei_model.sectionPart =
  mei_model.sectionPart.cmn
  | mei_model.endingLike
  | mei_model.scoreDefLike
  | mei_model.sectionLike
  | mei_model.staffDefLike
mei_model.staffDefLike = mei_staffDef
mei_model.staffDefPart =
  mei_model.keySigLike | mei_model.meterSigLike | mei_clef | mei_clefGrp
mei_model.staffGrpLike = mei_staffGrp
mei_model.staffLike = mei_staff
mei_model.staffPart = mei_model.ossiaLike | mei_model.layerLike
mei_model.sylLike = mei_syl
mei_model.textComponentLike =
  mei_model.tableLike
  | mei_model.pLike
  | mei_model.lgLike
  | mei_model.listLike
  | mei_model.quoteLike
mei_model.textComponentLike_alternation =
  mei_model.tableLike_alternation
  | mei_model.pLike_alternation
  | mei_model.lgLike_alternation
  | mei_model.listLike_alternation
  | mei_model.quoteLike_alternation
mei_model.textComponentLike_sequence =
  mei_model.tableLike_sequence,
  mei_model.pLike_sequence,
  mei_model.lgLike_sequence,
  mei_model.listLike_sequence,
  mei_model.quoteLike_sequence
mei_model.textComponentLike_sequenceOptional =
  mei_model.tableLike_sequenceOptional?,
  mei_model.pLike_sequenceOptional?,
  mei_model.lgLike_sequenceOptional?,
  mei_model.listLike_sequenceOptional?,
  mei_model.quoteLike_sequenceOptional?
mei_model.textComponentLike_sequenceOptionalRepeatable =
  mei_model.tableLike_sequenceOptionalRepeatable*,
  mei_model.pLike_sequenceOptionalRepeatable*,
  mei_model.lgLike_sequenceOptionalRepeatable*,
  mei_model.listLike_sequenceOptionalRepeatable*,
  mei_model.quoteLike_sequenceOptionalRepeatable*
mei_model.textComponentLike_sequenceRepeatable =
  mei_model.tableLike_sequenceRepeatable+,
  mei_model.pLike_sequenceRepeatable+,
  mei_model.lgLike_sequenceRepeatable+,
  mei_model.listLike_sequenceRepeatable+,
  mei_model.quoteLike_sequenceRepeatable+
mei_model.textPhraseLike =
  mei_model.pbLike | mei_model.textPhraseLike.limited
mei_model.textPhraseLike.limited =
  mei_model.figureLike
  | mei_model.msInline
  | mei_model.addressPart
  | mei_model.nameLike.label
  | mei_model.locrefLike
  | mei_model.addressLike
  | mei_model.annotLike
  | mei_model.biblLike
  | mei_model.dateLike
  | mei_model.dimLike
  | mei_model.editorialLike
  | mei_model.identifierLike
  | mei_model.lbLike
  | mei_model.measurementLike
  | mei_model.nameLike
  | mei_model.relationLike
  | mei_model.rendLike
  | mei_model.titleLike
  | mei_dedicatee
  | mei_dimensions
  | mei_extent
  | mei_symbol
  | mei_term
  | mei_model.qLike
  | mei_seg
mei_model.textPhraseLike.limited_alternation =
  mei_model.figureLike_alternation
  | mei_model.msInline_alternation
  | mei_model.addressPart_alternation
  | mei_model.nameLike.label_alternation
  | mei_model.locrefLike_alternation
  | mei_model.addressLike_alternation
  | mei_model.annotLike_alternation
  | mei_model.biblLike_alternation
  | mei_model.dateLike_alternation
  | mei_model.dimLike_alternation
  | mei_model.editorialLike_alternation
  | mei_model.identifierLike_alternation
  | mei_model.lbLike_alternation
  | mei_model.measurementLike_alternation
  | mei_model.nameLike_alternation
  | mei_model.relationLike_alternation
  | mei_model.rendLike_alternation
  | mei_model.titleLike_alternation
  | mei_dedicatee
  | mei_dimensions
  | mei_extent
  | mei_symbol
  | mei_term
  | mei_model.qLike_alternation
  | mei_seg
mei_model.textPhraseLike.limited_sequence =
  mei_model.figureLike_sequence,
  mei_model.msInline_sequence,
  mei_model.addressPart_sequence,
  mei_model.nameLike.label_sequence,
  mei_model.locrefLike_sequence,
  mei_model.addressLike_sequence,
  mei_model.annotLike_sequence,
  mei_model.biblLike_sequence,
  mei_model.dateLike_sequence,
  mei_model.dimLike_sequence,
  mei_model.editorialLike_sequence,
  mei_model.identifierLike_sequence,
  mei_model.lbLike_sequence,
  mei_model.measurementLike_sequence,
  mei_model.nameLike_sequence,
  mei_model.relationLike_sequence,
  mei_model.rendLike_sequence,
  mei_model.titleLike_sequence,
  mei_dedicatee,
  mei_dimensions,
  mei_extent,
  mei_symbol,
  mei_term,
  mei_model.qLike_sequence,
  mei_seg
mei_model.textPhraseLike.limited_sequenceOptional =
  mei_model.figureLike_sequenceOptional?,
  mei_model.msInline_sequenceOptional?,
  mei_model.addressPart_sequenceOptional?,
  mei_model.nameLike.label_sequenceOptional?,
  mei_model.locrefLike_sequenceOptional?,
  mei_model.addressLike_sequenceOptional?,
  mei_model.annotLike_sequenceOptional?,
  mei_model.biblLike_sequenceOptional?,
  mei_model.dateLike_sequenceOptional?,
  mei_model.dimLike_sequenceOptional?,
  mei_model.editorialLike_sequenceOptional?,
  mei_model.identifierLike_sequenceOptional?,
  mei_model.lbLike_sequenceOptional?,
  mei_model.measurementLike_sequenceOptional?,
  mei_model.nameLike_sequenceOptional?,
  mei_model.relationLike_sequenceOptional?,
  mei_model.rendLike_sequenceOptional?,
  mei_model.titleLike_sequenceOptional?,
  mei_dedicatee?,
  mei_dimensions?,
  mei_extent?,
  mei_symbol?,
  mei_term?,
  mei_model.qLike_sequenceOptional?,
  mei_seg?
mei_model.textPhraseLike.limited_sequenceOptionalRepeatable =
  mei_model.figureLike_sequenceOptionalRepeatable*,
  mei_model.msInline_sequenceOptionalRepeatable*,
  mei_model.addressPart_sequenceOptionalRepeatable*,
  mei_model.nameLike.label_sequenceOptionalRepeatable*,
  mei_model.locrefLike_sequenceOptionalRepeatable*,
  mei_model.addressLike_sequenceOptionalRepeatable*,
  mei_model.annotLike_sequenceOptionalRepeatable*,
  mei_model.biblLike_sequenceOptionalRepeatable*,
  mei_model.dateLike_sequenceOptionalRepeatable*,
  mei_model.dimLike_sequenceOptionalRepeatable*,
  mei_model.editorialLike_sequenceOptionalRepeatable*,
  mei_model.identifierLike_sequenceOptionalRepeatable*,
  mei_model.lbLike_sequenceOptionalRepeatable*,
  mei_model.measurementLike_sequenceOptionalRepeatable*,
  mei_model.nameLike_sequenceOptionalRepeatable*,
  mei_model.relationLike_sequenceOptionalRepeatable*,
  mei_model.rendLike_sequenceOptionalRepeatable*,
  mei_model.titleLike_sequenceOptionalRepeatable*,
  mei_dedicatee*,
  mei_dimensions*,
  mei_extent*,
  mei_symbol*,
  mei_term*,
  mei_model.qLike_sequenceOptionalRepeatable*,
  mei_seg*
mei_model.textPhraseLike.limited_sequenceRepeatable =
  mei_model.figureLike_sequenceRepeatable+,
  mei_model.msInline_sequenceRepeatable+,
  mei_model.addressPart_sequenceRepeatable+,
  mei_model.nameLike.label_sequenceRepeatable+,
  mei_model.locrefLike_sequenceRepeatable+,
  mei_model.addressLike_sequenceRepeatable+,
  mei_model.annotLike_sequenceRepeatable+,
  mei_model.biblLike_sequenceRepeatable+,
  mei_model.dateLike_sequenceRepeatable+,
  mei_model.dimLike_sequenceRepeatable+,
  mei_model.editorialLike_sequenceRepeatable+,
  mei_model.identifierLike_sequenceRepeatable+,
  mei_model.lbLike_sequenceRepeatable+,
  mei_model.measurementLike_sequenceRepeatable+,
  mei_model.nameLike_sequenceRepeatable+,
  mei_model.relationLike_sequenceRepeatable+,
  mei_model.rendLike_sequenceRepeatable+,
  mei_model.titleLike_sequenceRepeatable+,
  mei_dedicatee+,
  mei_dimensions+,
  mei_extent+,
  mei_symbol+,
  mei_term+,
  mei_model.qLike_sequenceRepeatable+,
  mei_seg+
mei_model.titleLike = mei_title
mei_model.titleLike_alternation = mei_title
mei_model.titleLike_sequence = mei_title
mei_model.titleLike_sequenceOptional = mei_title?
mei_model.titleLike_sequenceOptionalRepeatable = mei_title*
mei_model.titleLike_sequenceRepeatable = mei_title+
mei_model.titlePagePart =
  mei_accessRestrict
  | mei_availability
  | mei_byline
  | mei_contents
  | mei_dedication
  | mei_perfDuration
  | mei_perfMedium
  | mei_plateNum
  | mei_price
  | mei_sysReq
  | mei_useRestrict
  | mei_model.dateLike
  | mei_model.editionLike
  | mei_model.identifierLike
  | mei_model.respLikePart
  | mei_model.titleLike
  | mei_imprint
  | mei_series
  | mei_titlePart
  | mei_argument
  | mei_epigraph
  | mei_imprimatur
mei_accid =
  
  ## (accidental)  Records a temporary alteration to the pitch of a note.
  element accid {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.accid.log.attributes,
    mei_att.accid.vis.attributes,
    mei_att.accid.ges.attributes,
    mei_att.accid.anl.attributes,
    empty
  }
mei_actor =
  
  ## Name of an actor appearing within a cast list.
  element actor {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_address =
  
  ## Contains a postal address, for example of a publisher, an organization, or an individual.
  element address {
    (mei_addrLine+ | mei_model.addressPart+),
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_addrLine =
  
  ## (address line)  Single line of a postal address.
  element addrLine {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_ambitus =
  
  ## Range of a voice, instrument or piece.
  element ambitus {
    mei_ambNote,
    mei_ambNote,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.ambitus.anl.attributes,
    mei_att.ambitus.ges.attributes,
    mei_att.ambitus.log.attributes,
    mei_att.ambitus.vis.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_ambNote =
  
  ## Highest or lowest pitch in a score, staff, or layer.
  element ambNote {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.ambNote.log.attributes,
    mei_att.ambNote.vis.attributes,
    mei_att.ambNote.ges.attributes,
    mei_att.ambNote.anl.attributes,
    empty
  }
mei_analytic =
  
  ## (analytic level)  Contains bibliographic elements describing an item (e.g. an article or poem) published within a monograph or journal and not as an independent publication.
  element analytic {
    (mei_model.respLikePart | mei_respStmt | mei_title)*,
    mei_biblScope*,
    mei_identifier?,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.componentType.attributes,
    mei_att.dataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.recordType.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_annot =
  
  ## (annotation)  Provides a statement explaining the text or indicating the basis for an assertion.
  element annot {
    ((mei_model.headLike*, mei_model.textComponentLike*)
     | (text
        | mei_model.editLike
        | mei_model.textPhraseLike
        | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-annot-Check_annot_data-constraint-rule-129"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:annot[@data]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:notesStmt"
             "The @data attribute may only occur on an\x{a}" ~
             "            annotation within the notesStmt element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.annot.log.attributes,
    mei_att.annot.vis.attributes,
    mei_att.annot.ges.attributes,
    mei_att.annot.anl.attributes,
    mei_att.audience.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.plist.attributes,
    mei_att.source.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_arranger =
  
  ## A person or organization who transcribes a musical composition, usually for a different medium from that of the original; in an arrangement the musical substance remains essentially unchanged.
  element arranger {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_artic =
  
  ## (articulation)  An indication of how to play a note or chord.
  element artic {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.artic.log.attributes,
    mei_att.artic.vis.attributes,
    mei_att.artic.ges.attributes,
    mei_att.artic.anl.attributes,
    empty
  }
mei_author =
  
  ## The name of the creator of the intellectual content of a non-musical, literary work.
  element author {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_barLine =
  
  ## Vertical line drawn through one or more staves that divides musical notation into metrical units.
  element barLine {
    empty
    >> sch:pattern [
         id = "mei-barLine-Check_barLinetaktplace-constraint-rule-130"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:barLine[@taktplace]"
           "\x{a}" ~
           "               "
           sch:let [ name = "staff" value = "ancestor::mei:staff/@n" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "staffpos"
             value =
               "count(ancestor::mei:staff/preceding-sibling::mei:staff) + 1"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@taktplace) <= number(2 * preceding::mei:staffDef[@n=$staff and @lines][1]/@lines)"
             "The value of @taktplace must be less than or equal to two times the number of staff\x{a}" ~
             "            lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    mei_att.barLine.log.attributes,
    mei_att.barLine.vis.attributes,
    mei_att.barLine.ges.attributes,
    mei_att.barLine.anl.attributes,
    empty
  }
mei_bibl =
  
  ## (bibliographic reference)  Provides a loosely-structured bibliographic citation in which the sub-components may or may not be explicitly marked.
  element bibl {
    (text
     | mei_model.biblPart
     | mei_model.imprintPart
     | mei_model.textPhraseLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.pointing.attributes,
    empty
  }
mei_biblList =
  
  ## List of bibliographic references.
  element biblList {
    mei_model.headLike*,
    (((mei_label?, mei_model.biblLike) | mei_biblList)*)
    >> sch:pattern [
         id = "mei-biblList-checkBiblLabels-constraint-rule-131"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:biblList[mei:label]"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "count(mei:label) = count(mei:bibl)"
             "When labels are used,\x{a}" ~
             "            usually each bibliographic item has one."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_biblScope =
  
  ## (scope of citation)  Defines the scope of a bibliographic reference, for example as a list of page numbers, or a named subdivision of a larger work.
  element biblScope {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.extent.attributes,
    mei_att.lang.attributes,
    
    ##
    attribute from { xsd:token }?,
    
    ##
    attribute to { xsd:token }?,
    empty
  }
mei_biblStruct =
  
  ## (structured bibliographic citation)  Contains a bibliographic citation in which bibliographic sub-elements must appear in a specified order.
  element biblStruct {
    (mei_analytic*,
     (mei_monogr, mei_series*)+,
     (mei_model.annotLike | mei_identifier | mei_relatedItem)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    mei_att.pointing.attributes,
    mei_att.recordType.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_body =
  
  ## Contains the whole of a single musical text, excluding any front or back matter.
  element body {
    (mei_model.divLike | mei_model.mdivLike)+,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_caesura =
  
  ## Break, pause, or interruption in the normal tempo of a composition. Typically indicated by "railroad tracks", i.e., two diagonal slashes.
  element caesura {
    empty
    >> sch:pattern [
         id =
           "mei-caesura-caesura_start-type_attributes_required-constraint-rule-132"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:caesura"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.caesura.anl.attributes,
    mei_att.caesura.ges.attributes,
    mei_att.caesura.log.attributes,
    mei_att.caesura.vis.attributes,
    empty
  }
mei_caption =
  
  ## A label which accompanies an illustration or a table.
  element caption {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_castGrp =
  
  ## (cast group)  Groups one or more individual castItem elements within a cast list.
  element castGrp {
    (mei_castItem | mei_castGrp | mei_roleDesc)+,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_castItem =
  
  ## Contains a single entry within a cast list, describing either a single role or a list of non-speaking roles.
  element castItem {
    (text | mei_role | mei_roleDesc | mei_actor | mei_perfRes)+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_castList =
  
  ## Contains a single cast list or dramatis personae.
  element castList {
    mei_model.headLike*,
    (mei_castItem | mei_castGrp)+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_cb =
  
  ## (column beginning)  An empty formatting element that forces text to begin in a new column.
  element cb {
    empty,
    mei_att.basic.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.responsibility.attributes,
    mei_att.source.attributes,
    mei_att.typed.attributes,
    
    ## Records the column number.
    attribute n { xsd:positiveInteger }
    >> sch:pattern [
         id = "mei-cb-n-check_cb-constraint-rule-133"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:cb"
           "\x{a}" ~
           "              "
           sch:let [
             name = "totalColumns"
             value = "preceding::mei:colLayout[1]/@cols"
           ]
           "\x{a}" ~
           "              "
           sch:assert [
             test = "preceding::mei:colLayout"
             "Column beginning must be preceded by a\x{a}" ~
             "                colLayout element."
           ]
           "\x{a}" ~
           "              "
           sch:assert [
             test = "@n <= $totalColumns"
             "The value of @n should be less than or equal\x{a}" ~
             "                to the value of @cols ("
             sch:value-of [ select = "$totalColumns" ]
             ") of the preceding\x{a}" ~
             "                colLayout element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    empty
  }
mei_chord =
  
  ## A simultaneous sounding of two or more notes in the same layer *with the same duration*.
  element chord {
    (mei_model.chordPart
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.sylLike
     | mei_model.transcriptionLike
     | mei_model.verseLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.chord.log.attributes,
    mei_att.chord.vis.attributes,
    mei_att.chord.ges.attributes,
    mei_att.chord.anl.attributes,
    empty
  }
mei_clef =
  
  ## Indication of the exact location of a particular note on the staff and, therefore, the other notes as well.
  element clef {
    empty
    >> sch:pattern [
         id = "mei-clef-Clef_position_lines-constraint-rule-134"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[@lines]]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@line) <= number(ancestor::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The clef position must be less than or equal to the number of lines of an ancestor\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-clef-Clef_position_nolines-constraint-rule-135"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[not(@lines)]]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@line) <= number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The clef position must be less than or equal to the number of lines of a preceding\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.event.attributes,
    mei_att.facsimile.attributes,
    mei_att.clef.anl.attributes,
    mei_att.clef.ges.attributes,
    mei_att.clef.log.attributes,
    mei_att.clef.vis.attributes,
    empty
  }
mei_clefGrp =
  
  ## (clef group)  A set of simultaneously-occurring clefs.
  element clefGrp {
    mei_clef+,
    mei_att.common.attributes,
    mei_att.event.attributes,
    mei_att.facsimile.attributes,
    mei_att.clefGrp.log.attributes,
    mei_att.clefGrp.vis.attributes,
    mei_att.clefGrp.ges.attributes,
    mei_att.clefGrp.anl.attributes,
    empty
  }
mei_colLayout =
  
  ## (column layout)  An empty formatting element that signals the start of columnar layout.
  element colLayout {
    empty,
    mei_att.common.attributes,
    mei_att.source.attributes,
    
    ## Records the number of columns.
    attribute cols { xsd:positiveInteger },
    empty
  }
mei_composer =
  
  ## The name of the creator of the intellectual content of a musical work.
  element composer {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_contributor =
  
  ## Names of individuals, institutions, or organizations responsible for contributions to the intellectual content of a work, where the specialized elements for authors, editors, etc. do not suffice or do not apply.
  element contributor {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "mei-contributor-check_contributor_role-constraint-rule-136"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:contributor"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(matches(normalize-space(lower-case(@role)),               '(arranger|author|composer|contributor|editor|funder|librettist|lyricist|sponsor)'))"
             "The value of @role must not contain the name of another element available in this\x{a}" ~
             "            context."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Used to specify the contributor's function.
    attribute role { text }?,
    empty
  }
mei_creation =
  
  ## Non-bibliographic details of the creation of an intellectual entity, in narrative form, such as the date, place, and circumstances of its composition. More detailed information may be captured within the history element.
  element creation {
    mei_model.headLike*,
    (text | mei_dedication | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_custos =
  
  ## Symbol placed at the end of a line of music to indicate the first note of the next line. Sometimes called a "direct".
  element custos {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.source.attributes,
    mei_att.custos.log.attributes,
    mei_att.custos.vis.attributes,
    mei_att.custos.ges.attributes,
    mei_att.custos.anl.attributes,
    empty
  }
mei_date =
  
  ## A string identifying a point in time or the time period between two such points.
  element date {
    (text | mei_model.textPhraseLike)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.calendared.attributes,
    mei_att.datable.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_dedicatee =
  
  ## Entity to whom a creative work is formally offered.
  element dedicatee {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id = "mei-dedicatee-check_dedicatee-constraint-rule-137"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dedicatee"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(ancestor::mei:dedicatee)"
             "The dedicatee element may not be\x{a}" ~
             "            recursively nested."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_depth =
  
  ## Description of a measurement taken through a three-dimensional object.
  element depth {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.quantity.attributes,
    empty
  }
mei_desc =
  
  ## (description)  Container for text that briefly describes the feature to which it is attached, including its intended usage, purpose, or application as appropriate.
  element desc {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.source.attributes,
    empty
  }
mei_dim =
  
  ## (dimension)  Any single dimensional specification.
  element dim {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.quantity.attributes,
    
    ## Aspect of the object being measured.
    ## Suggested values include: 1] alt; 2] angle; 3] circum; 4] depth; 5] diameter; 6] elevation; 7] height; 8] length; 9] radius; 10] relief; 11] width
    attribute form {
      
      ## Altitude. Refers to the distance above a given level, commonly mean sea level.
      "alt"
      | 
        ## Angle. Amount of rotation needed to bring one line or plane into coincidence with another.
        "angle"
      | 
        ## Circumference of a circular area.
        "circum"
      | 
        ## Dimension taken through an object or body of material, usually downward from an upper surface, horizontally inward from an outer surface, or from top to bottom of something regarded as one of several layers.
        "depth"
      | 
        ## Length of a straight line passing through the center of a circle or sphere and meeting the circumference or surface at each end.
        "diameter"
      | 
        ## Distance to which something has been raised or uplifted above a level, e.g. a hill's elevation above the surrounding country.
        "elevation"
      | 
        ## Denotes extent upward (as from foot to head) as well as any measurable distance above a given level.
        "height"
      | 
        ## Measure of the greatest dimension of a plane or solid figure.
        "length"
      | 
        ## Half the diameter of a circular, spherical, or cylindrical object.
        "radius"
      | 
        ## Projection of a figure or part from the plane on which it is formed.
        "relief"
      | 
        ## Extent from side to side; breadth.
        "width"
      | xsd:NMTOKEN
    },
    empty
  }
mei_dimensions =
  
  ## Information about the physical size of an entity; usually includes numerical data.
  element dimensions {
    mei_macro.struc-unstrucContent
    >> sch:pattern [
         id = "mei-dimensions-check_dimensions-constraint-rule-138"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:physDesc/mei:dimensions"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(count(mei:depth) > 1)"
             "The depth element may only appear\x{a}" ~
             "            once."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(count(mei:height) > 1)"
             "The height element may only appear\x{a}" ~
             "            once."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(count(mei:width) > 1)"
             "The width element may only appear\x{a}" ~
             "            once."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.lang.attributes,
    mei_att.measurement.attributes,
    empty
  }
mei_dir =
  
  ## (directive)  An instruction expressed as a combination of text and symbols  such as segno and coda symbols, fermatas over a bar line, etc., typically above, below, or between staves, but not on the staff  that is not encoded elsewhere in more specific elements, like tempo or dynam.
  element dir {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.graphicPrimitiveLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-dir-dir_start-type_attributes_required-constraint-rule-139"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dir[not(ancestor::mei:syllable)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.dir.log.attributes,
    mei_att.dir.vis.attributes,
    mei_att.dir.ges.attributes,
    mei_att.dir.anl.attributes,
    empty
  }
mei_distributor =
  
  ## Person or agency, other than a publisher, from which access (including electronic access) to a bibliographic entity may be obtained.
  element distributor {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_div =
  
  ## (division)  Major structural division of text, such as a preface, chapter or section.
  element div {
    (mei_model.headLike | mei_model.milestoneLike.text)*,
    ((mei_model.divLike
      | mei_model.figureLike
      | mei_model.textComponentLike
      | mei_sp),
     mei_model.milestoneLike.text*)*,
    mei_att.basic.attributes,
    mei_att.classed.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    
    ## Characterizes the textual division in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] abstract; 2] ack; 3] appendix; 4] bibliography; 5] colophon; 6] contents; 7] dedication; 8] frontispiece; 9] glossary; 10] half-title; 11] index; 12] annotations; 13] preface
    attribute type {
      
      ## A summary of the content of a text as continuous prose.
      "abstract"
      | 
        ## A formal declaration of acknowledgment by the author in which persons and institutions are thanked for their part in the creation of a text.
        "ack"
      | 
        ## An ancillary self-contained section of a work, often providing additional but in some sense extra-canonical text.
        "appendix"
      | 
        ## A list of bibliographic citations.
        "bibliography"
      | 
        ## A statement appearing at the end of a book describing the conditions of its physical production.
        "colophon"
      | 
        ## A table of contents, specifying the structure of a work and listing its constituents. The list element should be used to mark its structure.
        "contents"
      | 
        ## A formal offering or dedication of a text to one or more persons or institutions by the author.
        "dedication"
      | 
        ## A pictorial frontispiece, possibly including some text.
        "frontispiece"
      | 
        ## A list of terms associated with definition texts (glosses).
        "glossary"
      | 
        ## A page containing only the title of a book  as opposed to the title page, which also lists subtitle, author, imprint and similar data.
        "half-title"
      | 
        ## Any form of index to the work.
        "index"
      | 
        ## A section in which annotations on the text are gathered together.
        "annotations"
      | 
        ## A foreword or preface addressed to the reader in which the author or publisher explains the content, purpose, or origin of the text.
        "preface"
      | xsd:NMTOKENS
    }?,
    empty
  }
mei_dot =
  
  ## Dot of augmentation or division.
  element dot {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.dot.log.attributes,
    mei_att.dot.vis.attributes,
    mei_att.dot.ges.attributes,
    mei_att.dot.anl.attributes,
    empty
  }
mei_dynam =
  
  ## (dynamic)  Indication of the volume of a note, phrase, or section of music.
  element dynam {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-dynam-dynam_start-type_attributes_required-constraint-rule-140"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dynam"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             " Must have one of\x{a}" ~
             "            the attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-dynam-dynam_end-type_attributes-constraint-rule-141"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:dynam[@val2]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "When @val2 is present, either\x{a}" ~
             "            @dur, @dur.ges, @endid, or @tstamp2 must also be present."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.dynam.log.attributes,
    mei_att.dynam.vis.attributes,
    mei_att.dynam.ges.attributes,
    mei_att.dynam.anl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_edition =
  
  ## (edition designation)  A word or text phrase that indicates a difference in either content or form between the item being described and a related item previously issued by the same publisher/distributor (e.g. 2nd edition, version 2.0, etc.), or simultaneously issued by either the same publisher/distributor or another publisher/distributor (e.g. large print edition, British edition, etc.).
  element edition {
    (text
     | mei_model.textPhraseLike.limited
     | mei_editor
     | mei_respStmt
     | mei_textLang)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_editor =
  
  ## The name of the individual(s), institution(s) or organization(s) acting in an editorial capacity.
  element editor {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_ending =
  
  ## Alternative ending for a repeated passage of music; i.e., prima volta, seconda volta, etc.
  element ending {
    mei_expansion*,
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.milestoneLike.music
     | mei_model.relationLike
     | mei_model.scoreDefLike
     | mei_model.sectionLike
     | mei_model.sectionPart.cmn
     | mei_model.staffDefLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.ending.anl.attributes,
    mei_att.ending.ges.attributes,
    mei_att.ending.log.attributes,
    mei_att.ending.vis.attributes,
    mei_att.facsimile.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_event =
  
  ## Contains a free-text event description.
  element event {
    mei_model.headLike*,
    ((mei_model.eventPart | mei_castList | mei_eventList)*
     | (mei_model.pLike | mei_model.tableLike | mei_list)*),
    mei_biblList*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.calendared.attributes,
    mei_att.datable.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_eventList =
  
  ## Contains historical information given as a sequence of significant past events.
  element eventList {
    mei_model.headLike*,
    ((mei_name
      | mei_model.addressLike
      | mei_model.dateLike
      | mei_model.nameLike.agent
      | mei_model.nameLike.geogName)?,
     (mei_event | mei_eventList))*,
    mei_biblList*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_expansion =
  
  ## Indicates how a section may be programmatically expanded into its 'through-composed' form.
  element expansion {
    empty,
    mei_att.common.attributes,
    mei_att.plist.attributes,
    mei_att.source.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_extent =
  
  ## Used to express size in terms other than physical dimensions, such as number of pages, records, bytes, physical components, etc.
  element extent {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.quantity.attributes,
    empty
  }
mei_funder =
  
  ## Names of individuals, institutions, or organizations responsible for funding. Funders provide financial support for a project; they are distinct from sponsors, who provide intellectual support and authority.
  element funder {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_genre =
  
  ## Term or terms that designate a category characterizing a particular style, form, or content.
  element genre {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_group =
  
  ## Contains a composite musical text, grouping together a sequence of distinct musical texts (or groups of such musical texts) which are regarded as a unit for some purpose, for example, the collected works of a composer.
  element group {
    (mei_music | mei_group),
    (mei_music | mei_group)*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_grpSym =
  
  ## (group symbol)  A brace or bracket used to group two or more staves of a score or part.
  element grpSym {
    (mei_model.labelLike*)
    >> sch:pattern [
         id =
           "mei-grpSym-check_grpSym_attributes_scoreDef-constraint-rule-142"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:grpSym[parent::mei:scoreDef]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid and @endid and @level"
             "In scoreDef, grpSym must have startid,\x{a}" ~
             "            endid, and level attributes."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-grpSym-check_grpSym_attributes_staffDef-constraint-rule-143"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:grpSym[parent::mei:staffGrp]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "not(@startid or @endid or @level)"
             "In staffGrp, grpSym must not have\x{a}" ~
             "            startid, endid, or level attributes."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.grpSym.log.attributes,
    mei_att.grpSym.vis.attributes,
    mei_att.grpSym.ges.attributes,
    mei_att.grpSym.anl.attributes,
    empty
  }
mei_head =
  
  ## (heading)  Contains any heading, for example, the title of a section of text, or the heading of a list.
  element head {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_height =
  
  ## Description of the vertical size of an object.
  element height {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.quantity.attributes,
    empty
  }
mei_identifier =
  
  ## An alpha-numeric string that establishes the identity of the described material.
  element identifier {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_imprint =
  
  ## Information relating to the publication or distribution of a bibliographic item.
  element imprint {
    (text
     | mei_model.imprintPart
     | mei_model.textPhraseLike
     | mei_model.transcriptionLike
     | mei_respStmt)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_incip =
  
  ## (incipit)  The opening music and/or words of a musical or textual work.
  element incip {
    mei_model.headLike*,
    mei_tempo?,
    mei_role?,
    (mei_clef | mei_clefGrp)?,
    (mei_perfRes | mei_perfResList)?,
    mei_key?,
    mei_meter?,
    mei_mensuration?,
    (mei_model.annotLike
     | mei_model.graphicLike
     | mei_model.scoreLike
     | mei_incipCode
     | mei_incipText)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    empty
  }
mei_keyAccid =
  
  ## (key accidental)  Accidental in a key signature.
  element keyAccid {
    empty
    >> sch:pattern [
         id = "mei-keyAccid-Check_keyAccidPlacement-constraint-rule-144"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:keyAccid"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "(@x and @y) or @pname or @loc"
             "One of the following is required: @x and\x{a}" ~
             "            @y attribute pair, @pname attribute, or @loc attribute. "
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.keyAccid.anl.attributes,
    mei_att.keyAccid.ges.attributes,
    mei_att.keyAccid.log.attributes,
    mei_att.keyAccid.vis.attributes,
    
    ## Specifies whether enharmonic (written) values or implicit ("perform-able") values are allowed.
    attribute form {
      
      ## Only performed values (sharp, flat, natural) allowed.
      "implicit"
      | 
        ## All enharmonic (written) values allowed.
        "explicit"
    }?,
    empty
  }
mei_keySig =
  
  ## (key signature)  Written key signature.
  element keySig {
    ((mei_model.keyAccidLike | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-keySig-check_keyAccid_oct-constraint-rule-145"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:keySig[mei:keyAccid[@oct]]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:keyAccid[@oct]) = count(mei:keyAccid)"
             "If the @oct attribute\x{a}" ~
             "            appears on any keyAccid element, it must be provided on all keyAccid\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-keySig-check_keySig_editorial-constraint-rule-146"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:keySig/mei:*[local-name() eq 'add' or local-name() eq 'corr'             or local-name() eq 'damage' or local-name() eq 'del' or local-name() eq 'orig' or              local-name() eq 'reg' or local-name() eq 'restore' or local-name() eq 'sic' or              local-name() eq 'supplied' or local-name() eq 'unclear']"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:keyAccid) = count(mei:*)"
             "Only keyAccid elements are allowed\x{a}" ~
             "            here."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.keySig.anl.attributes,
    mei_att.keySig.ges.attributes,
    mei_att.keySig.log.attributes,
    mei_att.keySig.vis.attributes,
    empty
  }
mei_label =
  
  ## A container for document text that identifies the feature to which it is attached. For a "tool tip" or other generated label, use the label attribute.
  element label {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.source.attributes,
    empty
  }
mei_labelAbbr =
  
  ## A label on the pages following the first.
  element labelAbbr {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.source.attributes,
    empty
  }
mei_layer =
  
  ## An independent stream of events on a staff.
  element layer {
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.layerPart
     | mei_model.milestoneLike.music
     | mei_model.transcriptionLike)*,
    mei_att.basic.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    mei_att.typed.attributes,
    mei_att.layer.log.attributes,
    mei_att.layer.vis.attributes,
    mei_att.layer.ges.attributes,
    mei_att.layer.anl.attributes,
    empty
  }
mei_layerDef =
  
  ## (layer definition)  Container for layer meta-information.
  element layerDef {
    mei_model.labelLike*,
    mei_model.instrDefLike*,
    mei_ambitus?,
    mei_att.basic.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    mei_att.typed.attributes,
    mei_att.layerDef.log.attributes,
    mei_att.layerDef.vis.attributes,
    mei_att.layerDef.ges.attributes,
    mei_att.layerDef.anl.attributes,
    empty
  }
mei_lb =
  
  ## (line beginning)  An empty formatting element that forces text to begin on a new line.
  element lb {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.source.attributes,
    empty
  }
mei_lg =
  
  ## (line group)  May be used for any section of text that is organized as a group of lines; however, it is most often used for a group of verse lines functioning as a formal unit, e.g. a stanza, refrain, verse paragraph, etc.
  element lg {
    mei_model.headLike*,
    (mei_model.lLike | mei_model.lgLike),
    (mei_model.lLike | mei_model.lgLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.lyrics.ges.attributes,
    mei_att.lyrics.log.attributes,
    mei_att.lyrics.vis.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_librettist =
  
  ## Person or organization who is a writer of the text of an opera, oratorio, etc.
  element librettist {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_lyricist =
  
  ## Person or organization who is a writer of the text of a song.
  element lyricist {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_mdiv =
  
  ## (musical division)  Contains a subdivision of the body of a musical text.
  element mdiv {
    ((mei_model.scoreLike?, mei_model.partsLike?)
     | mei_model.mdivLike*),
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.mdiv.anl.attributes,
    mei_att.mdiv.ges.attributes,
    mei_att.mdiv.log.attributes,
    mei_att.mdiv.vis.attributes,
    empty
  }
mei_mei =
  
  ## Contains a single MEI-conformant document, consisting of an MEI header and a musical text, either in isolation or as part of an meiCorpus element.
  element mei {
    mei_meiHead,
    mei_music
    >> sch:pattern [
         id = "mei-mei-Check_staff-constraint-rule-147"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:*[@staff]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "every $i in tokenize(normalize-space(@staff), '\s+') satisfies $i=//mei:staffDef/@n"
             "The values in @staff must correspond to @n attribute of a staffDef\x{a}" ~
             "            element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.id.attributes,
    mei_att.meiVersion.attributes,
    mei_att.responsibility.attributes,
    empty
  }
mei_monogr =
  
  ## (monograph level)  Contains bibliographic elements describing an item, for example, a published book or journal, score, recording, or an unpublished manuscript.
  element monogr {
    ((((mei_model.respLikePart | mei_respStmt),
       (mei_model.respLikePart | mei_respStmt)*,
       mei_model.titleLike+,
       (mei_editor | mei_model.identifierLike | mei_respStmt)*)
      | (mei_model.titleLike+,
         (mei_model.respLikePart
          | mei_model.identifierLike
          | mei_respStmt)*))?,
     (mei_model.annotLike | mei_corpName)*,
     (mei_model.editionLike,
      (mei_model.identifierLike | mei_editor | mei_respStmt)*)*,
     mei_imprint,
     (mei_imprint | mei_extent | mei_biblScope)*),
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.recordType.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_music =
  
  ## Contains a single musical text of any kind, whether unitary or composite, for example, an etude, opera, song cycle, symphony, or anthology of piano solos.
  element music {
    mei_model.resourceLike*,
    mei_macro.musicPart,
    mei_att.common.attributes,
    mei_att.meiVersion.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_name =
  
  ## Proper noun or noun phrase.
  element name {
    ((text
      | mei_model.textPhraseLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-name-nameParts-constraint-rule-148"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:name"
           "\x{a}" ~
           "               "
           sch:assert [
             role = "warning"
             test = "not(mei:geogName or mei:persName or mei:corpName)"
             "Recommended practice is to use name elements to capture sub-parts of a generic\x{a}" ~
             "            name."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.basic.attributes,
    mei_att.bibl.attributes,
    mei_att.classed.attributes,
    mei_att.edit.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.linking.attributes,
    mei_att.name.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    
    ## Characterizes the name in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] person; 2] corporation; 3] location; 4] process; 5] style; 6] time
    attribute type {
      
      ## A personal name.
      "person"
      | 
        ## Name of a corporate body.
        "corporation"
      | 
        ## Name of a location.
        "location"
      | 
        ## Name of a process or software application.
        "process"
      | 
        ## Name of a musical style; i.e., form, genre, technique, etc.
        "style"
      | 
        ## Name of a period of time.
        "time"
      | xsd:NMTOKENS
    }?,
    empty
  }
mei_note =
  
  ## A single pitched event. 
  element note {
    (mei_model.noteModifierLike
     | mei_model.verseLike
     | mei_model.sylLike
     | mei_model.appLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.note.log.attributes,
    mei_att.note.vis.attributes,
    mei_att.note.ges.attributes,
    mei_att.note.anl.attributes,
    empty
  }
mei_num =
  
  ## (number)  Numeric information in any form.
  element num {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.measurement.attributes,
    mei_att.ranging.attributes,
    
    ## Numeric value capturing a measurement or count. Can only be interpreted in combination with the unit attribute.
    attribute value { xsd:decimal }?,
    empty
  }
mei_ornam =
  
  ## An element indicating an ornament that is not a mordent, turn, or trill. 
  element ornam {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.graphicPrimitiveLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-ornam-ornam_start-type_attributes_required-constraint-rule-149"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:ornam"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.ornam.log.attributes,
    mei_att.ornam.vis.attributes,
    mei_att.ornam.ges.attributes,
    mei_att.ornam.anl.attributes,
    empty
  }
mei_p =
  
  ## (paragraph)  One or more text phrases that form a logical prose passage.
  element p {
    (text | mei_model.paracontentPart)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_pad =
  
  ## (padding)  An indication of extra visual space between notational elements.
  element pad {
    empty,
    mei_att.common.attributes,
    mei_att.pad.log.attributes,
    mei_att.pad.vis.attributes,
    mei_att.pad.ges.attributes,
    mei_att.pad.anl.attributes,
    empty
  }
mei_part =
  
  ## An alternative visual rendition of the score from the point of view of a particular performer (or group of performers).
  element part {
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.milestoneLike.music
     | mei_model.scoreDefLike
     | mei_model.scorePart
     | mei_model.staffDefLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.part.log.attributes,
    mei_att.part.vis.attributes,
    mei_att.part.ges.attributes,
    mei_att.part.anl.attributes,
    empty
  }
mei_parts =
  
  ## Provides a container for performers' parts.
  element parts {
    mei_model.partLike*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.parts.log.attributes,
    mei_att.parts.vis.attributes,
    mei_att.parts.ges.attributes,
    mei_att.parts.anl.attributes,
    empty
  }
mei_pb =
  
  ## (page beginning)  An empty formatting element that forces text to begin on a new page.
  element pb {
    mei_macro.metaLike.page,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.pointing.attributes,
    mei_att.source.attributes,
    mei_att.pb.anl.attributes,
    mei_att.pb.ges.attributes,
    mei_att.pb.log.attributes,
    mei_att.pb.vis.attributes,
    empty
  }
mei_pgDesc =
  
  ## (page description)  Contains a brief prose description of the appearance or description of the content of a physical page.
  element pgDesc {
    (text
     | mei_model.graphicPrimitiveLike
     | mei_model.textComponentLike
     | mei_model.annotLike
     | mei_model.locrefLike)*,
    mei_att.common.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_pgFoot =
  
  ## (page footer)  A running footer on the first page. Also, used to temporarily override a running footer on individual pages.
  element pgFoot {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_model.appLike
     | mei_anchoredText)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Records horizontal alignment of the page footer.
    attribute halign { mei_data.HORIZONTALALIGNMENT }?,
    empty
  }
mei_pgFoot2 =
  
  ## (page footer 2)  A running footer on the pages following the first.
  element pgFoot2 {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_model.appLike
     | mei_anchoredText)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Records horizontal alignment of the page footer. Use multiple values to capture an alternating pattern.
    attribute halign {
      list { mei_data.HORIZONTALALIGNMENT+ }
    }?,
    empty
  }
mei_pgHead =
  
  ## (page header)  A running header on the first page. Also, used to temporarily override a running header on individual pages.
  element pgHead {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_model.appLike
     | mei_anchoredText)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Records horizontal alignment of the page header.
    attribute halign { mei_data.HORIZONTALALIGNMENT }?,
    empty
  }
mei_pgHead2 =
  
  ## (page header 2)  A running header on the pages following the first.
  element pgHead2 {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_model.appLike
     | mei_anchoredText)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Records horizontal alignment of the page header. Use multiple values to capture an alternating pattern.
    attribute halign {
      list { mei_data.HORIZONTALALIGNMENT+ }
    }?,
    empty
  }
mei_phrase =
  
  ## Indication of 1) a "unified melodic idea" or 2) performance technique.
  element phrase {
    (mei_curve*)
    >> sch:pattern [
         id =
           "mei-phrase-phrase_start-_and_end-type_attributes_required-constraint-rule-150"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:phrase"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@dur or @dur.ges or @endid or @tstamp2"
             "Must have one of the attributes:\x{a}" ~
             "            dur, dur.ges, endid, or tstamp2."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-phrase-phrase_containing_curve-constraint-rule-151"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:phrase[mei:curve[@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or              @startho or @endho or @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2]]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@bezier or @bulge or @curvedir or @lform or @lwidth or @ho or @startho or @endho or                @to or @startto or @endto or @vo or @startvo or @endvo or @x or @y or @x2 or @y2)"
             role = "warning"
             "The visual attributes of the phrase (@bezier, @bulge, @curvedir, @lform,\x{a}" ~
             "            @lwidth, @ho, @startho, @endho, @to, @startto, @endto, @vo, @startvo, @endvo, @x, @y,\x{a}" ~
             "            @x2, and @y2) will be overridden by visual attributes of the contained curve\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.phrase.log.attributes,
    mei_att.phrase.vis.attributes,
    mei_att.phrase.ges.attributes,
    mei_att.phrase.anl.attributes,
    empty
  }
mei_physLoc =
  
  ## (physical location)  Groups information about the current physical location of a bibliographic item, such as the repository in which it is located and its shelf mark(s), and its previous locations.
  element physLoc {
    mei_model.headLike*,
    (mei_model.repositoryLike, mei_model.identifierLike*)*,
    mei_history?,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_publisher =
  
  ## Name of the organization responsible for the publication of a bibliographic item.
  element publisher {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_pubPlace =
  
  ## (publication place)  Name of the place where a bibliographic item was published.
  element pubPlace {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_recipient =
  
  ## The name of the individual(s), institution(s) or organization(s) receiving correspondence.
  element recipient {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_relatedItem =
  
  ## (related item)  Contains or references another bibliographic item which is related to the present one.
  element relatedItem {
    mei_model.biblLike*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.facsimile.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    
    ## Describes the relationship between the entity identified by the relatedItem element and the resource described in the parent element, i.e., bibl, source or relatedItem.
    attribute rel { mei_data.MODSRELATIONSHIP },
    empty
  }
mei_relation =
  
  ## Describes a relationship or linkage amongst entities.
  element relation {
    empty
    >> sch:pattern [
         id = "mei-relation-FRBR_relation-constraint-rule-152"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:relationList/mei:relation[parent::mei:work or parent::mei:expression or                        parent::mei:source or parent::mei:item]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "matches(@rel, 'hasAbridgement') or             matches(@rel, 'hasAbridgement') or             matches(@rel, 'isAbridgementOf') or             matches(@rel, 'hasAdaptation') or             matches(@rel, 'isAdaptationOf') or             matches(@rel, 'hasAlternate') or             matches(@rel, 'isAlternateOf') or             matches(@rel, 'hasArrangement') or             matches(@rel, 'isArrangementOf') or             matches(@rel, 'hasComplement') or             matches(@rel, 'isComplementOf') or             matches(@rel, 'hasEmbodiment') or             matches(@rel, 'isEmbodimentOf') or             matches(@rel, 'hasExemplar') or             matches(@rel, 'isExemplarOf') or             matches(@rel, 'hasImitation') or             matches(@rel, 'isImitationOf') or             matches(@rel, 'hasPart') or             matches(@rel, 'isPartOf') or             matches(@rel, 'hasRealization') or             matches(@rel, 'isRealizationOf') or             matches(@rel, 'hasReconfiguration') or             matches(@rel, 'isReconfigurationOf') or             matches(@rel, 'hasReproduction') or             matches(@rel, 'isReproductionOf') or             matches(@rel, 'hasRevision') or             matches(@rel, 'isRevisionOf') or             matches(@rel, 'hasSuccessor') or             matches(@rel, 'isSuccessorOf') or             matches(@rel, 'hasSummarization') or             matches(@rel, 'isSummarizationOf') or             matches(@rel, 'hasSupplement') or             matches(@rel, 'isSupplementOf') or             matches(@rel, 'hasTransformation') or             matches(@rel, 'isTransformationOf') or             matches(@rel, 'hasTranslation') or             matches(@rel, 'isTranslationOf')"
             "Within work, expression, source, or item, the value of the rel attribute must match one\x{a}" ~
             "            of the following: hasAbridgement, isAbridgementOf, hasAdaptation, isAdaptationOf,\x{a}" ~
             "            hasAlternate, isAlternateOf, hasArrangement, isArrangementOf, hasComplement,\x{a}" ~
             "            isComplementOf, hasEmbodiment, isEmbodimentOf, hasExemplar, isExemplarOf, hasImitation,\x{a}" ~
             "            isImitationOf, hasPart, isPartOf, hasRealization, isRealizationOf, hasReconfiguration,\x{a}" ~
             "            isReconfigurationOf, hasReproduction, isReproductionOf, hasRevision, isRevisionOf,\x{a}" ~
             "            hasSuccessor, isSuccessorOf, hasSummarization, isSummarizationOf, hasSupplement,\x{a}" ~
             "            isSupplementOf, hasTransformation, isTransformationOf, hasTranslation,\x{a}" ~
             "            isTranslationOf"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@target"
             "Within work, expression, source or item, the target attribute\x{a}" ~
             "            must be present."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.evidence.attributes,
    mei_att.plist.attributes,
    mei_att.pointing.attributes,
    mei_att.targetEval.attributes,
    
    ## Describes the relationship between the entities identified by the plist and target attributes.
    attribute rel { mei_data.RELATIONSHIP },
    empty
  }
mei_relationList =
  
  ## Gathers relation elements.
  element relationList {
    mei_model.headLike*,
    mei_model.relationLike*,
    mei_att.common.attributes,
    empty
  }
mei_rend =
  
  ## (render)  A formatting element indicating special visual rendering, e.g., bold or italicized, of a text word or phrase.
  element rend {
    (text
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.color.attributes,
    mei_att.common.attributes,
    mei_att.horizontalAlign.attributes,
    mei_att.lang.attributes,
    mei_att.textRendition.attributes,
    mei_att.typography.attributes,
    mei_att.verticalAlign.attributes,
    mei_att.whitespace.attributes,
    
    ## A positive value for rotation rotates the text in a counter-clockwise fashion, while negative values produce clockwise rotation.
    attribute rotation { mei_data.DEGREES }?,
    empty
  }
mei_repository =
  
  ## Institution, agency, or individual which holds a bibliographic item.
  element repository {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.name.attributes,
    empty
  }
mei_resp =
  
  ## (responsibility)  A phrase describing the nature of intellectual responsibility.
  element resp {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.authorized.attributes,
    mei_att.bibl.attributes,
    mei_att.datable.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_respStmt =
  
  ## (responsibility statement)  Transcription of text that names one or more individuals, groups, or in rare cases, mechanical processes, responsible for creation, realization, production, funding, or distribution of the intellectual or artistic content.
  element respStmt {
    mei_model.headLike*,
    ((mei_name | mei_resp | mei_model.nameLike.agent)*)
    >> sch:pattern [
         id = "mei-respStmt-check_respStmt-constraint-rule-153"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:respStmt[not(ancestor::mei:change)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "(mei:resp and (mei:name or mei:corpName or mei:persName)) or              count(mei:*[@role]) = count(mei:*) and count(mei:*) > 0"
             role = "warning"
             "At least one element pair (a resp element and a name-like element) is\x{a}" ~
             "            recommended. Alternatively, each name-like element may have a @role\x{a}" ~
             "            attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_rest =
  
  ## A non-sounding event found in the source being transcribed.
  element rest {
    ((mei_dot
      | mei_model.appLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-rest-Check_restline-constraint-rule-154"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:rest[@line]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staff/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "number(@line) <= number(preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines)"
             "The value of @line must be less than or equal to the number of lines on the\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.rest.log.attributes,
    mei_att.rest.vis.attributes,
    mei_att.rest.ges.attributes,
    mei_att.rest.anl.attributes,
    empty
  }
mei_role =
  
  ## Name of a dramatic role, as given in a cast list.
  element role {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_roleDesc =
  
  ## (role description)  Describes a character's role in a drama.
  element roleDesc {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_sb =
  
  ## (system beginning)  An empty formatting element that forces musical notation to begin on a new line.
  element sb {
    mei_custos?,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.source.attributes,
    mei_att.sb.anl.attributes,
    mei_att.sb.ges.attributes,
    mei_att.sb.log.attributes,
    mei_att.sb.vis.attributes,
    empty
  }
mei_score =
  
  ## Full score view of the musical content.
  element score {
    (mei_model.annotLike
     | mei_model.appLike
     | mei_model.divLike
     | mei_model.editLike
     | mei_model.graphicPrimitiveLike
     | mei_model.milestoneLike.music
     | mei_model.relationLike
     | mei_model.scoreDefLike
     | mei_model.scorePart
     | mei_model.staffDefLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.score.log.attributes,
    mei_att.score.vis.attributes,
    mei_att.score.ges.attributes,
    mei_att.score.anl.attributes,
    empty
  }
mei_scoreDef =
  
  ## (score definition)  Container for score meta-information.
  element scoreDef {
    mei_model.chordTableLike?,
    mei_model.symbolTableLike?,
    mei_model.keySigLike?,
    mei_model.meterSigLike?,
    mei_pgHead?,
    mei_pgHead2?,
    mei_pgFoot?,
    mei_pgFoot2?,
    mei_instrGrp?,
    mei_model.staffGrpLike?,
    mei_grpSym*,
    mei_ambitus?,
    mei_att.common.attributes,
    mei_att.scoreDef.log.attributes,
    mei_att.scoreDef.vis.attributes,
    mei_att.scoreDef.ges.attributes,
    mei_att.scoreDef.anl.attributes,
    empty
  }
mei_section =
  
  ## Segment of music data.
  element section {
    mei_expansion*,
    ((mei_model.annotLike
      | mei_model.appLike
      | mei_model.divLike
      | mei_model.editLike
      | mei_model.graphicPrimitiveLike
      | mei_model.milestoneLike.music
      | mei_model.relationLike
      | mei_model.sectionPart
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-section-Check_sectionexpansion-constraint-rule-155"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:section[mei:expansion]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "descendant::mei:section|descendant::mei:ending|descendant::mei:rdg"
             "A\x{a}" ~
             "            section containing an expansion element must have descendant section, ending, or rdg\x{a}" ~
             "            elements."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.pointing.attributes,
    mei_att.section.anl.attributes,
    mei_att.section.ges.attributes,
    mei_att.section.log.attributes,
    mei_att.section.vis.attributes,
    mei_att.targetEval.attributes,
    empty
  }
mei_series =
  
  ## Contains information about the serial publication in which a bibliographic item has appeared.
  element series {
    (text
     | mei_model.identifierLike
     | mei_model.locrefLike
     | mei_model.milestoneLike.text
     | mei_model.titleLike
     | mei_editor
     | mei_extent
     | mei_respStmt
     | mei_textLang)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_space =
  
  ## A placeholder used to fill an incomplete measure, layer, etc. most often so that the combined duration of the events equals the number of beats in the measure.
  element space {
    empty,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.space.log.attributes,
    mei_att.space.vis.attributes,
    mei_att.space.ges.attributes,
    mei_att.space.anl.attributes,
    empty
  }
mei_speaker =
  
  ## Contains a specialized form of heading or label, giving the name of one or more speakers in a dramatic text or fragment.
  element speaker {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_sponsor =
  
  ## Names of sponsoring individuals, organizations or institutions. Sponsors give their intellectual authority to a project; they are to be distinguished from funders, who provide the funding but do not necessarily take intellectual responsibility.
  element sponsor {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.evidence.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_stack =
  
  ## (stacked text)  An inline table with a single column.
  element stack {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Indicates the delimiter used to mark the portions of text that are to be stacked.
    attribute delim { xsd:string }?,
    
    ## Specifies how the stacked text components should be aligned.
    attribute align {
      
      ## Left justified.
      "left"
      | 
        ## Right justified.
        "right"
      | 
        ## Centered.
        "center"
      | 
        ## Aligned on right-most digit.
        "rightdigit"
    }?,
    empty
  }
mei_staff =
  
  ## A group of equidistant horizontal lines on which notes are placed in order to represent pitch or a grouping element for individual 'strands' of notes, rests, etc. that may or may not actually be rendered on staff lines; that is, both diastematic and non-diastematic signs.
  element staff {
    ((mei_model.annotLike
      | mei_model.appLike
      | mei_model.editLike
      | mei_model.graphicPrimitiveLike
      | mei_model.milestoneLike.music
      | mei_model.relationLike
      | mei_model.staffDefLike
      | mei_model.staffPart
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id = "mei-staff-checkStaff_n-constraint-rule-156"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staff[@n]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "preceding::mei:staffDef[@n=$thisstaff] or preceding::mei:staff[@n=$thisstaff]/mei:staffDef or mei:staffDef"
             "There must be a preceding staffDef with a matching value of @n, a preceding staff with\x{a}" ~
             "            a matching @n value containing a staffDef, or a staffDef child element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.basic.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    mei_att.typed.attributes,
    mei_att.staff.log.attributes,
    mei_att.staff.vis.attributes,
    mei_att.staff.ges.attributes,
    mei_att.staff.anl.attributes,
    empty
  }
mei_staffDef =
  
  ## (staff definition)  Container for staff meta-information.
  element staffDef {
    mei_model.labelLike*,
    (mei_model.instrDefLike
     | mei_model.layerDefLike
     | mei_model.staffDefPart)*,
    (mei_ambitus?)
    >> sch:pattern [
         id = "mei-staffDef-Check_staffDefn-constraint-rule-157"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[not(ancestor::mei:staff)]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@n"
             "StaffDef must have an n attribute."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"
             " Either\x{a}" ~
             "            @lines must be present or a preceding staffDef with the same value for @n and @lines\x{a}" ~
             "            must exist."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:clef) + count(mei:clefGrp) < 2"
             "Only one clef or clefGrp is\x{a}" ~
             "            permitted."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-staffDef-Check_ancestor_staff-constraint-rule-158"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[ancestor::mei:staff and @n]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:staff/@n eq $thisstaff"
             "@n must have the same value as the\x{a}" ~
             "            current staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-staffDef-Check_ancestor_staff_lines-constraint-rule-159"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[ancestor::mei:staff and not(@n)]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staff/@n"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@lines or preceding::mei:staffDef[@n=$thisstaff and @lines]"
             " Either\x{a}" ~
             "            @lines must be present or a preceding staffDef with matching @n value and @lines must\x{a}" ~
             "            exist."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-staffDef-Check_clef_position_staffDef-constraint-rule-160"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@clef.line and @lines]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "number(@clef.line) <= number(@lines)"
             "The clef position must be less\x{a}" ~
             "            than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-staffDef-Check_clef_position_staffDef_nolines-constraint-rule-161"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@clef.line and not(@lines)]"
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "stafflines"
             value =
               "preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "number(@clef.line) <= number($stafflines)"
             "The clef position must be\x{a}" ~
             "            less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "mei-staffDef-Check_tab_strings_lines-constraint-rule-162"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@tab.strings and @lines]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "$countTokens = @lines"
             "The tab.strings attribute must have the same\x{a}" ~
             "            number of values as there are staff lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-staffDef-Check_tab_strings_nolines-constraint-rule-163"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@tab.strings and not(@lines)]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "$countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"
             "The\x{a}" ~
             "            tab.strings attribute must have the same number of values as there are staff\x{a}" ~
             "            lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@lines.color and @lines]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "$countTokens = 1 or $countTokens = @lines"
             "The lines.color attribute\x{a}" ~
             "              must have either 1) a single value or 2) the same number of values as there are staff\x{a}" ~
             "              lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@lines.color and not(@lines)]"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color), '\s'))"
           ]
           "\x{a}" ~
           "               "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisstaff and @lines][1]/@lines"
             "The lines.color attribute must have either 1) a single value or 2) the same number of\x{a}" ~
             "              values as there are staff lines."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@ppq][ancestor::mei:scoreDef[@ppq]]"
           "\x{a}" ~
           "               "
           sch:let [ name = "staffPPQ" value = "@ppq" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "scorePPQ"
             value = "ancestor::mei:scoreDef[@ppq][1]/@ppq"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "($scorePPQ mod $staffPPQ) = 0"
             "The value of ppq must be a factor of\x{a}" ~
             "              the value of ppq on an ancestor scoreDef."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffDef[@ppq][preceding::mei:scoreDef[@ppq]]"
           "\x{a}" ~
           "               "
           sch:let [ name = "staffPPQ" value = "@ppq" ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "scorePPQ"
             value = "preceding::mei:scoreDef[@ppq][1]/@ppq"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "($scorePPQ mod $staffPPQ) = 0"
             "The value of ppq must be a factor of\x{a}" ~
             "              the value of ppq on a preceding scoreDef."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "        "
       ],
    mei_att.basic.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    mei_att.typed.attributes,
    mei_att.staffDef.log.attributes,
    mei_att.staffDef.vis.attributes,
    mei_att.staffDef.ges.attributes,
    mei_att.staffDef.anl.attributes,
    empty
  }
mei_staffGrp =
  
  ## (staff group)  A group of bracketed or braced staves.
  element staffGrp {
    mei_grpSym*,
    mei_model.labelLike*,
    mei_model.instrDefLike*,
    (mei_model.staffGrpLike | mei_model.staffDefLike)+,
    (mei_grpSym*)
    >> sch:pattern [
         id =
           "mei-staffGrp-Check_staffGrp_unique_staff_n_values-constraint-rule-168"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:staffGrp"
           "\x{a}" ~
           "               "
           sch:let [
             name = "countstaves"
             value = "count(descendant::mei:staffDef)"
           ]
           "\x{a}" ~
           "               "
           sch:let [
             name = "countuniqstaves"
             value =
               "count(distinct-values(descendant::mei:staffDef/@n))"
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "$countstaves eq $countuniqstaves"
             "Each staffDef must have a unique value\x{a}" ~
             "            for the n attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.metadataPointing.attributes,
    mei_att.staffGrp.log.attributes,
    mei_att.staffGrp.vis.attributes,
    mei_att.staffGrp.ges.attributes,
    mei_att.staffGrp.anl.attributes,
    empty
  }
mei_syl =
  
  ## (syllable)  Individual lyric syllable.
  element syl {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.syl.log.attributes,
    mei_att.syl.vis.attributes,
    mei_att.syl.ges.attributes,
    mei_att.syl.anl.attributes,
    empty
  }
mei_symbol =
  
  ## A reference to a previously defined symbol.
  element symbol {
    empty
    >> sch:pattern [
         id =
           "mei-symbol-symbolDef_symbol_attributes_required-constraint-rule-169"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:symbol[ancestor::mei:symbolDef]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or (@x and @y)"
             "In the symbolDef context, symbol must have\x{a}" ~
             "            either a startid attribute or x and y attributes."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@altsym or @glyph.name or @glyph.num"
             "In the symbolDef context, symbol\x{a}" ~
             "            must have one of the following attributes: altsym, glyph.name, or\x{a}" ~
             "            glyph.num."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.symbol.anl.attributes,
    mei_att.symbol.ges.attributes,
    mei_att.symbol.log.attributes,
    mei_att.symbol.vis.attributes,
    empty
  }
mei_tempo =
  
  ## Text and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo", "cantabile", "Moderato", "=60", "Moderato  =60").
  element tempo {
    ((text
      | mei_model.textPhraseLike.limited
      | mei_model.graphicPrimitiveLike
      | mei_model.editLike
      | mei_model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "mei-tempo-tempo_in_header_disallow_most_attrs-constraint-rule-170"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:tempo[not(ancestor::mei:score or ancestor::mei:part)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "not(@*[name() != 'analog' and name() != 'class' and name() != 'label' and                name() != 'mm' and name() != 'mm.dots' and name() != 'translit' and                name() != 'type' and name() != 'mm.unit' and name() != 'n' and name() != 'xml:base' and                name() != 'xml:id' and name() != 'xml:lang'])"
             "Only analog, class, label, mm, mm.dots, mm.unit, n, translit, type, xml:base, xml:id,\x{a}" ~
             "            and xml:lang attributes are allowed when tempo is not a descendant of a score or\x{a}" ~
             "            part."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-tempo-tempo_start-type_attributes_required-constraint-rule-171"
         "\x{a}" ~
         "            "
         sch:rule [
           context =
             "mei:tempo[not(ancestor::mei:syllable) and not(ancestor::mei:work) and not(ancestor::mei:expression) and not(count(ancestor::mei:*) = 0)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or @tstamp or @tstamp.ges or @tstamp.real"
             "Must have one of the\x{a}" ~
             "            attributes: startid, tstamp, tstamp.ges or tstamp.real."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.tempo.log.attributes,
    mei_att.tempo.vis.attributes,
    mei_att.tempo.ges.attributes,
    mei_att.tempo.anl.attributes,
    empty
  }
mei_term =
  
  ## Keyword or phrase which describes a resource.
  element term {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id = "mei-term-Check_term_dataTarget-constraint-rule-172"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:term[@data]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "ancestor::mei:classification"
             "The @data attribute may only occur on a\x{a}" ~
             "            term which is a descendant of a classification element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.dataPointing.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_textLang =
  
  ## (text language)  Identifies the languages and writing systems within the work described by a bibliographic description, not the language of the description.
  element textLang {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## (main language) supplies a code which identifies the chief language used in the bibliographic work.
    attribute lang.main { xsd:language }?,
    
    ## (other languages) one or more codes identifying any other languages used in the bibliographic work.
    attribute lang.other {
      list { xsd:language+ }
    }?,
    empty
  }
mei_title =
  
  ## Title of a bibliographic entity.
  element title {
    (text
     | mei_macro.titlePart
     | mei_model.editLike
     | mei_model.transcriptionLike
     | mei_titlePart)*,
    mei_att.authorized.attributes,
    mei_att.basic.attributes,
    mei_att.bibl.attributes,
    mei_att.classed.attributes,
    mei_att.facsimile.attributes,
    mei_att.filing.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.linking.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    
    ## Indicates the bibliographic level of the title.
    attribute level {
      
      ## Analyzed component, such as an article or chapter, within a larger bibliographic entity.
      "a"
      | 
        ## Collection. A group of items that were not originally published, distributed, or produced together.
        "c"
      | 
        ## Subunit of a collection, e.g. item, folder, box, archival series, subgroup, or subcollection.
        "d"
      | 
        ## Integrating resource, such as a continuously updated loose-leaf service or Web site.
        "i"
      | 
        ## Monograph.
        "m"
      | 
        ## Journal.
        "j"
      | 
        ## Series.
        "s"
      | 
        ## Unpublished (including theses and dissertations unless published by a commercial press).
        "u"
    }?,
    
    ## Characterizes the title in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] main; 2] subordinate; 3] abbreviated; 4] alternative; 5] translated; 6] uniform; 7] desc
    attribute type {
      
      ## Main title.
      "main"
      | 
        ## Subtitle or title of part.
        "subordinate"
      | 
        ## Abbreviated form of title.
        "abbreviated"
      | 
        ## Alternate title by which the item is also known.
        "alternative"
      | 
        ## Translated form of title.
        "translated"
      | 
        ## Collective title.
        "uniform"
      | 
        ## Descriptive paraphrase of the work.
        "desc"
      | xsd:NMTOKENS
    }?,
    empty
  }
mei_titlePage =
  
  ## Contains a transcription of the title page of a text.
  element titlePage {
    mei_model.headLike*,
    (mei_model.figureLike
     | mei_model.imprintPart
     | mei_model.milestoneLike.text
     | mei_model.textComponentLike
     | mei_model.titlePagePart
     | mei_model.transcriptionLike)+,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_titlePart =
  
  ## Contains a subsection or division of the title of a bibliographic entity.
  element titlePart {
    (text
     | mei_macro.titlePart
     | mei_model.editLike
     | mei_model.titleLike
     | mei_model.transcriptionLike)*,
    mei_att.authorized.attributes,
    mei_att.basic.attributes,
    mei_att.bibl.attributes,
    mei_att.classed.attributes,
    mei_att.facsimile.attributes,
    mei_att.filing.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.linking.attributes,
    mei_att.nInteger.attributes,
    mei_att.responsibility.attributes,
    
    ## Characterizes this title component in some sense, using any convenient classification scheme or typology that employs single-token labels.
    ## Suggested values include: 1] alternative; 2] arrangement; 3] carrier; 4] date; 5] desc; 6] form; 7] key; 8] language; 9] main; 10] name; 11] number; 12] perfmedium; 13] subordinate; 14] translated; 15] version
    attribute type {
      
      ## Alternate title by which the item is also known.
      "alternative"
      | 
        ## Arranged statement for music. Analogous to MARC 240 subfield o.
        "arrangement"
      | 
        ## Medium of the carrier. Analogous to MARC 240 subfield h.
        "carrier"
      | 
        ## Publication/creation date(s) of work. Analogous to MARC 240 subfield f.
        "date"
      | 
        ## Descriptive paraphrase of the work.
        "desc"
      | 
        ## Form subheading. Analogous to MARC 240 subfield k.
        "form"
      | 
        ## Key for music. Analogous to MARC 240 subfield r.
        "key"
      | 
        ## Language of a work. Analogous to MARC 240 subfield l (el).
        "language"
      | 
        ## Main title.
        "main"
      | 
        ## Name of a part or section of a work. Analogous to MARC 240 subfield p.
        "name"
      | 
        ## Standard number designation of a work or of a part or section of a work. Analogous to MARC 240 subfield n.
        "number"
      | 
        ## Performance medium. Analogous to MARC 240 subfield m.
        "perfmedium"
      | 
        ## Subtitle.
        "subordinate"
      | 
        ## Translated form of title.
        "translated"
      | 
        ## Version. Analogous to MARC 240 subfield s.
        "version"
      | xsd:NMTOKENS
    }?,
    empty
  }
mei_width =
  
  ## Description of the horizontal size of an object.
  element width {
    (text | mei_model.textPhraseLike.limited)*,
    mei_att.common.attributes,
    mei_att.bibl.attributes,
    mei_att.lang.attributes,
    mei_att.quantity.attributes,
    empty
  }
mei_att.stringtab.attributes =
  mei_att.stringtab.attribute.tab.fing,
  mei_att.stringtab.attribute.tab.fret,
  mei_att.stringtab.attribute.tab.string
mei_att.stringtab.attribute.tab.fing =
  
  ## Indicates which finger, if any, should be used to play an individual string. The index, middle, ring, and little fingers are represented by the values 1-4, while 't' is for the thumb. The values 'x' and 'o' indicate muffled and open strings, respectively.
  attribute tab.fing { mei_data.FINGER.FRET }?
mei_att.stringtab.attribute.tab.fret =
  
  ## Records the location at which a string should be stopped against a fret.
  attribute tab.fret { mei_data.FRETNUMBER }?
mei_att.stringtab.attribute.tab.string =
  
  ## Records which string is to be played.
  attribute tab.string { mei_data.STRINGNUMBER }?
mei_att.stringtab.position.attributes =
  mei_att.stringtab.position.attribute.tab.pos
mei_att.stringtab.position.attribute.tab.pos =
  
  ## Records fret position.
  attribute tab.pos { xsd:positiveInteger }?
mei_att.stringtab.tuning.attributes =
  mei_att.stringtab.tuning.attribute.tab.strings
mei_att.stringtab.tuning.attribute.tab.strings =
  
  ## Provides a *written* pitch and octave for each open string or course of strings.
  attribute tab.strings {
    list {
      xsd:token {
        pattern =
          "[a-g][0-9](s|f|ss|x|ff|xs|sx|ts|tf|n|nf|ns|su|sd|fu|fd|nu|nd|1qf|3qf|1qs|3qs)?([a-g][0-9](s|f|ss|x|ff|xs|sx|ts|tf|n|nf|ns|su|sd|fu|fd|nu|nd|1qf|3qf|1qs|3qs)?)*"
      }+
    }
  }?
mei_barre =
  
  ## A barre in a chord tablature grid.
  element barre {
    empty,
    mei_att.common.attributes,
    mei_att.startEndId.attributes,
    
    ## Records the location at which the strings should be stopped against a fret in a fretboard diagram. This may or may not be the same as the actual location on the fretboard of the instrument in performance.
    attribute fret {
      xsd:positiveInteger { minInclusive = "1" maxInclusive = "5" }
    }?,
    empty
  }
mei_model.backLike = mei_back
mei_model.divLike = mei_div
mei_model.frontLike = mei_front
mei_model.lgLike = mei_lg
mei_model.lgLike_alternation = mei_lg
mei_model.lgLike_sequence = mei_lg
mei_model.lgLike_sequenceOptional = mei_lg?
mei_model.lgLike_sequenceOptionalRepeatable = mei_lg*
mei_model.lgLike_sequenceRepeatable = mei_lg+
mei_model.listLike =
  mei_biblList | mei_castList | mei_eventList | mei_list
mei_model.listLike_alternation =
  mei_biblList | mei_castList | mei_eventList | mei_list
mei_model.listLike_sequence =
  mei_biblList, mei_castList, mei_eventList, mei_list
mei_model.listLike_sequenceOptional =
  mei_biblList?, mei_castList?, mei_eventList?, mei_list?
mei_model.listLike_sequenceOptionalRepeatable =
  mei_biblList*, mei_castList*, mei_eventList*, mei_list*
mei_model.listLike_sequenceRepeatable =
  mei_biblList+, mei_castList+, mei_eventList+, mei_list+
mei_model.lLike = mei_l
mei_model.qLike = mei_q
mei_model.qLike_alternation = mei_q
mei_model.qLike_sequence = mei_q
mei_model.qLike_sequenceOptional = mei_q?
mei_model.qLike_sequenceOptionalRepeatable = mei_q*
mei_model.qLike_sequenceRepeatable = mei_q+
mei_model.quoteLike = mei_quote
mei_model.quoteLike_alternation = mei_quote
mei_model.quoteLike_sequence = mei_quote
mei_model.quoteLike_sequenceOptional = mei_quote?
mei_model.quoteLike_sequenceOptionalRepeatable = mei_quote*
mei_model.quoteLike_sequenceRepeatable = mei_quote+
mei_argument =
  
  ## Contains a formal list or prose description of topics addressed.
  element argument {
    (mei_model.headLike | mei_model.milestoneLike.text)*,
    ((mei_model.figureLike | mei_model.textComponentLike | mei_sp),
     mei_model.milestoneLike.text*)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_back =
  
  ## (back matter)  Contains any appendixes, advertisements, indexes, etc. following the main body of a musical text.
  element back {
    (mei_model.divLike
     | mei_model.frontAndBackPart
     | mei_model.milestoneLike.text
     | mei_model.relationLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_epigraph =
  
  ## Contains a quotation, anonymous or attributed, appearing on a title page.
  element epigraph {
    (text | mei_model.paracontentPart | mei_p)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_front =
  
  ## (front matter)  Bundles prefatory text found before the start of the musical text.
  element front {
    (mei_model.divLike
     | mei_model.frontAndBackPart
     | mei_model.milestoneLike.text
     | mei_model.relationLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_imprimatur =
  
  ## Contains a formal statement authorizing the publication of a work, sometimes required to appear on a title page or its verso.
  element imprimatur {
    (text | mei_model.paracontentPart)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.metadataPointing.attributes,
    empty
  }
mei_l =
  
  ## (line of text)  Contains a single line of text within a line group.
  element l {
    (text
     | mei_model.editLike
     | mei_model.sylLike
     | mei_model.textPhraseLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    
    ## Used to specify a rhythm for the lyric syllables that differs from that of the notes on the staff, e.g., '4,4,4,4' when the rhythm of the notes is '4.,8,4.,8'.
    attribute rhythm { xsd:string }?,
    empty
  }
mei_li =
  
  ## (list item)  Single item in a list.
  element li {
    (text
     | mei_model.textComponentLike
     | mei_model.textPhraseLike
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_list =
  
  ## A formatting element that contains a series of items separated from one another and arranged in a linear, often vertical, sequence.
  element list {
    mei_model.headLike*,
    ((mei_label?, mei_li)*)
    >> sch:pattern [
         id = "mei-list-list_type_constraint-constraint-rule-173"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:list[contains(@type,'gloss')]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "count(mei:label) = count(mei:li)"
             'In a list of type "gloss" all items\x{a}' ~
             "            must be immediately preceded by a label."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.basic.attributes,
    mei_att.classed.attributes,
    mei_att.facsimile.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.linking.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    mei_att.xy.attributes,
    
    ## Used to indicate the format of a list. In a "simple" list, li elements are not numbered or bulleted. In a "marked" list, the sequence of the list items is not critical, and a bullet, box, dash, or other character is displayed at the start of each item. In an "ordered" list, the sequence of the items is important, and each li is lettered or numbered. Style sheet functions should be used to specify the mark or numeration system for each li.
    attribute form {
      
      ## Items are not numbered or bulleted.
      "simple"
      | 
        ## Bullet, box, dash, or other character is displayed before each item.
        "marked"
      | 
        ## Each item is numbered or lettered.
        "ordered"
    }?,
    
    ## Captures the nature of the content of a list.
    ## Suggested values include: 1] gloss; 2] index; 3] instructions; 4] litany; 5] syllogism
    attribute type {
      
      ## Each list item glosses some term or concept, which is given by a label element preceding the list item.
      "gloss"
      | 
        ## Each list item is an entry in an index such as the alphabetical topical index at the back of a print volume.
        "index"
      | 
        ## Each list item is a step in a sequence of instructions, as in a recipe.
        "instructions"
      | 
        ## Each list item is one of a sequence of petitions, supplications or invocations, typically in a religious ritual.
        "litany"
      | 
        ## Each list item is part of an argument consisting of two or more propositions and a final conclusion derived from them.
        "syllogism"
      | xsd:NMTOKENS
    }?,
    empty
  }
mei_q =
  
  ## (quoted)  Contains material which is distinguished from the surrounding phrase-level text using quotation marks or a similar method. Use quote for block-level quotations.
  element q {
    (text | mei_model.textPhraseLike)*,
    mei_att.basic.attributes,
    mei_att.classed.attributes,
    mei_att.labelled.attributes,
    mei_att.lang.attributes,
    mei_att.linking.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    
    ## 
    ## Suggested values include: 1] spoken; 2] thought; 3] written; 4] soCalled; 5] foreign; 6] distinct; 7] term; 8] emph; 9] mentioned
    attribute type {
      list {
        (
         ## Representation of speech.
         "spoken"
         | 
           ## Representation of thought, e.g. internal monologue.
           "thought"
         | 
           ## Quotation from a written source.
           "written"
         | 
           ## Authorial distance.
           "soCalled"
         | 
           ## Linguistically distinct.
           "foreign"
         | 
           ## Linguistically distinct.
           "distinct"
         | 
           ## Technical term.
           "term"
         | 
           ## Rhetorically emphasized.
           "emph"
         | 
           ## Refering to itself, not its normal referent.
           "mentioned"
         | xsd:NMTOKEN)+
      }
    }?,
    empty
  }
mei_quote =
  
  ## (quoted material)  Contains a paragraph-like block of text attributed to an external source, normally set off from the surrounding text by spacing or other typographic distinction.
  element quote {
    (text | mei_model.paracontentPart | mei_model.pLike | mei_sp)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.xy.attributes,
    empty
  }
mei_seg =
  
  ## (arbitrary segment) represents any segmentation of text below the "text component" level.
  element seg {
    (text
     | mei_model.editLike
     | mei_model.sylLike
     | mei_model.textPhraseLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    empty
  }
mei_att.altSym.attributes = mei_att.altSym.attribute.altsym
mei_att.altSym.attribute.altsym =
  
  ## Provides a way of pointing to a user-defined symbol. It must contain a reference to an ID of a symbolDef element elsewhere in the document.
  attribute altsym { mei_data.URI }?
sch:pattern [
  id = "mei-att.altSym-altsym-check_altsymTarget-constraint-rule-174"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "@altsym"
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test = "not(normalize-space(.) eq '')"
      "@altsym attribute\x{a}" ~
      "                should have content."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      role = "warning"
      test =
        "every $i in tokenize(., '\s+') satisfies substring($i,2)=//mei:symbolDef/@xml:id"
      "The value in @altsym should correspond to the @xml:id attribute of a symbolDef\x{a}" ~
      "                element."
    ]
    "\x{a}" ~
    "              "
    sch:assert [
      test = "not(substring(., 2) eq ancestor::mei:symbolDef/@xml:id)"
      "The value\x{a}" ~
      "                in @altsym must not correspond to the @xml:id attribute of a symbolDef\x{a}" ~
      "                ancestor."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.anchoredText.log.attributes =
  mei_att.startId.attributes, mei_att.anchoredText.log.attribute.func
mei_att.anchoredText.log.attribute.func =
  
  ## Indicates the function of the text.
  ## Suggested values include: 1] unknown
  attribute func {
    
    ## The function of the text is unknown.
    "unknown"
    | xsd:NMTOKEN
  }?
mei_att.curve.log.attributes =
  mei_att.startEndId.attributes, mei_att.curve.log.attribute.func
mei_att.curve.log.attribute.func =
  
  ## Indicates the function of the curve.
  ## Suggested values include: 1] unknown
  attribute func {
    
    ## The function of the curve is unknown.
    "unknown"
    | xsd:NMTOKEN
  }?
mei_att.line.log.attributes =
  mei_att.controlEvent.attributes,
  mei_att.duration.additive.attributes,
  mei_att.startEndId.attributes,
  mei_att.timestamp2.logical.attributes,
  mei_att.line.log.attribute.func
mei_att.line.log.attribute.func =
  
  ## Indicates the function of the line.
  ## Suggested values include: 1] coloration; 2] ligature; 3] unknown
  attribute func {
    
    ## Indicates coloration in material transcribed from a source originally in mensural notation.
    "coloration"
    | 
      ## Marks a ligature in material transcribed from a source originally in mensural notation.
      "ligature"
    | 
      ## The function of the line is unknown.
      "unknown"
    | xsd:NMTOKEN
  }?
mei_model.graphicPrimitiveLike = mei_anchoredText | mei_curve | mei_line
mei_model.symbolTableLike = mei_symbolTable
mei_anchoredText =
  
  ## Container for text that is fixed to a particular page location, regardless of changes made to the layout of the measures around it.
  element anchoredText {
    (text
     | mei_model.textPhraseLike.limited
     | mei_model.editLike
     | mei_model.transcriptionLike)*,
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.lang.attributes,
    mei_att.anchoredText.anl.attributes,
    mei_att.anchoredText.ges.attributes,
    mei_att.anchoredText.log.attributes,
    mei_att.anchoredText.vis.attributes,
    empty
  }
mei_curve =
  
  ## A curved line that cannot be represented by a more specific element, such as a slur.
  element curve {
    empty
    >> sch:pattern [
         id =
           "mei-curve-symbolDef_curve_attributes_required-constraint-rule-175"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:curve[ancestor::mei:symbolDef]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or (@x and @y)"
             "In the symbolDef context, curve must have\x{a}" ~
             "            either a startid attribute or x and y attributes."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@endid or (@x2 and @y2)"
             "In the symbolDef context, curve must have\x{a}" ~
             "            either an endid attribute or both x2 and y2 attributes."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@bezier or @bulge"
             "In the symbolDef context, curve must have either a\x{a}" ~
             "            bezier or bulge attribute."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.curve.anl.attributes,
    mei_att.curve.ges.attributes,
    mei_att.curve.log.attributes,
    mei_att.curve.vis.attributes,
    mei_att.facsimile.attributes,
    empty
  }
mei_line =
  
  ## A visual line that cannot be represented by a more specific; i.e., semantic, element.
  element line {
    ((text | mei_model.textPhraseLike.limited)*)
    >> sch:pattern [
         id =
           "mei-line-line_start-_and_end-type_attributes_required-constraint-rule-176"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:line[ancestor::mei:symbolDef]"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@startid or (@x and @y)"
             "When used in the symbolDef context, must have\x{a}" ~
             "            either a startid attribute or x and y attributes."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@endid or (@x2 and @y2)"
             "When used in the symbolDef context, must have\x{a}" ~
             "            either an endid attribute or both x2 and y2 attributes."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id =
           "mei-line-line_start-_and_end-type_attributes_required-constraint-rule-177"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "mei:line[not(ancestor::mei:symbolDef)]"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or @tstamp.real or (@x and @y)"
             "When\x{a}" ~
             "            used in the score context, must have a startid, tstamp, tstamp.ges or tstamp.real\x{a}" ~
             "            attribute or both x and y attributes."
           ]
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "@dur or @dur.ges or @endid or @tstamp2 or (@x2 and @y2)"
             "When used in\x{a}" ~
             "            the score context, must have an endid, dur, dur.ges, or tstamp2 attribute or both x2 and\x{a}" ~
             "            y2 attributes."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    mei_att.common.attributes,
    mei_att.facsimile.attributes,
    mei_att.line.anl.attributes,
    mei_att.line.ges.attributes,
    mei_att.line.log.attributes,
    mei_att.line.vis.attributes,
    empty
  }
mei_mapping =
  
  ## One or more characters which are related to the parent symbol in some respect, as specified by the type attribute.
  element mapping {
    (text | mei_symbol)*, mei_att.common.attributes, empty
  }
mei_propName =
  
  ## (property name)  Name of a property of the symbol.
  element propName {
    text,
    mei_att.basic.attributes,
    mei_att.labelled.attributes,
    mei_att.linking.attributes,
    mei_att.nNumberLike.attributes,
    mei_att.responsibility.attributes,
    
    ## Characterizes the property name.
    attribute type {
      
      ## A registered Unicode normative or informative property name.
      "unicode"
      | 
        ## A locally defined name.
        "local"
    },
    empty
  }
mei_propValue =
  
  ## (property value)  A single property value.
  element propValue { text, mei_att.common.attributes, empty }
mei_symbolDef =
  
  ## (symbol definition)  Declaration of an individual symbol in a symbolTable.
  element symbolDef {
    mei_symName?,
    mei_symProp*,
    mei_mapping*,
    (svg_svg?
     | (mei_model.graphicPrimitiveLike | mei_symbol | mei_graphic)*),
    mei_model.annotLike*,
    mei_att.common.attributes,
    mei_att.coordinated.attributes,
    empty
  }
mei_symName =
  
  ## (symbol name)  Contains the name of a symbol, expressed following Unicode conventions.
  element symName { text, mei_att.common.attributes, empty }
mei_symProp =
  
  ## (symbol property)  Provides a name and value for some property of the parent symbol.
  element symProp {
    mei_propName, mei_propValue, mei_att.common.attributes, empty
  }
mei_symbolTable =
  
  ## Contains a set of user-defined symbols.
  element symbolTable {
    mei_symbolDef+, mei_att.common.attributes, empty
  }
mei_att.accid.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.ho.attributes,
  mei_att.visualOffset.vo.attributes,
  mei_att.xy.attributes
mei_att.ambNote.vis.attributes =
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.noteHeads.attributes,
  mei_att.staffLoc.attributes,
  mei_att.stems.attributes,
  mei_att.typography.attributes
mei_att.annot.vis.attributes = mei_att.annot.vis.attribute.place
mei_att.annot.vis.attribute.place =
  
  ## Location of the annotation.
  attribute place {
    list { mei_data.PLACEMENT+ }
  }?
mei_att.arpeg.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes,
  mei_att.arpeg.vis.attribute.arrow,
  mei_att.arpeg.vis.attribute.arrow.shape,
  mei_att.arpeg.vis.attribute.arrow.size,
  mei_att.arpeg.vis.attribute.arrow.color,
  mei_att.arpeg.vis.attribute.arrow.fillcolor,
  mei_att.arpeg.vis.attribute.line.form,
  mei_att.arpeg.vis.attribute.line.width
mei_att.arpeg.vis.attribute.arrow =
  
  ## Indicates if an arrowhead is to be drawn as part of the arpeggiation symbol.
  attribute arrow { mei_data.BOOLEAN }?
mei_att.arpeg.vis.attribute.arrow.shape =
  
  ## Symbol rendered at end of the line.
  attribute arrow.shape { mei_data.LINESTARTENDSYMBOL }?
mei_att.arpeg.vis.attribute.arrow.size =
  
  ## Holds the relative size of the arrow symbol.
  attribute arrow.size { mei_data.FONTSIZESCALE }?
mei_att.arpeg.vis.attribute.arrow.color =
  
  ## Captures the overall color of the arrow.
  attribute arrow.color { mei_data.COLOR }?
mei_att.arpeg.vis.attribute.arrow.fillcolor =
  
  ## Captures the fill color of the arrow if different from the line color.
  attribute arrow.fillcolor { mei_data.COLOR }?
mei_att.arpeg.vis.attribute.line.form =
  
  ## Visual form of the line.
  attribute line.form { mei_data.LINEFORM }?
mei_att.arpeg.vis.attribute.line.width =
  
  ## Width of the line.
  attribute line.width { mei_data.LINEWIDTH }?
mei_att.artic.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.attacca.vis.attributes =
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.verticalGroup.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.barLine.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.visibility.attributes,
  mei_att.width.attributes,
  mei_att.barLine.vis.attribute.len,
  mei_att.barLine.vis.attribute.method,
  mei_att.barLine.vis.attribute.place
mei_att.barLine.vis.attribute.len =
  
  ## States the length of barlines in virtual units. The value must be greater than 0 and is typically equal to 2 times (the number of staff lines - 1); e.g., a value of '8' for a 5-line staff.
  attribute len {
    xsd:decimal { minExclusive = "0" }
  }?
mei_att.barLine.vis.attribute.method =
  
  ## Records the method of barring.
  attribute method { mei_data.BARMETHOD }?
mei_att.barLine.vis.attribute.place =
  
  ## Denotes the staff location of the bar line if its length is non-standard.
  attribute place { mei_data.STAFFLOC }?
mei_att.beam.vis.attributes =
  mei_att.color.attributes,
  mei_att.cue.attributes,
  mei_att.beamRend.attributes
mei_att.beaming.vis.attributes =
  mei_att.beaming.vis.attribute.beam.color,
  mei_att.beaming.vis.attribute.beam.rend,
  mei_att.beaming.vis.attribute.beam.slope
mei_att.beaming.vis.attribute.beam.color =
  
  ## Color of beams, including those associated with tuplets.
  attribute beam.color { mei_data.COLOR }?
mei_att.beaming.vis.attribute.beam.rend =
  
  ## Encodes whether a beam is "feathered" and in which direction.
  attribute beam.rend {
    
    ## Beam lines grow farther apart from left to right.
    "acc"
    | 
      ## Beam lines grow closer together from left to right.
      "rit"
    | 
      ## Beam lines are equally-spaced over the entire length of the beam.
      "norm"
  }?
mei_att.beaming.vis.attribute.beam.slope =
  
  ## Captures beam slope.
  attribute beam.slope { xsd:decimal }?
mei_att.beamSpan.vis.attributes = mei_att.beam.vis.attributes
mei_att.beatRpt.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.expandable.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.beatRpt.vis.attribute.slash
mei_att.beatRpt.vis.attribute.slash =
  
  ## Indicates the number of slashes required to render the appropriate beat repeat symbol. When a single beat consisting of a single note or chord is repeated, the repetition symbol is a single thick, slanting slash; therefore, the value '1' should be used. When the beat is divided into even notes, the following values should be used: 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5. When the beat is comprised of mixed duration values, the default rendition is 2 slashes and 2 dots.
  attribute slash { mei_data.BEATRPT.REND }
mei_att.bend.vis.attributes =
  mei_att.color.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.curvature.attributes,
  mei_att.curveRend.attributes
mei_att.bracketSpan.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.lineRend.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes
mei_att.breath.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.bTrem.vis.attributes = mei_att.numberPlacement.attributes
mei_att.caesura.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.chord.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.extSym.attributes,
  mei_att.stems.attributes,
  mei_att.typography.attributes,
  mei_att.visibility.attributes,
  mei_att.visualOffset.ho.attributes,
  mei_att.visualOffset.to.attributes,
  mei_att.xy.attributes,
  mei_att.chord.vis.cmn.attributes,
  mei_att.chord.vis.attribute.cluster
mei_att.chord.vis.attribute.cluster =
  
  ## Indicates a single, alternative note head should be displayed instead of individual note heads. The highest and lowest notes of the chord usually indicate the upper and lower boundaries of the cluster note head.
  attribute cluster { mei_data.CLUSTER }?
mei_att.chordDef.vis.attributes = empty
mei_att.chordMember.vis.attributes = empty
mei_att.clef.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.visibility.attributes
mei_att.cleffing.vis.attributes =
  mei_att.cleffing.vis.attribute.clef.color,
  mei_att.cleffing.vis.attribute.clef.visible
mei_att.cleffing.vis.attribute.clef.color =
  
  ## Describes the color of the clef.
  attribute clef.color { mei_data.COLOR }?
mei_att.cleffing.vis.attribute.clef.visible =
  
  ## Determines whether the clef is to be displayed.
  attribute clef.visible { mei_data.BOOLEAN }?
mei_att.clefGrp.vis.attributes = empty
mei_att.cpMark.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.curve.vis.attributes =
  mei_att.color.attributes,
  mei_att.curvature.attributes,
  mei_att.curveRend.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes
mei_att.custos.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.staffLoc.attributes,
  mei_att.typography.attributes
mei_att.mdiv.vis.attributes = empty
mei_att.dir.vis.attributes =
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.verticalGroup.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.dot.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.ho.attributes,
  mei_att.visualOffset.vo.attributes,
  mei_att.xy.attributes
mei_att.dynam.vis.attributes =
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.verticalGroup.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.ending.vis.attributes = mei_att.lineRend.attributes
mei_att.f.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.fermata.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes,
  mei_att.fermata.vis.attribute.form,
  mei_att.fermata.vis.attribute.shape
mei_att.fermata.vis.attribute.form =
  
  ## Describes the visual appearance of the fermata; that is, whether it occurs as upright or inverted.
  attribute form {
    
    ## Inverted, i.e., curve or bracket below the dot.
    "inv"
    | 
      ## Upright; i.e., curve or bracket above the dot.
      "norm"
  }?
mei_att.fermata.vis.attribute.shape =
  
  ## Describes the visual appearance of the fermata; that is, whether it has a curved, square, or angular shape.
  attribute shape {
    
    ## A curve above or below the dot.
    "curved"
    | 
      ## A bracket above or below the dot.
      "square"
    | 
      ## A triangle above or below the dot.
      "angular"
  }?
mei_att.fing.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.fingGrp.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes,
  mei_att.fingGrp.vis.attribute.orient
mei_att.fingGrp.vis.attribute.orient =
  
  ##
  attribute orient {
    
    ## Combination expressed horizontally, as for brass instruments.
    "horiz"
    | 
      ## Combination expressed vertically, as for woodwind instruments or piano.
      "vert"
  }?
mei_att.fTrem.vis.attributes =
  mei_att.fTrem.vis.attribute.beams,
  mei_att.fTrem.vis.attribute.beams.float,
  mei_att.fTrem.vis.attribute.float.gap
mei_att.fTrem.vis.attribute.beams =
  
  ## Indicates the number of beams present.
  attribute beams {
    xsd:positiveInteger { minInclusive = "1" maxInclusive = "6" }
  }?
mei_att.fTrem.vis.attribute.beams.float =
  
  ## Captures the number of "floating" beams, i.e., those not attached to stems.
  attribute beams.float { xsd:nonNegativeInteger }?
sch:pattern [
  id =
    "mei-att.fTrem.vis-beams.float-check_beams.floating-constraint-rule-178"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "mei:fTrem[@beams and @beams.float]"
    "\x{a}" ~
    "              "
    sch:assert [
      test = "@beams.float <= @beams"
      "The number of floating beams must be less\x{a}" ~
      "                than or equal to the total number of beams."
    ]
    "\x{a}" ~
    "            "
  ]
  "\x{a}" ~
  "   "
]
mei_att.fTrem.vis.attribute.float.gap =
  
  ## Records the amount of separation between floating beams and stems.
  attribute float.gap { mei_data.MEASUREMENTABS }?
mei_att.gliss.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.lineRend.attributes
mei_att.grpSym.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.hairpin.vis.attributes =
  mei_att.color.attributes,
  mei_att.lineRend.base.attributes,
  mei_att.placement.attributes,
  mei_att.verticalGroup.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.hairpin.vis.attribute.opening
mei_att.hairpin.vis.attribute.opening =
  
  ## Specifies the distance between the lines at the open end of a hairpin dynamic mark.
  attribute opening { mei_data.MEASUREMENTABS }?
mei_att.halfmRpt.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.expandable.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes
mei_att.harm.vis.attributes =
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes,
  mei_att.harm.vis.attribute.rendgrid
mei_att.harm.vis.attribute.rendgrid =
  
  ## Describes how the harmonic indication should be rendered.
  attribute rendgrid {
    
    ## Chord tablature grid.
    "grid"
    | 
      ## Chord tablature grid and the element's textual content.
      "gridtext"
    | 
      ## Textual content of the element.
      "text"
  }?
mei_att.harpPedal.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.instrDef.vis.attributes = empty
mei_att.keyAccid.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.extSym.attributes,
  mei_att.staffLoc.attributes,
  mei_att.typography.attributes,
  mei_att.xy.attributes
mei_att.keySig.vis.attributes =
  mei_att.visibility.attributes,
  mei_att.keySig.vis.attribute.sig.showchange
mei_att.keySig.vis.attribute.sig.showchange =
  
  ## Determines whether cautionary accidentals should be displayed at a key change.
  attribute sig.showchange { mei_data.BOOLEAN }?
mei_att.keySigDefault.vis.attributes =
  mei_att.keySigDefault.vis.attribute.keysig.show,
  mei_att.keySigDefault.vis.attribute.keysig.showchange
mei_att.keySigDefault.vis.attribute.keysig.show =
  
  ## Indicates whether the key signature should be displayed.
  attribute keysig.show { mei_data.BOOLEAN }?
mei_att.keySigDefault.vis.attribute.keysig.showchange =
  
  ## Determines whether cautionary accidentals should be displayed at a key change.
  attribute keysig.showchange { mei_data.BOOLEAN }?
mei_att.layer.vis.attributes = mei_att.visibility.attributes
mei_att.layerDef.vis.attributes =
  mei_att.beaming.vis.attributes,
  mei_att.textStyle.attributes,
  mei_att.visibility.attributes
mei_att.line.vis.attributes =
  mei_att.color.attributes,
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.line.vis.attribute.form,
  mei_att.line.vis.attribute.width,
  mei_att.line.vis.attribute.endsym,
  mei_att.line.vis.attribute.endsym.size,
  mei_att.line.vis.attribute.startsym,
  mei_att.line.vis.attribute.startsym.size
mei_att.line.vis.attribute.form =
  
  ## Visual form of the line.
  attribute form { mei_data.LINEFORM }?
mei_att.line.vis.attribute.width =
  
  ## Width of the line.
  attribute width { mei_data.LINEWIDTH }?
mei_att.line.vis.attribute.endsym =
  
  ## Symbol rendered at end of line.
  attribute endsym { mei_data.LINESTARTENDSYMBOL }?
mei_att.line.vis.attribute.endsym.size =
  
  ## Holds the relative size of the line-end symbol.
  attribute endsym.size { mei_data.FONTSIZESCALE }?
mei_att.line.vis.attribute.startsym =
  
  ## Symbol rendered at start of line.
  attribute startsym { mei_data.LINESTARTENDSYMBOL }?
mei_att.line.vis.attribute.startsym.size =
  
  ## Holds the relative size of the line-start symbol.
  attribute startsym.size { mei_data.FONTSIZESCALE }?
mei_att.lv.vis.attributes =
  mei_att.color.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.curvature.attributes,
  mei_att.curveRend.attributes
mei_att.lyrics.vis.attributes =
  mei_att.placement.attributes, mei_att.typography.attributes
mei_att.measure.vis.attributes =
  mei_att.barring.attributes, mei_att.width.attributes
mei_att.meterSig.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.meterSig.vis.attribute.form
mei_att.meterSig.vis.attribute.form =
  
  ## Contains an indication of how the meter signature should be rendered.
  attribute form {
    
    ## Show only the number of beats.
    "num"
    | 
      ## The lower number in the meter signature is replaced by a note symbol.
      "denomsym"
    | 
      ## Meter signature rendered using traditional numeric values.
      "norm"
    | 
      ## Meter signature not rendered.
      "invis"
  }?
mei_att.meterSigDefault.vis.attributes =
  mei_att.meterSigDefault.vis.attribute.meter.form,
  mei_att.meterSigDefault.vis.attribute.meter.showchange
mei_att.meterSigDefault.vis.attribute.meter.form =
  
  ## Contains an indication of how the meter signature should be rendered.
  attribute meter.form {
    
    ## Show only the number of beats.
    "num"
    | 
      ## The lower number in the meter signature is replaced by a note symbol.
      "denomsym"
    | 
      ## Meter signature rendered using traditional numeric values.
      "norm"
    | 
      ## Meter signature not rendered.
      "invis"
  }?
mei_att.meterSigDefault.vis.attribute.meter.showchange =
  
  ## Determines whether the old meter signature should be displayed when the meter signature changes.
  attribute meter.showchange { mei_data.BOOLEAN }?
mei_att.meterSigGrp.vis.attributes = empty
mei_att.midi.vis.attributes = empty
mei_att.mordent.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes
mei_att.mRest.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.cutout.attributes,
  mei_att.extSym.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visibility.attributes,
  mei_att.xy.attributes
mei_att.mRpt.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.expandable.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes
mei_att.mRpt2.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.expandable.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes
mei_att.mSpace.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.cutout.attributes,
  mei_att.xy.attributes
mei_att.multiRest.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.extSym.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.multiRest.vis.attribute.block
mei_att.multiRest.vis.attribute.block =
  
  ## When the block attribute is used, combinations of the 1, 2, and 4 measure rest forms (Read, p. 104) should be rendered instead of the modern form or an alternative symbol.
  attribute block { mei_data.BOOLEAN }?
mei_att.multiRpt.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.expandable.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes
mei_att.note.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.extSym.attributes,
  mei_att.noteHeads.attributes,
  mei_att.staffLoc.attributes,
  mei_att.stems.attributes,
  mei_att.typography.attributes,
  mei_att.visibility.attributes,
  mei_att.visualOffset.ho.attributes,
  mei_att.visualOffset.to.attributes,
  mei_att.xy.attributes,
  mei_att.note.vis.cmn.attributes
mei_att.octave.vis.attributes =
  mei_att.color.attributes,
  mei_att.extender.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.ornam.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.ossia.vis.attributes = empty
mei_att.pad.vis.attributes = empty
mei_att.part.vis.attributes = empty
mei_att.parts.vis.attributes = empty
mei_att.pb.vis.attributes = mei_att.pb.vis.attribute.folium
mei_att.pb.vis.attribute.folium =
  
  ## States the side of a leaf (as in a manuscript) on which the content following the pb element occurs.
  attribute folium {
    
    ## The back of a manuscript page.
    "verso"
    | 
      ## The front of a manuscript page.
      "recto"
  }?
mei_att.pedal.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.lineRend.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes,
  mei_att.pedal.vis.attribute.form
mei_att.pedal.vis.attribute.form =
  
  ## Determines whether piano pedal marks should be rendered as lines or as terms.
  attribute form {
    
    ## Continuous line with start and end positions rendered by vertical bars and bounces shown by upward-pointing "blips".
    "line"
    | 
      ## Pedal down and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered with "* Ped.".
      "pedstar"
    | 
      ## Pedal up and down indications same as with "pedstar", but bounce is rendered with "Ped." only.
      "altpedstar"
  }?
mei_att.phrase.vis.attributes =
  mei_att.color.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.phrase.vis.cmn.attributes
mei_att.rdg.vis.attributes = empty
mei_att.refrain.vis.attributes =
  mei_att.color.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.to.attributes,
  mei_att.visualOffset.vo.attributes,
  mei_att.voltaGroupingSym.attributes,
  mei_att.xy.attributes
mei_att.reh.vis.attributes =
  mei_att.color.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.rest.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.enclosingChars.attributes,
  mei_att.rest.vis.cmn.attributes,
  mei_att.staffLoc.attributes,
  mei_att.staffLoc.pitched.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.sb.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.sb.vis.attribute.form
mei_att.sb.vis.attribute.form =
  
  ## Indicates whether hash marks should be rendered between systems. See Read, p. 436, ex. 26-3.
  attribute form {
    
    ## Display hash marks between systems.
    "hash"
  }?
mei_att.score.vis.attributes = empty
mei_att.scoreDef.vis.attributes =
  mei_att.barring.attributes,
  mei_att.cleffing.vis.attributes,
  mei_att.distances.attributes,
  mei_att.endings.attributes,
  mei_att.keySigDefault.vis.attributes,
  mei_att.lyricStyle.attributes,
  mei_att.measureNumbers.attributes,
  mei_att.meterSigDefault.vis.attributes,
  mei_att.multinumMeasures.attributes,
  mei_att.notationStyle.attributes,
  mei_att.oneLineStaff.attributes,
  mei_att.optimization.attributes,
  mei_att.pages.attributes,
  mei_att.spacing.attributes,
  mei_att.staffItems.attributes,
  mei_att.systems.attributes,
  mei_att.textStyle.attributes,
  mei_att.scoreDef.vis.cmn.attributes,
  mei_att.scoreDef.vis.attribute.vu.height
mei_att.scoreDef.vis.attribute.vu.height =
  
  ## Defines the height of a "virtual unit" (vu) in terms of real-world units. A single vu is half the distance between the vertical center point of a staff line and that of an adjacent staff line.
  attribute vu.height {
    xsd:token { pattern = "\d+(\.\d+)?(cm|mm|in|pt|pc)" }
  }?
mei_att.section.vis.attributes = mei_att.section.vis.attribute.restart
mei_att.section.vis.attribute.restart =
  
  ## Indicates that staves begin again with this section.
  attribute restart { mei_data.BOOLEAN }?
mei_att.slur.vis.attributes =
  mei_att.color.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.curvature.attributes,
  mei_att.curveRend.attributes
mei_att.sp.vis.attributes =
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.space.vis.attributes =
  mei_att.cutout.attributes, mei_att.space.vis.attribute.compressable
mei_att.space.vis.attribute.compressable =
  
  ## Indicates whether a space is 'compressible', i.e., if it may be removed at the discretion of processing software.
  attribute compressable { mei_data.BOOLEAN }?
mei_att.staff.vis.attributes = mei_att.visibility.attributes
mei_att.staffDef.vis.attributes =
  mei_att.barring.attributes,
  mei_att.cleffing.vis.attributes,
  mei_att.distances.attributes,
  mei_att.keySigDefault.vis.attributes,
  mei_att.lyricStyle.attributes,
  mei_att.meterSigDefault.vis.attributes,
  mei_att.multinumMeasures.attributes,
  mei_att.notationStyle.attributes,
  mei_att.oneLineStaff.attributes,
  mei_att.scalable.attributes,
  mei_att.staffItems.attributes,
  mei_att.textStyle.attributes,
  mei_att.visibility.attributes,
  mei_att.staffDef.vis.cmn.attributes,
  mei_att.staffDef.vis.attribute.grid.show,
  mei_att.staffDef.vis.attribute.layerscheme,
  mei_att.staffDef.vis.attribute.lines.color,
  mei_att.staffDef.vis.attribute.lines.visible,
  mei_att.staffDef.vis.attribute.spacing
mei_att.staffDef.vis.attribute.grid.show =
  
  ## Determines whether to display guitar chord grids.
  attribute grid.show { mei_data.BOOLEAN }?
mei_att.staffDef.vis.attribute.layerscheme =
  
  ## Indicates the number of layers and their stem directions.
  attribute layerscheme { mei_data.LAYERSCHEME }?
mei_att.staffDef.vis.attribute.lines.color =
  
  ## Captures the colors of the staff lines. The value is structured; that is, it should have the same number of space-separated RGB values as the number of lines indicated by the lines attribute. A line can be made invisible by assigning it the same RGB value as the background, usually white.
  attribute lines.color {
    list { mei_data.COLOR+ }
  }?
mei_att.staffDef.vis.attribute.lines.visible =
  
  ## Records whether all staff lines are visible.
  attribute lines.visible { mei_data.BOOLEAN }?
mei_att.staffDef.vis.attribute.spacing =
  
  ## Records the absolute distance (as opposed to the relative distances recorded in scoreDef elements) between this staff and the preceding one in the same system. This value is meaningless for the first staff in a system since the spacing.system attribute indicates the spacing between systems.
  attribute spacing { mei_data.MEASUREMENTREL }?
mei_att.staffGrp.vis.attributes =
  mei_att.barring.attributes,
  mei_att.staffGroupingSym.attributes,
  mei_att.visibility.attributes,
  mei_att.staffGrp.vis.attribute.bar.thru
mei_att.staffGrp.vis.attribute.bar.thru =
  
  ## Indicates whether bar lines go across the space between staves (true) or are only drawn across the lines of each staff (false).
  attribute bar.thru { mei_data.BOOLEAN }?
mei_att.stageDir.vis.attributes =
  mei_att.placement.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.syl.vis.attributes =
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes,
  mei_att.horizontalAlign.attributes
mei_att.symbol.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.scalable.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.tempo.vis.attributes =
  mei_att.placement.attributes,
  mei_att.verticalGroup.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.tie.vis.attributes =
  mei_att.color.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.attributes,
  mei_att.xy.attributes,
  mei_att.xy2.attributes,
  mei_att.curvature.attributes,
  mei_att.curveRend.attributes
mei_att.trill.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extender.attributes,
  mei_att.placement.attributes,
  mei_att.extSym.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.visualOffset2.ho.attributes,
  mei_att.visualOffset2.to.attributes,
  mei_att.xy.attributes
mei_att.tuplet.vis.attributes =
  mei_att.color.attributes,
  mei_att.numberPlacement.attributes,
  mei_att.tuplet.vis.attribute.bracket.place,
  mei_att.tuplet.vis.attribute.bracket.visible,
  mei_att.tuplet.vis.attribute.dur.visible,
  mei_att.tuplet.vis.attribute.num.format
mei_att.tuplet.vis.attribute.bracket.place =
  
  ## Used to state where a tuplet bracket will be placed in relation to the note heads.
  attribute bracket.place { mei_data.STAFFREL.basic }?
mei_att.tuplet.vis.attribute.bracket.visible =
  
  ## States whether a bracket should be rendered with a tuplet.
  attribute bracket.visible { mei_data.BOOLEAN }?
mei_att.tuplet.vis.attribute.dur.visible =
  
  ## Determines if the tuplet duration is visible.
  attribute dur.visible { mei_data.BOOLEAN }?
mei_att.tuplet.vis.attribute.num.format =
  
  ## Controls how the num:numbase ratio is to be displayed.
  attribute num.format {
    
    ## Only the num attribute is displayed, e.g., '7'.
    "count"
    | 
      ## Both the num and numbase attributes are displayed, e.g., '7:4'.
      "ratio"
  }?
mei_att.tupletSpan.vis.attributes = mei_att.tuplet.vis.attributes
mei_att.turn.vis.attributes =
  mei_att.altSym.attributes,
  mei_att.color.attributes,
  mei_att.extSym.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.attributes,
  mei_att.xy.attributes
mei_att.verse.vis.attributes =
  mei_att.color.attributes,
  mei_att.placement.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.to.attributes,
  mei_att.visualOffset.vo.attributes,
  mei_att.voltaGroupingSym.attributes,
  mei_att.xy.attributes
mei_att.volta.vis.attributes =
  mei_att.color.attributes,
  mei_att.typography.attributes,
  mei_att.visualOffset.to.attributes,
  mei_att.visualOffset.vo.attributes,
  mei_att.xy.attributes
start = mei_mei | mei_meiHead | mei_meiCorpus | mei_music
sch:ns [ prefix = "mei" uri = "http://www.music-encoding.org/ns/mei" ]
sch:ns [ prefix = "xlink" uri = "http://www.w3.org/1999/xlink" ]
